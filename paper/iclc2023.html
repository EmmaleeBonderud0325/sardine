<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Sardine: a Modular Python Live Coding Environment</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="css/iclc.css" />
  
  
  
</head>
<body>
<div id="header">
<h1 class="title">Sardine: a Modular Python Live Coding Environment</h1>
<ul id="authorlist">
<li>true</li>
<li>true</li>
</ul>
</div>

<h2 class="abstract">Abstract</h2>
<div id="abstract">
<p><strong>Sardine</strong> is a live coding environment and library for
Python 3.10+ focusing on the modularity and extensibility of its base
components (clocks, parser, <em>handlers</em>). Sardine has been
designed to be easily integrated with existing <em>live-coding</em>
environments as both a tool for experimentation and demonstration of
various live coding techniques : temporal recursion, patterning,
integration in various hardware and software setups. Although the tool
is still in active early development, it has already been used in
multiple public performances and algoraves. This paper is dedicated to
the introduction of the <strong>Sardine</strong> system and the
explanation of the main guidelines currently followed by contributors to
the project. It will also present the preliminary results of our work
through practical realizations that served as experimental validation
during the early stages of development. Sardine already supports MIDI
IN/Out, OSC IN/Out and <em>SuperCollider</em>/<em>SuperDirt</em> one-way
communication through OSC.</p>
</div>

<figure>
<img src="images/sardine_intro_picture.png"
alt="Sardine first algorave in Lorient (France), 2022, October 13th. Photography: Guillaume Kerjean." />
<figcaption aria-hidden="true"><em>Sardine first algorave in Lorient
(France), 2022, October 13th. Photography: Guillaume
Kerjean.</em></figcaption>
</figure>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction</h1>
<p>Sardine is a live coding library based on Python 3.10+ focusing on
modularity and extensibility of its base components. Despite still being
in early alpha stage, Sardine is extensively documented on a <a
href="https://sardine.raphaelforment.fr">dedicated website</a> providing
installation guides, tutorials and media examples. Sardine is providing
three main features linked together by the <code>FishBowl</code> – an
environment handling synchronisation and communication between them:</p>
<ul>
<li><p><em>a scheduling system</em> based on asynchronous and recursive
function calls inspired by the concept of temporal recursion <span
class="citation" data-cites="SorensenTemporal">(Sorensen 2013)</span>.
Calls can be scheduled in musical time either on an
<code>InternalClock</code> or a <code>LinkClock</code> based on the Link
Protocol <span class="citation" data-cites="goltz2018ableton">(Goltz
2018)</span>.</p></li>
<li><p><em>a modular handlers</em> system allowing the addition and/or
removal of various I/O (OSC, MIDI) or base components through a central
<code>dispatch</code> environment named the <code>FishBowl</code>. This
is allowing the addition of modular logic without the need of a rewrite
or refactoring of the low-level behavior of the system.</p></li>
<li><p><em>a small and tidy number based pattern programming
language</em> with support for basic generative and musical syntax (MIDI
notes, polyphony, etc…), time-based patterns (<em>clock</em> and
<em>absolute</em> time) and handling of symbolic names.</p></li>
</ul>
<p>Sardine, by design, is in the direct lineage of previously released
Python based libraries such as <a href="https://foxdot.org">FoxDot</a>
<span class="citation" data-cites="kirkbride2016foxdot">(Kirkbride
2016)</span>, <a href="https://github.com/ideoforms/isobar">Isobar</a>
<span class="citation" data-cites="isobar">(Jones, n.d.)</span> or the
very recent <a
href="https://github.com/tidalcycles/vortex">TidalVortex</a> <span
class="citation" data-cites="vortex">(McLean et al. 2022)</span>.
Initially conceived as a demonstration tool, Sardine partially emulates
some selected features from the previously mentioned libraries or from
the dominant live-coding <em>dialects</em> such as the <a
href="https://tidalcycles.org">TidalCycles</a> rhythmical mininotation
<span class="citation" data-cites="mclean2014making">(McLean
2014)</span> or the <a href="https://sonic-pi.net/">Sonic Pi</a>
imperative scheduling syntax <span class="citation"
data-cites="aaron2016sonic">(Sam Aaron 2016)</span>. Sardine is designed
as a general <em>agnostic</em> framework for approaching live coding
using Python. Thus, the library is aiming to support different writing
paradigms and different approaches to live performance based on the
manipulation of source code. The reliance on regular Python asynchronous
functions for scheduling and music writing has for consequence that
Sardine is particulary suited to let each developer-musician follow
their own personal coding style, providing a blank slate for
experimentation on live coding interface building. Furthermore, Sardine
design has been strongly influenced by Andrew Mc Pherson’s and Koray
Tahiroğlu concerns about the <em>idiomatic patterns</em> <span
class="citation" data-cites="mcpherson2020idiomatic">(McPherson and
Tahıroğlu 2020)</span> of usage enforced by computer music softwares,
pushing users to repeat and strictly follow prefered patterns of usage.
Sardine focuses on laying out the base infrastructure needed to support
live coding in Python and wishes to encourage users to imagine diverse
patterning idioms, diverse live coding targets, <em>mini-notations</em>
or user-facing scheduling mechanisms and syntaxes. The modular
architecture followed by the system is a first step towards the
inclusion of more targets and custom <em>input</em> and <em>output</em>
handling.</p>
<p>The version hereby presented – labelled as <code>v0.2.0</code> – is
offering a first look into the complete intended design for the library.
It features a near complete rewrite over the <code>0.1.0</code> version
previously used by members of the french live coding scene and by the
first global Sardine users. It features two different clock
implementations, multiple handlers for <em>I/O</em>
(<strong>MIDI</strong>, <strong>OSC</strong>,
<strong>SuperDirt</strong>), a robust asynchronous temporal recursive
scheduling system and a reimagining of the <em>‘Player’</em> system
previously introduced by FoxDot <span class="citation"
data-cites="kirkbride2016foxdot">(Kirkbride 2016)</span>. Sardine
originality lies in its temporal model, strongly anchored in Python’s
default mechanisms for asynchronous programming. Sardine also features a
modular overall architecture allowing it to be integrated in any live
coding tooling and setup, capable of handling most Python-based
scheduling duties or to be integrated in a larger mixed platform setup.
It has been developed collectively with the help of John Phan based on
user requests and feedback gathered during a first period of
experimentation that saw Sardine being used or integrated by musicians
for several algoraves, network-based jams and musical performances.</p>
<p>Sardine has been developed using exclusively the Python programming
language with few libraries depending on C++ code through bindings to
external libraries. Despite the known shortcomings of Python for
interpreted conversational real time programming (incomplete support of
dynamic programming, slowness relative to other interpreted languages),
we do believe that this language is suitable for the implementation of a
live coding library. The large collection of available librairies and
modules and the popularity of the language ensures the affordance of
good tooling and rich customization and integration options for
different text editors, running environments, etc… Sardine already takes
advantage of a thorough ecosystem of libraries focused on data
<em>input</em>/<em>output</em>, network communication and text
manipulation. Moreover, thanks to its lightweight and clear syntax,
Python can be read by programmers coming from various backgrounds with a
minimal adaptation time, making it a convenient platform for
collaboration and experimentation over the implementation of bespoke
features needed by performers.</p>
<p>In the present article, we will introduce the
<strong>Sardine</strong> system by detailing its goals (1) and base
implementation centered on the scheduling mechanism (2), the
environment/handler system (3) and the mininotation support (4). By
doing so, we hope to highlight the basic principles of its inner working
while providing some context on the current direction taken by the
project and by its users.</p>
<h1 data-number="2"
id="methodology-and-objectives-a-framework-for-exploring-live-coding-in-python"><span
class="header-section-number">2</span> Methodology and objectives: a
framework for exploring live-coding in Python</h1>
<p>Sardine is born out of a curiosity for the implementation of
similarly featured Python-based live-coding libraries such as <a
href="https://foxdot.org">FoxDot</a>, <a
href="https://github.com/ideoforms/isobar">Isobar</a> or the very recent
<a href="https://github.com/tidalcycles/vortex">TidalVortex</a> <span
class="citation" data-cites="vortex">(McLean et al. 2022)</span>. At its
inception, the Sardine project was thought as an attempt to provide a
functional but barebones live coding library for demonstration purposes
in a dissertation manuscript; a library capable enough for showing the
impact of design and implementation choices on the possibilities of
musical expression and on the expressiveness offered by a live coding
environment. Therefore, a particular attention has been given to
reproducing or <em>at least</em> paving the way for the reproduction of
different coding styles and representation of timed musical information.
Initial work for the <code>0.1.0</code> has been based upon an older
personal attempt at writing a live coding library, then named
<em>ComputerTalk</em><a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>. The base design, not suitable with
our goal, has quickly evolved after the first initial public tests. It
has been decided to aim for an increased modularity of the system in
order to support and maximise the <em>input</em> and <em>output</em>
options offered by Sardine. This has allowed for the quick integration
of the tool with other neighbor interfaces and live coding
environments.</p>
<p>The development of Sardine began initially in a period of frantic
collaborations and joint performances with the parisian <em>Cookie
Collective</em> <span class="citation"
data-cites="cookiewebsite">(Collective 2016)</span> and the Digital
Audio Community from Lyon (<em>th4</em>, <em>rAlt144MI</em>, etc..).
Stemming from the <em>demoscene</em> and shader-coding scene, the
<em>Cookie</em> is known for its complex multimedia performances, each
member relying on bespoke hybrid audio-visual setups ranging from low
end computing devices to complex synthesizers and circuit-bended video
mixers. It is also known for working in an improvised manner,
customising its setup for each venue depending on the audience needs and
expectations. The need to adapt and customize the live coding interfaces
already in use to the needs of each performance and each artist gave
rise to the idea of creating a modular interface that could be used and
mastered by every member of the collective, while allowing for jam-ready
synchronisation with other musicians and live-coders. The recent
splitting of Foxdot’s development into several scattered branches
reinforced the need for a central, customizable and easily editable
Python interface, the software being particularly used in the french
live coding community. Due to the open-ended nature of the development
process, Sardine has been gradually shifting towards its current modular
architecture, allowing each performer to refine the nature of the
<em>inputs</em> and <em>outputs</em> controllable through the system,
from simple MIDI note output to more convoluted custom Sysex and OSC
message support. The invaluable help and expertise from John Phan has
allowed for a complete deep rewrite of every base mechanism. With
Sardine’s finalization of its new framework marks the beginning of a new
stage in the development process, focused on introducing new features
and improving existing ones. This process is managed in an
<em>ad-hoc</em> manner, by encouraging users to propose ideas and
contribute to an extensively documented codebase.</p>
<h1 data-number="3" id="sardine-implementation"><span
class="header-section-number">3</span> Sardine implementation</h1>
<img src="images/usage.png" alt="Sardine usage workflow" /><br />

<p>Sardine is implemented and distributed as two complementary Python
modules: <code>sardine</code> and <code>fishery</code>. These modules
will typically work hand in hand to provide the interface to the user.
<code>fishery</code> provides amendments to the default Python
asynchronous REPL<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> and constitutes the entry point for
the Sardine system, accessible by typing <code>python -m fishery</code>
or simply <code>fishery</code> right after install. <code>fishery</code>
is nothing more than a slightly modified version of the base Python
asynchronous REPL. Importing it also imports <code>sardine</code> and
will <em>de facto</em> start a new playing session. As a helper for new
users, a terminal based configuration client
(<code>sardine-config</code>) is also provided and can be used to setup
various options before starting <code>fishery</code>. Configuration
files are stored in a default standard location depending on the OS
currently in use (<code>e.g.</code> <code>.local/share</code> on UNIX
systems). Configuration files include a general JSON file, a blank
<code>.py</code> usable to load user-specifc Python code at the start of
each session and the files needed to properly configure a
<em>SuperCollider</em>/<em>SuperDirt</em> session. This architecture –
despite its initial complexity – makes Sardine more accessible to novice
users who may not be familiar with using the command line and Python
development tools. Files relative to Sardine will be kept in a single
configuration folder. Note that modularity of the system is greatly
encouraged, with many <em>input</em> and <em>output</em> components
being disabled by default. This makes the installation of any
audio-backend like <em>SuperCollider</em> entirely optional, the latter
being considered more as a target than a dependency.</p>
<p>Thanks to the generally great IDE support for Python,
<em>Sardine</em> is not shipping with its own text-editor or dedicated
text editor plugin. Sardine has been tested with third-party code
writing tools such as <em>Atom</em>, <em>VSCode</em>, <em>Emacs</em>,
<em>Vim/Neovim</em> or even <em>Jupyter Notebooks</em>. Each one of
these text editors generally support the spawning of an asynchronous
REPL and the piping of code from a text buffer to a running interpreter.
The setup process for each one of these interfaces generally relies on
the installation of a simple general-purpose Python plugin<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.
This has lead us to consider the Python interpreter as a code receiver
and monitoring tool mainly used to mirror useful information to the
user, such as the state of the SuperCollider sub-process, of the event
loop and <em>runners</em>, etc… Every other operation is directly
handled by calls internal to a Sardine session.</p>
<p>Reliance on any audio backend can / will require the boot of another
application. For the time being, only <em>SuperCollider</em> and
<em>SuperDirt</em> are natively supported by their own Sardine
components. Even though the installation of these backends is still
necessary for users willing to use them, integration is done in such a
way that there is no need – later on – to actively take care and monitor
any of these dependencies. A basic API to <em>SuperCollider</em> and
<em>SuperDirt</em> is offered through the <code>SC.send()</code>
function, allowing to run arbitrary <code>sclang</code> code in the
subprocess session. The addition of more automatically-managed
audio-backend <em>subprocesses</em> is planned and will be explored in
the coming months (deeper <em>SuperCollider</em> integration,
<em>CSound</em> backend, etc…). Clever combination of Sardine provided
functions is already allowing some amount of customization for
patterning hardware and software synthesizers through MIDI or OSC.</p>
<p>Being packaged as a regular Python module, Sardine makes use of the
<code>pyproject.toml</code> module configuration and packaging format
defined by PEP 660. No third party tool is currently required to install
Sardine other than a base <em>complete</em> installation of a modern
(3.10+) Python runtime. The package has recently been packaged and
released on <code>Pypi</code>, allowing any Python user to install it
using the <code>pip install sardine-system</code> command. Work has been
done to properly ensure that every C++ dependency is served on our own
and that <code>wheels</code> – binary distribution of compiled packages
– are available for every major platform. This has solved a long lasting
issue that prevented users from installing Sardine on the recently
released Python 3.11 version.</p>
<h2 data-number="3.1" id="event-loop-and-scheduling-system"><span
class="header-section-number">3.1</span> Event loop and scheduling
System</h2>
<h3 data-number="3.1.1" id="event-loop"><span
class="header-section-number">3.1.1</span> Event loop</h3>
<img src="images/event_loop.png" style="width:100.0%"
alt="Event Loop Diagram" />`
<p>Sardine is making use of the asynchronous programming features
offered by Python. More specifically, Sardine takes advantage of the
little known <code>asyncio</code> REPL prototype introduced by Python
3.8 <span class="citation" data-cites="asynciorepl">(Yuri Selivanov,
n.d.)</span>. The UVLoop <span class="citation"
data-cites="uvloop">(Yury Selivanov 2016)</span> drop-in replacement
event loop is also being used – but not on Windows – in order to speed
up the scheduling of asynchronous calls. Several hot-patches to the
asynchronous loop have been introduced by John Phan
(<em>thegamecracks</em>) in order to make its behaviour consistent on
every major OS platform. Sardine is laid out as a series of abstractions
built on the base loop, making it aware of tempo and timing. Sardine
<em>clock</em> (either the <code>internal</code> or <code>link</code>)
clock automatically starts whenever the system is imported but pure
asynchronous calls can still be handled even if the clock is being
stopped. The usage of the <code>LinkClock</code> will allow Sardine
users to link their session to a global tempo shared by other users of
the local network, allowing networked synchronisation of several Sardine
or Link capable hardware/software. Every clock provides the same
interface, allowing the system to retrieve the current bar, beat and
current position in <em>musical</em> time. Time drift compensation and
the time shifting needed by some functionalities is handled entirely by
the low-level event loop system.</p>
<p>The consistency of the asynchronous clocks is being covered by tests
(in the <code>tests/</code> folder) and has been checked to be
<em>on-par</em> with the alternatives offered by similar, more widely
used threaded clocks. Development of such a feature has proven to be a
difficult technical challenge due to the specificity of the task and of
the relatively obscure and scarcely documented inner workings of
internal OS’s schedulers. Threaded components are still used for various
<em>I/O</em> operations in order to lighten the load of the event loop
and to alleviate the temporal cost of message processing. Note that many
<em>Sardine</em> components are entirely optional and can be activated
on demand by the user. Only the <code>clock</code>,
<code>AsyncRunners</code> and <code>SleepHandler</code> constitute the
core abstractions needed over Python <code>asyncio</code> loop. Basing
the custom event loop on top of the Python asynchronous interpreter is
allowing for the evaluation of any top-level asynchronous
<code>await</code> instructions that would be forbidden by the main
interpreter. It must be noted that Python <code>asyncio</code> features
might behave differently on every major OS due to its binding with
system-level mechanisms.</p>
<h3 data-number="3.1.2" id="scheduling"><span
class="header-section-number">3.1.2</span> Scheduling</h3>
<img src="images/asyncrunner_diagram.png" style="width:51.0%"
alt="Lifetime of an asynchronous ‘swimming’ function" /> 
<p>Python is known to be a language that doesn’t have native support for
tail-call recursion <span class="citation"
data-cites="guido1 guido2">(Rossum 2009b, 2009a)</span>, making the
infinite recursion of a function a delicate task. To properly support
this central feature, a complex system based on John Phan’s
<code>AsyncRunners</code> has been developed and is used as the basis
for every repetitive operation – such as a pattern – scheduled with
Sardine. In the spirit of the metaphor followed by the whole program, a
temporal recursive function is nicknamed a <em>swimming function</em> by
the development team and is labelled in code as an
<code>AsyncRunner</code>. A <em>swimming function</em> can be started
using the <code>@swim</code> decorator<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>,
stopped using the <code>@die</code> decorator and can receive updates
all along its lifetime on the scheduler.</p>
<p>Decorating a Python function is enough to push a given synchronous or
asynchronous function to the scheduler, making it repeat every
<code>p</code> (for <code>period</code>), a time measured in beats
relative to the clock currently in use. The content of a given function
will be re-evaluated for every recursion cycle and state can be
preserved either by passing arguments to a subsequent call or by relying
on global state. <em>Swimming functions</em> are a powerful construct
for building abstractions dealing with time, code re-evaluation and
dynamic lifetime management of code components. Iterators, for example,
can be built by incrementing a variable passed as argument. Random
generators can be built by calling a simple native random function whose
result will be dynamically updated for each recursion.</p>
<p><em>Swimming functions</em> will automatically start
<em>on-the-beat</em>. The start of a function can target a specific
point in musical time by specifying a special <code>snap</code> argument
that is understood as an offset, in beats, from the beginning of the
next bar. The <code>period</code> argument of a given function is the
only required argument for a function to be considered as a valid
<em>swimming function</em>. Every other component of the
<em>Sardine</em> system is based on the assumption that its evaluation
context will be the <em>swimming function</em>. They can receive any
arbitrary Python code and/or call the various players defined by the
Sardine system to properly handle <em>I/O</em> operations. Thus, the
prototype of a basic musical function using the previously defined model
looks like the following:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">@swim</span>                                      <span class="co"># swimming decorator (swim or die)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> swimming_function(p<span class="op">=</span><span class="fl">0.5</span>, i<span class="op">=</span><span class="dv">0</span>):         <span class="co"># p: (period), i (custom iterator)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&#39;I am swimming in time.&#39;</span>)        <span class="co"># genuine function call</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    D(<span class="st">&#39;bd, hh, cp, hh&#39;</span>, i<span class="op">=</span>i)               <span class="co"># call to the &#39;Dirt&#39; SuperDirt interface.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    ...                                    <span class="co"># other user specified code</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    again(swimming_function, p<span class="op">=</span><span class="fl">0.5</span>, i<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span>) <span class="co"># recursion callback with argument passing</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># remove the call to again() to stop the recursion from happening, stopping the runner.</span></span></code></pre></div>
<p>Multiple abstractions can be built on top of the basic <em>swimming
function</em> mechanism, allowing for a terser user-facing syntax. We
believe that building abstraction on top of the <em>swimming
function</em> is helpful to allow newcomers to get a grasp on the
temporal model offered by the system. The FoxDot’s inspired
<em>surfboard</em> mechanism is currently the only available abstraction
demonstrating this principle. It automatically handles its own
scheduling logic and provides its own iterators needed by the default
parser. As demonstrated by the following example, it also provides
additional musical logic without the need for altering the base
scheduling logic, thus adding a completely new – and optional – flavour
of patterning/scheduling for Sardine users. Following this model,
Sardine future versions are likely to include user-based modes of
playing built upon the basic abstractions provided by the library.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Pa <span class="op">&gt;&gt;</span> d(<span class="st">&#39;bd, hh, cp, hh&#39;</span>, p<span class="op">=</span><span class="fl">0.5</span>) <span class="co"># Terser version of the above swimming function.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>Pb <span class="op">&gt;&gt;</span> d(<span class="st">&#39;voodoo&#39;</span>, span<span class="op">=</span><span class="dv">2</span>)        <span class="co"># &#39;span&#39; extends the inner-hidden swimming </span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                                 <span class="co"># function duration to span over twice the </span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="co"># duration of Pa.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>Pc <span class="op">&gt;&gt;</span> d(<span class="st">&#39;voodoo, tabla&#39;</span>, legato<span class="op">=</span><span class="fl">0.1</span>, span<span class="op">=</span><span class="dv">2</span>, p<span class="op">=</span><span class="st">&#39;1,2,3,4&#39;</span>) </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                                 <span class="co"># duration values of Pc will be fitted to the </span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                                 <span class="co"># duration of the given timespan.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>Pc <span class="op">&gt;&gt;</span> <span class="va">None</span>                       <span class="co"># alternative to @die</span></span></code></pre></div>
<p>Sardine’s <code>sleep()</code> method, worthy of note, has been
overriden from the default Python <code>time.sleep()</code> function
that would, if used, block the event loop. This special function will
allow to defer the execution of any statement or expression defined
thereafter to <em>x</em> beats in the future even if these events take
place after the next recursive call. This latter phenomenon is known and
referred to as <em>oversleeping</em>. Unlike <code>time.sleep()</code>,
this function does not actually block the function from running to its
end. Instead, it temporarily affects the value of
<code>clock.time</code> and extends the perceived time of methods using
that property. This mechanism has been introduced to mimick the
<code>sleep()</code> statement found in other live coding tools such as
Sonic Pi <span class="citation" data-cites="aaron2014temporal">(Samuel
Aaron, Orchard, and Blackwell 2014)</span>.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">@swim</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sonorous_cake(p<span class="op">=</span><span class="dv">2</span>, i<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    D(<span class="st">&#39;jvbass!4, jvbass:4&#39;</span>, midinote<span class="op">=</span><span class="st">&#39;C,Eb,G,D&#39;</span>, i<span class="op">=</span>i) <span class="co"># SuperDirt calling sample playback</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    sleep(<span class="dv">1</span>)                                          <span class="co"># Deferring further operations to next beat</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    D(<span class="st">&#39;jvbass:4!4&#39;</span>, midinote<span class="op">=</span><span class="st">&quot;C&#39;, C&#39;&#39;!3&quot;</span>, i<span class="op">=</span>i)        <span class="co"># Other sample playback</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    again(sonorous_cake, p<span class="op">=</span><span class="dv">2</span>, i<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span>)                  <span class="co"># Recursive call</span></span></code></pre></div>
<h2 data-number="3.2" id="environment-dispatch-and-handlers"><span
class="header-section-number">3.2</span> Environment, dispatch and
handlers</h2>
<h3 data-number="3.2.1" id="the-fishbowl"><span
class="header-section-number">3.2.1</span> The FishBowl</h3>
<p>While scheduling takes an important part in the overall modular
design of the Sardine library, its logic wouldn’t function without the
central piece of the system called the <code>FishBowl</code>. The
<code>FishBowl</code> is an environment for software components handling
the synchronisation and coordination between all the different pieces
composing a Sardine system. This environment has been designed so that
every component of the system can talk or access transparently and
instantly to the data held by any other component. The
<code>FishBowl</code> is a central coordination mechanism allowing
components to subscribe to it throuh <code>hooks</code> and to react to
every message through a <code>dispatch</code> system. The
<code>bowl.dispatch('stop')</code> message is an example of such an
event – stopping the clock – asking for the collaboration and immediate
response of multiple components. Naturally, some components are more
important than others and can thus be considered as <em>hard</em>
dependencies. Other <em>soft</em> dependencies, mainly the various
<em>I/O</em> handlers available, can be added and removed from the
environment/session at any point in time. The <code>clock</code> and the
<code>parser</code> are two <em>hard</em> dependencies that cannot be
removed but which can be swapped. They provide the basic mechanisms
needed by every other modular component to properly function. The
fluidity of the <code>FishBowl</code> mechanism allows for the addition
and removal of modular logic to any Sardine system capable of answering
to any message currently being dispatched to neighbor components. One
can switch from the <code>internal</code> to the <code>link</code> clock
<em>on-the-fly</em> if the need arises to synchronise with other
players, or add a new OSC receiver. Even though the current version of
Sardine does not feature multiple parsers, the parser can also be
switched.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>bowl <span class="op">=</span> FishBowl(clock<span class="op">=</span>clock(tempo<span class="op">=</span>config.bpm, bpb<span class="op">=</span>config.beats)) <span class="co"># declaring the bowl</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>midi <span class="op">=</span> MidiHandler(port_name<span class="op">=</span><span class="bu">str</span>(config.midi))                   <span class="co"># instance of new component</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>bowl.add_handler(midi)                                           <span class="co"># adding to the environment</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> midi.send                                                    <span class="co"># aliasing for playability</span></span></code></pre></div>
<h3 data-number="3.2.2"
id="case-study-of-a-component-the-midi-sender"><span
class="header-section-number">3.2.2</span> Case-study of a component:
the MIDI sender</h3>
<p>In the previoous code example, a MIDI handler was added to the
<code>FishBowl</code>, giving access to a new MIDI output.
<em>Senders</em> are one type of Sardine modular components which
requires the collaboration of multiple parts of the system to function
properly. The <code>M</code> (<code>midi.send</code>) function serves as
the central output and user interface for this component. It is the only
function that the user will be playing with during a session. To operate
efficiently, it requires an access to the <code>parser</code> for
patterning and composing a valid message, to the <code>clock</code> for
sending its message in musical time and to the <code>SleepHandler</code>
to precisely time calls between a ‘note on’ and ‘note off’ message. By
declaring itself to the environment, it gains access to these much
needed features that will be accessed transparently without having to
deal with the innermost lower-level logic. Consequently, user
interaction can be carefully implemented through one minimal function
only, letting the system handle the hard and slightly convoluted
asynchronous scheduling calls taking place in the background.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># basic MIDI note scheduling (duration handled by bowl.SleepHandler)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>M(note<span class="op">=</span><span class="dv">60</span>, velocity<span class="op">=</span><span class="dv">100</span>, channel<span class="op">=</span><span class="dv">0</span>, dur<span class="op">=</span><span class="fl">0.25</span>)                        </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># patterning a similar call with added component-specific logic (strings parsed by bowl.parser)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>M(note<span class="op">=</span><span class="st">&#39;C@penta, C.., G3&#39;</span>, velocity<span class="op">=</span><span class="st">&#39;80~100&#39;</span>, channel<span class="op">=</span><span class="st">&#39;[0:10]&#39;</span>, i<span class="op">=</span>i, r<span class="op">=</span><span class="dv">2</span>) </span></code></pre></div>
<p>Similar <em>senders</em> or <em>handlers</em> can be implemented for
various operations requiring collaboration between multiple parts of the
system. Given that each of these adhere to the <code>BaseHandler</code>
abstract base class, adding a component to Sardine does not require any
particulary complex addition or refactoring to the base system. Most of
the internal critical components of Sardine work by taking advantage of
interconnexion of every component, allowing one component to affect the
behavior of the whole environment if ever needed.</p>
<h2 data-number="3.3" id="sardine-pattern-language"><span
class="header-section-number">3.3</span> Sardine Pattern Language</h2>
<h3 data-number="3.3.1" id="sardine-default-pattern-language"><span
class="header-section-number">3.3.1</span> Sardine default pattern
language</h3>
<p>For the sake of demonstration and usability, a small programming
language specialised in the writing of musical patterns has been
developed for Sardine. This <em>mininotation</em> language has been
developed using the <a
href="https://github.com/lark-parser/lark">Lark</a> (<code>LALR</code>
parsing). Its entire source code is directly included in the
<code>sardine</code> module (in the <code>sequences/</code> folder). The
need for the creation of a <em>domain specific language</em> (DSL) has
been felt in order to deal with the limited support provided by Python
for syntactic macros (<em>à la Lisp</em>) and operators overloading. The
use of the <em>hard</em> <code>parser</code> dependency is limited to
parsing string arguments provided to any <em>handler</em>
<code>send</code> method. These <code>send</code> functions, common to
any sender, are acting as <strong>the principal interface, for
patterning and output alike</strong>. They provide a convenient
user-facing interface for the creation of complex musical and data
pattern evolving through time in the context of a <em>swimming
function</em>. Patterns play an important role in the workflow of
audio/visual live coders, allowing them to define rich evolving
structures spanning over time <span class="citation"
data-cites="magnusson2018performing">(Magnusson and McLean,
n.d.)</span>. A generic interface – named <code>Pat()</code> – is also
made available to Sardine users in order to increase the
<em>patternability</em> of any given Python code or function call done
in the context of recursive <em>swimming</em> calls. This basic test
pattern language is best defined as a rich and terse interface dealing
with lists of arbitrarily typed elements ranging from numbers to MIDI
notes, samples or synthesizer names, OSC addresses, etc… The string
input(s) composed by the user for each keyword argument provided to a
<code>send</code> method is always ultimately resolved by the parser as
final arbitrarily-nested list used for composing an output message.
Quite possibly, multiple instances to different parsers will be
supported in future versions as a way to vary the idioms usable to
compose patterns. For now, only one parser is supported in each instance
of the <code>FishBowl</code>. Its use is entirely optional for users
willing to work with different methods.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>Pat(<span class="st">&#39;1, 2, 3, 2~40, 5!4, C@fifths&#39;</span>, i<span class="op">=</span>i) <span class="co"># standalone call to the parser, yielding one value</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>D(<span class="st">&#39;amencutup:[1,10]&#39;</span>, legato<span class="op">=</span><span class="st">&#39;0.1~0.8&#39;</span>, room<span class="op">=</span><span class="st">&#39;0.5&#39;</span>, dry<span class="op">=</span><span class="st">&#39;[0.1,0.5:0.05]&#39;</span>, i<span class="op">=</span>i) <span class="co"># several calls nested</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                                         <span class="co"># inside a more densely composed call to SuperDirt.</span></span></code></pre></div>
<p>Extensive support has been dedicated to list-based operations for the
composition of sequences. Every basic binary arithmetic operator such as
<code>+</code>, <code>-</code>, <code>*</code> or <code>%</code>, can
work either on single tokens or on lists (on both sides). Lists can be
arbitrarily nested. List slicing and value extraction has been
re-implemented in a fashion similar to that of its Python counterpart.
Unary operators such as <code>abs()</code>, <code>sin()</code> or
similar scientific calculation functions work in a similar way, with the
function being functionally mapped to each element of the list if
needed. Custom convenience operators have also been defined such as
<code>x~y</code> (choosing a number in range), <code>x|y|z</code>
(choosing between <em>x</em> elements). Other custom operators have been
borrowed to similar pattern languages such as <em>Ziffers</em> or
<em>TidalCycles</em>: <code>'</code> for octave up, <code>.</code> for
octave down, <code>:</code> for sample choice, <code>!</code> for
repetition; among many others. Basic music notation is handled through
the conversion of specific tokens to single MIDI notes (<code>C#4</code>
or <code>Do#4</code> parsed as <code>61</code>), silences (a dot
<code>.</code> or multiple dots <code>...</code>), list objects
(<code>C@penta</code> parsed as <code>[60,62,64,67,69]</code>) with
support for transposition, chord and structure inversion, etc… A
complete list of all supported operations is provided to the user
through Sardine’s documentation. Support for random and generative
structures – even though fairly basic – has been implemented. Once more,
the implementation of this feature has been facilitated by the
definition of the <em>parser</em> as a component of the
<code>FishBowl</code>. This allows the parser to query the environment
and <code>bowl.clock</code> in search of semi-random number generators
such as the measure number (<code>m</code>) or current execution time
given as clock time (<code>$</code>).</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Middle-C MIDI Note with default velocity and channel (M, alias for midi.send)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>M(note<span class="op">=</span><span class="dv">60</span>)                         </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># C major natural seventh chord with velocity in between 80 and 120, channel either 0, 1 or 2</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>M(note<span class="op">=</span><span class="st">&#39;&lt;C@maj7&gt;&#39;</span>, velocity<span class="op">=</span><span class="st">&#39;80~120&#39;</span>, channel<span class="op">=</span><span class="st">&#39;0|1|2&#39;</span>, i<span class="op">=</span>i) </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># SuperDirt call, picking samples &#39;0&#39; to &#39;20&#39; in order in the &#39;drum&#39; folder. Speed parameter</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ramping from 1 to 10 in increments of 2, shape is the sin function of current time divided by 2.</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>D(<span class="st">&quot;drum:[0:20], speed=&#39;[1:10,2]&#39;, shape=&#39;sin($)/2&#39;, i=i)</span></span></code></pre></div>
<p>The querying of values in the multiple patterns defined in each
<em>sender</em> is done by providing a single pattern-wide
<em>iterator</em> (labelled as <code>i</code>) as an argument to each
<code>send</code> function. Indexing errors are taken care of by making
this index cyclical over the length of each pattern. The design of the
iterator is entirely left to the care of the user. Hence, the preferred
method for browsing through the reduced list patterns can be chosen
depending on context: sequentially, in reverse, using a random number
generator, etc… More arguments, namely <code>rate</code> and
<code>div</code>, can help in specifying how the iterator will be
applied to the gathered patterns, adding another layer of patterning –
and complexity – on top of the base mechanism:</p>
<ul>
<li><code>rate</code> (aliased as <code>r</code>): <em>compress</em> or
<em>extend</em> the number of iterations needed to move from a list
index to the preceding/next. Used as an equivalent to <em>slowing
down</em> or <em>speeding up</em> the iteration over patterns.</li>
<li><code>div</code> (aliased as <code>d</code>): a modulo operation
between the iteration count and <code>div</code> that will determine if
the pattern will be played. This is mainly used to generate interesting
rhythms by confronting <em>senders</em> calls with different
<code>div</code>s.</li>
</ul>
<p>In our opinion, the iteration-based pattern system suits nicely to a
system based on the concept of temporal recursion. Recursive operations
are often used as iteration tools in functional approaches to
programming. Multiple iterators can be used in the same pattern by
playing around with the <code>Pat()</code> mechanism previously
described. This allows for the creation of arbitrarily complex patterns
composed of multiple values assigned to any parameter accessible through
a given <em>sender</em>. Even though the list of features provided by
the pattern language is dense, its overall architecture is not
particularly complex and allows for quick customisation and feature
addition from a user willing to do so. This parser also provides a basic
workaround for most <em>patterning duties</em> while awaiting for the
inclusion of new parsers in future versions of the software.</p>
<h3 data-number="3.3.2"
id="planned-extensions-of-the-parser-mechanism"><span
class="header-section-number">3.3.2</span> Planned extensions of the
parser mechanism</h3>
<p>The basic Sardine parser has proved to be useful for increasing the
playability of the system. However, multiple extensions have been
planned and will hopefully be included in future versions. These
additions can be split in two categories, the first focusing solely on
additions and corrections to the basic parser, the other to the addition
of new parsers and to the inclusion of more mininotations. Both are
currently priorities of the development team following the end of the
rewrite. Support for the <a
href="https://github.com/amiika/ziffers">Ziffers</a> numerical notation
created by Miika Alonen, defined as a PEG parser, has already started to
take shape. To be properly supported, <em>Ziffers</em> will require the
inclusion of a new type of <code>Player</code> similar to the previously
mentioned <em>surfboards</em>, relying on the low-level scheduling
mechanism. This will allow to test the ease of inclusion of new
patterning and live coding paradigms to the Sardine system while opening
new ways to write complex melodies and harmonic content. A refactoring
of the basic parser is also currently being worked on. Although the
pattern language currently supports the definition of custom operators
and the function calls with an arbitrary number of arguments, we do not
consider that the language is advanced enough to support all the
operations we want to support. The addition of high-order functions and
easier function calls will now be prioritized, as well as better
matching for basic tokens. The basic parser aims to support a large
range of functions typically found in most functional programming
languages, paving the way for better support of a more functional
pattern writing style typically found in other historical live coding
libraries.</p>
<h1 data-number="4" id="sardine-usage"><span
class="header-section-number">4</span> Sardine usage</h1>
<img src="images/sardine_code_paper_fig.png"
alt="Sardine in use at the Zorba" /><br />

<p>Over its relatively short timespan, from september to december 2022,
Sardine has already been used multiple times for public music
performance. The thrill and danger arising from using an unstable and
unpolished software has constituted an obstacle as well as an appealing
perspective for most users <span class="citation"
data-cites="roberts2018">(Roberts and Wakefield 2018)</span>. Jams,
informal meetings and dialogue with the wider live coding community were
also of the utmost importance to study the relevance and/or the
inefficiency of integrating Sardine, in often already pre-established
musical contexts. Here we mention a few specific examples of Sardine
usage, and show how being able to live code in Python provides unique
advantages (and also potential disadvantages). Numerous specialised
devices or handlers have been created to facilitate Sardine interacting
with other systems. Hybridations between multiple live coding
environments, such as <em>Sardine</em>/<em>TidalCycles</em> and
<em>Sardine</em>/<em>Sonic Pi</em> have been tried successfully. Initial
failures mostly arised from improper or careless implementations of the
synchronization mechanism. Documentation pertaining to the
implementation of live-coding oriented musical clocks and
synchronization mechanism is scarce and most of it had to be inferred
from the inner workings of similar open-source libraries. In order to
help with the collective effort of documenting live coding practices, we
hope to upload a very thorough explanation of the system on the Sardine
website to help future developers.</p>
<p>A proto-sender specialised in SysEx communication with a Yamaha TX7
synthesizer unit has been designed by Raphaël in order to enhance
melodic and timbral capabilities of <em>Ralt144MI</em> (Rémi Georges)
current live coding setup, previously mostly based on TidalCycles, MIDI
controllers and audio-video hardware. Using a simple dictionary of
<code>lambda</code> functions, this mechanism uses the previously
described <code>Pat()</code> function to provide a general patterning
interface for each individual parameter defined in the MIDI
specification of the unit. Subsequent performances led to the inclusion
of more bespoke mechanisms that ultimately made their way into the main
codebase, having been proved useful in the context of live performances
(<code>span</code>, <code>snap</code>, support for polyphony, etc…).
This experience also proved the usefulness of adding better support for
the definition of custom-fit <em>senders</em> and output/patterning
interfaces.</p>
<p>At the Intelligent Instruments Lab in Reykjavík, Jack Armitage has
been using Sardine to live code the Magnetic Resonator Piano (MRP) <span
class="citation"
data-cites="mcphersonAugmentingAcousticPiano2010">(McPherson and Kim
2010)</span>. In this case, Sardine enabled developing a Python API
client for the MRP much more interactively, due to being able to
redefine <code>@swim</code> functions on the fly. Another attractive
feature of Sardine being written in Python in this case, is that the
entire Python ecosystem can be explored for machine learning based
approaches to instrumental control and interaction<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.
This also positions Sardine as a bridging platform for researchers and
practitioners interested in hybrid live coding interfaces, as in this
case where live coding and instrumental practices are blurred. Jack
Armitage has also been live coding artificial life simulations using
Sardine, in the <em>Tölvera</em> library as part of the <em>Agential
Scores</em> project <span class="citation"
data-cites="agential">(Armitage 2022)</span>. This is one of the first
examples of Sardine being used for visual output. In this case, the
Taichi numerical simulation library was able to run its animation frame
loop as a <code>@swim</code> function, with Sardine’s recursion
occurring fast enough to give 60fps graphics<a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.
These early examples showed the diversity of approaches that are
possible in the Python ecosystem, and they also usefully highlighted
usability pain points and performance bottlenecks with Sardine. As a
result, substantial rewriting efforts have been taking place to
accommodate these needs. Motivation for the rewrite process was found in
the perspective to support more of these creative endeavours that would
be hard to undertake in more closed or less configurable live coding
systems.</p>
<h1 data-number="5" id="conclusion"><span
class="header-section-number">5</span> Conclusion</h1>
<h2 data-number="5.1" id="current-issues-and-shortcomings"><span
class="header-section-number">5.1</span> Current issues and
shortcomings</h2>
<p>Sardine is both a new software/environment and an architecture model
for a Python based live coding library. Developed only by a small
dedicated team of developers with few enthusiastic users, some features
are already hard to keep a track of for they are not often used. Much
needed updates to specific parts of the system are currently delayed to
address more urgent concerns. To help keeping track of the current state
of the system, tests have recently been introduced. However, better code
coverage is still much needed to track each specific component and their
mutual interaction. Only time critical parts of the system are currently
extensively covered. Most of the rewrite work for <code>v.0.2.0</code>
has been focused on improvements to the temporal model and component
handling. Although very promising, it remains fragile and requires
careful and time-consuming testing to keep track of regressions and
possible issues brought by additions to the model. Regular updates are
being provided to increase the <em>playability</em> of the system.</p>
<p>Sardine is in dire need of documentation focused on new and
unexperienced users. The installation process – despite being now more
accessible than ever – still requires the manual configuration of a
suitable text editor and the installation of a full Python runtime. The
documentation currently only provides a thorough tour and exploration of
the system but lacks friendly videos, text tutorials and contents that
could lead to the adoption of Sardine by more users. As a temporary
solution for demonstrating the capabilities of the system, we actively
provide the code used by performers in a special <code>Demo</code>
section included on the website. Automatic documentation of the codebase
is planned to help with the process of maintaining good technical
documentation, liberating time to focus on user-focused contents. Every
part of the source code is extensively documented for contributors, but
currently unavailable to surface users not willing to deep dive into the
source code. The modularity of Sardine can be considered as its major
strength and weakness. The first configuration of the software can be
quite intimidating for newcomers that doesn’t yet know what task they
wish to accomplish using Sardine (MIDI, OSC, SuperDirt, etc..). Most
options are disabled by default and must be added manually to configure
a session.</p>
<h2 data-number="5.2" id="learning-contributing-testing"><span
class="header-section-number">5.2</span> Learning, contributing,
testing</h2>
<p>The Sardine system project is already freely usable and modifiable by
its users. It is currently hosted on GitHub under the GNU General Public
License v.3.0. We warmly encourage anyone interested to actively try
this experimental system in order to help us with chasing bugs and/or
collectively build this new live coding system. A Discord server and a
TOPLAP <code>#sardine</code> channel are used for communication around
the project. Sardine is currently by no mean as complete or as fully
featured as other existing propositions used by the community. We are
still in the process of catching up with known alternatives, thinking as
Sardine as a way to extend or collaborate with other musicians and
visualists using different live coding environments.</p>
<h1 data-number="6" id="acknowledgments"><span
class="header-section-number">6</span> Acknowledgments</h1>
<p>I warmly thank my thesis supervisors Laurent Pottier and Alain
Bonardi for their support and advice in the creation of this tool. I
thank the doctoral school <em>3LA</em> from the University of Lyon for
the funding it provided to this research. I extend my thanks to the
musicians and friends who allowed me to take <strong>Sardine</strong> on
stage and to present it to a wider audience these few last months: the
<strong>Cookie Collective</strong>, Rémi Georges, Yassin Siouda and many
more from the online Sardine chat channels.</p>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
role="doc-bibliography">
<div id="ref-aaron2016sonic" class="csl-entry" role="doc-biblioentry">
Aaron, Sam. 2016. <span>“Sonic Pi–Performance in Education, Technology
and Art.”</span> <em>International Journal of Performance Arts and
Digital Media</em> 12 (2): 171–78.
</div>
<div id="ref-aaron2014temporal" class="csl-entry"
role="doc-biblioentry">
Aaron, Samuel, Dominic Orchard, and Alan F Blackwell. 2014.
<span>“Temporal Semantics for a Live Coding Language.”</span> In
<em>Proceedings of the 2nd ACM SIGPLAN International Workshop on
Functional Art, Music, Modeling &amp; Design</em>, 37–47.
</div>
<div id="ref-agential" class="csl-entry" role="doc-biblioentry">
Armitage, Jack. 2022. <span>“Agential Scores.”</span> <a
href="https://iil.is/research/agential-scores"
class="uri">https://iil.is/research/agential-scores</a>.
</div>
<div id="ref-cookiewebsite" class="csl-entry" role="doc-biblioentry">
Collective, Cookie. 2016. <span>“Cookie Collective.”</span> <a
href="https://cookie.paris/all/"
class="uri">https://cookie.paris/all/</a>.
</div>
<div id="ref-goltz2018ableton" class="csl-entry" role="doc-biblioentry">
Goltz, Florian. 2018. <span>“Ableton Link–a Technology to Synchronize
Music Software.”</span> In <em>Proceedings of the Linux Audio
Conference</em>, 39–42.
</div>
<div id="ref-isobar" class="csl-entry" role="doc-biblioentry">
Jones, Daniel John. n.d. <span>“Isobar.”</span> <a
href="https://github.com/ideoforms/isobar">https://github.com/ideoforms/isobar</a>.
</div>
<div id="ref-kirkbride2016foxdot" class="csl-entry"
role="doc-biblioentry">
Kirkbride, Ryan. 2016. <span>“Foxdot: Live Coding with Python and
Supercollider.”</span> In <em>Proceedings of the International
Conference on Live Interfaces</em>, 194–98.
</div>
<div id="ref-magnusson2018performing" class="csl-entry"
role="doc-biblioentry">
Magnusson, Thor, and Alex McLean. n.d. <span>“Performing with Patterns
of Time.”</span>
</div>
<div id="ref-mclean2014making" class="csl-entry" role="doc-biblioentry">
McLean, Alex. 2014. <span>“Making Programming Languages to Dance to:
Live Coding with Tidal.”</span> In <em>Proceedings of the 2nd ACM
SIGPLAN International Workshop on Functional Art, Music, Modeling &amp;
Design</em>, 63–70.
</div>
<div id="ref-vortex" class="csl-entry" role="doc-biblioentry">
McLean, Alex, Damian Silvani, Raphaël Forment, and Sylvain Le Beux.
2022. <em>TidalVortex Zero</em>. Zenodo. <a
href="https://doi.org/10.5281/zenodo.6456380">https://doi.org/10.5281/zenodo.6456380</a>.
</div>
<div id="ref-mcphersonAugmentingAcousticPiano2010" class="csl-entry"
role="doc-biblioentry">
McPherson, Andrew, and Youngmoo Kim. 2010. <span>“Augmenting the
<span>Acoustic Piano</span> with <span>Electromagnetic String
Actuation</span> and <span>Continuous Key Position
Sensing</span>.”</span> In <em><span>NIME</span></em>, 217–22.
</div>
<div id="ref-mcpherson2020idiomatic" class="csl-entry"
role="doc-biblioentry">
McPherson, Andrew, and Koray Tahıroğlu. 2020. <span>“Idiomatic Patterns
and Aesthetic Influence in Computer Music Languages.”</span>
<em>Organised Sound</em> 25 (1): 53–63.
</div>
<div id="ref-roberts2018" class="csl-entry" role="doc-biblioentry">
Roberts, Charlie, and Graham Wakefield. 2018. <span>“Tensions and
Techniques in Live Coding Performance.”</span>
</div>
<div id="ref-guido2" class="csl-entry" role="doc-biblioentry">
Rossum, Guido Van. 2009a. <span>“Final Word on Tail Calls.”</span> Blog.
</div>
<div id="ref-guido1" class="csl-entry" role="doc-biblioentry">
———. 2009b. <span>“Tail Recursion Elimination.”</span> Blog.
</div>
<div id="ref-asynciorepl" class="csl-entry" role="doc-biblioentry">
Selivanov, Yuri. n.d. <span>“Implement Asyncio REPL.”</span> <a
href="https://github.com/python/cpython/issues/81209"
class="uri">https://github.com/python/cpython/issues/81209</a>.
</div>
<div id="ref-uvloop" class="csl-entry" role="doc-biblioentry">
Selivanov, Yury. 2016. <span>“UVLoop.”</span> <em>GitHub
Repository</em>. <a href="https://github.com/MagicStack/uvloop"
class="uri">https://github.com/MagicStack/uvloop</a>; GitHub.
</div>
<div id="ref-SorensenTemporal" class="csl-entry" role="doc-biblioentry">
Sorensen, Andrew. 2013. <span>“The Many Faces of a Temporal
Recursion.”</span> <a
href="http://extempore.moso.com.au/temporal_recursion.html">http://extempore.moso.com.au/temporal_recursion.html</a>.
</div>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Some videos of this older system can be found on…<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><em>Read, Eval, Print, Loop</em>: mechanism used by most
interpreted languages to quickly process user input from the command
line.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The process for setting up various interfaces is
extensively detailed on <a
href="https://sardine.raphaelforment.fr">Sardine Website</a><a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Decorators in Python are used to add a behaviour to an
object without modifying the base object itself.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Python codebase for the Magnetic Resonator Piano: <a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Code from this experiment can be found on the
<em>Tölvera</em> GitHub repository:
https://github.com/Intelligent-Instruments-Lab/iil-python-tools<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
