#+title: 🐟 Sardine 🐟
#+SUBTITLE: 🫧 A Python Live Coding Instrument 🫧
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="gray/gray.css" />
#+EXPORT_FILE_NAME: index.html

#+BEGIN_EXPORT html
<script>
    // select #text-table-of-contents
    const menu = document.querySelector('#text-table-of-contents');


    // select the first ul li's
    const menuItems = menu.querySelectorAll('ul li');

    // add detail tag inside thye first li level and summary arounbd the ul
    menuItems.forEach((item) => {
        // add detail tag to the first li level
        item.innerHTML = `<details>${item.innerHTML}</details>`;
        // add summary tag around the a
        item.querySelector('a').outerHTML = `<summary>${item.querySelector('a').outerHTML}</summary>`;
    });
</script>
#+END_EXPORT
#+OPTIONS: toc:2          (only include two levels in TOC)


#+begin_quote
Sardine is a free/open-source software for Python 3.10+. It turns Python into a musical instrument. You can play it alone or with your friends. *With Sardine you can*:
- Play synthesizers and audio samples using *SuperCollider*.
- Control synthesizers through MIDI/OSC messages.
- Interconnect audio/video softwares and/or sound engines.
- Play collaboratively with your friends.
- Extend your musical environment using any *Python* package.

*Sardine* is designed to allow the exploration of algorithmic improvisation using a friendly syntax/environment. It transforms *Python* into a time-aware environment capable of sequencing any event with precision. Code can be updated anytime while the program still runs, a technique called *live coding*!
#+end_quote


* Presentation
** What is Sardine?
#+attr_html: :width 800px
file:what_is_sardine.png

Sardine is a *Python based musical instrument*. While it may look like a typical Python library, it is best described as a modular live coding environment. You won't just *import* it and forget it, you will play it like a guitar or a trombone. *Sardine* will allow you to sequence synthesizers, audio samples and various messages used by software or hardware audio/video equipment. *Sardine* is leveraging *Python* as a way to build powerful and terse algorithmic sequences that you can type fast while on stage. *Sardine* is also embedding multiple small languages (the more the merrier!) allowing you to do that even faster, and with style!

*Sardine* is using *Python* for its flexibility. *Python* is a very popular programming language for a good reason. It has a lot of different packages and it is very well supported pretty much everywhere :) You won't have any problem finding a good text editor or finding the right tools for the job.

A small community of musicians and artists in France (and even elsewhere) are using *Sardine*. You can find more by looking at the showcase section or by getting in touch with other *Sardine users* on social medias: *Discord*, etc...

#+attr_html: :width 800px
file:sardine_stack.svg

** What is Live Coding?

*Sardine* is an instrument/tool that you control by programming live. Your keyboard will be your main musical interface, which is pretty unusual compared to other musical practices. *Sardine* is a tool made to explore various live coding techniques, and a tool made to integrate with other live coding softwares and environments. For people unfamiliar with it, live coding can be said to be three things at once:

- *a programming technique:* the art of manipulating, redefining or altering software while it runs. A technique exploring processes of hot swapping, reloading or re-compiling parts of a software stack without interruption, as part of the way the software is meant to be used.
- *an artistic practice:* promoting artistic expression throughout the use of computer code. Turning programming into a gestural and expressive act, usually meant to be shared with an audience.
- *a subculture:* a niche in the larger world of computer and electronic music. Live coding has always been there. You can trace its origins way back to the 70s if you are really looking for it :) Nowadays, live coding is mostly promoted by algoravers or by the [[https://toplap.org/][TOPLAP]] collective.

Try to read about it. It's a fascinating world of people happily hacking and sharing software, usually free and open source. The goal is to find the right tool for the nail you want to hammer, and build from there, turning your computer into an environment for personal artistic expression. For our case, it means that Sardine is meant to be extended, modified, specialised for what you need to do :)

** Community

There are multiple pages on the internet to share your new-found passion about *Sardine*:
- [[https://discord.gg/aPgV7mSFZh][Discord Server]]: the most active place. Easy to reach me there as well :)
- [[https://github.com/Bubobubobubobubo/sardine][Github Repository]]: to check the latest news and to contribute to the code!
- [[https://discord.gg/XpwR2fNQpV][TOPLAP Discord]] or [[https://forum.toplap.org/][TOPLAP Forum]]: the biggest international live coding collective.

You can also find some *Sardine* related content by checking the [[https://cookie.paris][Cookie Collective]] website. There are some users documenting their art practice and their love/hate relationship with *Sardine*:
- [[https://raphaelforment.fr][BuboBubo]] (Raphaël Maurice Forment): I created the *Sardine* live coding environment and I am live coding as well.
- [[https://remigeorges.fr/][Rémi Georges]]: the infamous Rémi Georges, the first *Sardine* user. A lover of old/ancient digital machines and emerit live-coder.

** Showcase
*** Solstice

This piece was submitted by *BuboBubo*. This is a 20 minutes performance that I did for the *TidalCycles* annual solstice stream. Three of the four tracks were rapidly composed before the stream. I've tried to highlight some of the new features we have worked on for the ~v.0.2.1~. I am sometimes playing additional keyboard on top of the code.

#+begin_src python
padcc = { 'timbre': {'control' : 18, 'chan': 2},
        'time': {'control' : 19, 'chan': 2},
        'metal': {'control' : 16, 'chan': 2},
        'fx': {'control' : 17, 'chan': 2}}
basscc = { 'timbre': {'control' : 18, 'chan': 0},
        'time': {'control' : 19, 'chan': 0},
        'cutoff': {'control' : 16, 'chan': 0},
        'fx': {'control' : 17, 'chan': 0}}
jupcc = { 'decay': {'control' : 81, 'chan': 1},
        'time': {'control' : 19, 'chan': 1},
        'cutoff': {'control' : 74, 'chan': 1},
        'resonance': {'control' : 71, 'chan': 1}}
dirt._ahead_amount = 0.4

#######################################################################
# FRENCH TOUCH SAMBA
#######################################################################

PE >> d('long:3', cut=1, begin="[0.0:0.6,0.1]")

Pc >> d('ff:4!3, gg:12', cut=1, p=0.25, orbit=1, shape=0.5)

Pb >> d('f!7', cut=0, p=1, orbit=2, shape=0.5)

Pd >> d('g:10', p='.5, .5, .25', orbit=2, shape=0.5, speed='2,2,1!2,4')

Pb >> None
Pc >> None
Pc >> d('bip:rand*20', speed=2,
        cut=0, p=0.25, orbit=1, shape=0.5, hcutoff='[500:15000,1000]')

# ---

PE >> d('long:3', cut=1, begin="[0.0:0.6,0.1]")
Pc >> d('ff:4!3, gg:12', cut=1, p=0.25, orbit=1, shape=0.5)
Pb >> d('f!7', cut=0, p=1, orbit=2, shape=0.5)
Pd >> d('g:10', p='.5, .5, .25', orbit=2, shape=0.5, speed='2,2,1!2,4')
Pf >> d('bip:rand*50', speed=2, midinote='C5,C5,G5,A5',
        cut=1, p=0.25, orbit=1, shape=0.5)
Pg >> d('bip:rand*50', squiz=4, speed=1, midinote='C3,C4,G3,G4,A4,A5', shape=0.5,
        cut=1, p=0.25, orbit=1)

# ---

Pa >> None
Pb >> None
Pc >> None
Pd >> None

PE >> d('long:3', cut=1, begin="[0.0:0.6,0.1]")
Pc >> d('ff:4!3, gg:12', cut=1, p=0.25, orbit=1, shape=0.5)
Pb >> d('f!7', cut=0, p=1, orbit=2, shape=0.5)
Pd >> d('g:10', p='.5, .5, .25', orbit=2, shape=0.5, speed='2,2,1!2,4')
Pf >> d('bip:rand*50', speed=2, midinote='C5,C5,G5,G5',
        cut=1, p=0.25, orbit=1, shape=0.5)
Pg >> d('bip:rand*50', squiz=4, speed=1, midinote='C5@fifths', shape=0.5,
        cut=1, p=0.25, orbit=1)

Pa >> None
Pb >> None
Pc >> None
Pd >> None
PE >> d('long:3', cut=1, begin="[0.0:0.6,0.1]", speed='2!4,4!4')


PE >> d('long:3', cut=1, begin="[0.0:0.6,0.1]")
Pc >> d('ff:4!3, gg:12', cut=1, p=0.25, orbit=1, shape=0.5)
Pb >> d('f!7', cut=0, p=1, orbit=2, shape=0.5)
Pd >> d('g:10', p='.5, .5, .25', orbit=2, shape=0.5, speed='2,2,1!2,4')
Pf >> d('bip:rand*50', speed=2, midinote='C5,C5,G5,G5',
        cut=1, p=0.25, orbit=1, shape=0.5)
Pg >> d('bip:rand*50', squiz=4, speed=1, midinote='C5@fifths', shape=0.5,
        cut=1, p=0.25, orbit=1)

###################################################################
# CAROTTE INTERLUDE
###################################################################

panic()

@swim
def baba(p=0.5, i=0):
    D('juppad:54, juppad:55', cutoff=2000, begin=0.1,
      orbit=2, cut=0, legato=1.1, i=i, d=8, r=0.25)
    again(baba, p=1/4, i=i+1)

@swim
def baba(p=0.5, i=0):
    D('juppad:54, juppad:55', cutoff=5000, begin=0.1,
      orbit=2, cut=0, legato=1.1, i=i, d=8, r=0.25)
    D('boop:rand*20', shape=0.4,
      midinote='G4|G5,Bb5,F6, G4|G5,Bb5,G6', i=i, r=0.25, d=2)
    D('boop:rand*40')
    again(baba, p=1/4, i=i+1)

@swim
def baba(p=0.5, i=0):
    # D('f', shape=0.4, i=i, d=4)
    # D('f:3', amp='[0:0.4,0.05]', legato='0.01~0.2', i=i)
    D('.., p:5, .', legato=0.5, shape=0.7, i=i, d=1)
    D('juppad:54, juppad:55', cutoff=5000, begin=0.1,
      orbit=2, cut=0, legato=1.1, i=i, d=8, r=0.25)
    D('.., p:6, ., .., p:3, ..', legato=0.5, shape=0.7, i=i)
    D('bip:rand*20', midinote='adisco((G|[G,G|Ab|G5])!2)', i=i, d=2)
    again(baba, p=1/4, i=i+1)

@swim
def baba(p=0.5, i=0):
    D('f, f, ..', shape=0.4, i=i, d=4)
    D('f:4', amp='[0:0.4, 0.05]', legato='0.1~0.5', i=i)
    D('.., p:5, .', legato=0.5, shape=0.7, i=i)
    D('juppad:54, juppad:55', cutoff=5000, begin=0.1,
      squiz=2, orbit=2, cut=0, legato=1.1, i=i, d=8, r=0.25)
    again(baba, p=1/4, i=i+1)

@swim
def baba(p=0.5, i=0):
    D('f', shape=0.4, i=i, d=4)
    D('f:8~12', speed='4~8', amp='[0:0.4, 0.05]', legato='0.1~0.5', i=i)
    D('.., p:5, .', legato=0.5, shape=0.7, i=i, d=1)
    D('laz:rand*20',
            speed="1, 2,4",  hcutoff='3000~6000',
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4, i=i, d=0.25)
    D('juppad:54, juppad:55', cutoff=5000, begin=0.1,
      squiz='0!4,2',
      orbit=2, cut=0, legato=1.1, i=i, d=8, r=1)
    again(baba, p=1/4, i=i+1)

@swim
def baba(p=0.5, i=0):
    # D('f', shape=0.4, i=i, d=4)
    # D('f:3', speed=4, amp='[0:0.4, 0.05]', legato='0.1~0.5', i=i)
    D('.., p:5, .', legato=0.5, shape=0.7, i=i)
    D('laz:rand*20',
            speed="1, 2,4",  hcutoff=6000,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4, i=i, d=1, r=0.25)
    D('juppad:54, juppad:55', cutoff=5000, begin=0.1,
      pan='r', speed='1|2|4', leslie=1, lesliespeed=8,
      orbit=2, cut=0, legato=1.1, i=i, d=8, r=0.25)
    again(baba, p=1/4, i=i+1)

@swim
def baba(p=0.5, i=0):
    D('f', shape=0.4, i=i, d=4)
    D('.., p:5, .', legato=0.5, shape=0.7, i=i)
    D('conga:rand*20', speed="[1,2,4]/4", hcutoff='500~1000', shape=0.4,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.5, i=i, d=1, r=0.25)
    D('kit2:3', shape=0.5, i=i, d=8)
    D('., kit2:10, ., kit2:9!2', shape=0.5, i=i, d=2)
    again(baba, p=1/4, i=i+1)


@swim
def baba(p=0.5, i=0):
    D('f', shape=0.4, i=i, d=4)
    D('.., p:5, .', legato=0.5, shape=0.7, i=i)
    D('conga:rand*20', speed="[1,2,4]/4", hcutoff='500~1000', shape=0.4,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.5, i=i, d=1, r=0.25)
    D('conga:rand*20', speed="[1,2,4]/2", hcutoff='2000', shape=0.4,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.5, i=i, d=2, r=0.5)
    D('kit2:3', shape=0.5, i=i, d=8)
    D('., kit2:10, ., kit2:9!2', shape=0.5, i=i, d=2)
    again(baba, p=1/4, i=i+1)

# Ici on joue uniquement avec les percus et on lave les oreilles

@swim
def baba(p=0.5, i=0):
    D('f:3', amp='[0:0.2,0.01]', legato='0.1~0.5', i=i)
    D('.., p:(5|10), .', legato=0.5, i=i, d=1)
    D('m|c:[4:9]', legato=0.2, i=i, d='4!12, 3!12')
    D('jupbass:[1:100]', # -> lost into jupfx
            cutoff=3000, # ->
            shape=0.5,
            pan='sin($/40)', # -> X
            legato=0.2, # ->
            begin='r', i=i)
    again(baba, p=1/4, i=i+1)


@swim
def baba(p=0.5, i=0):
    D('a', shape=0.7, i=i, d=4)
    D('c', shape=0.7, i=i, d=3)
    D('d:7', orbit=3, room=0.2, size=0.8, dry=0.2, i=i, d=8)
    D('hhh:3', amp='[0:0.2, 0.01]', legato='0.1~0.5', i=i)
    D('f:3', amp='[0:0.2,0.01]', legato='0.1~0.5', i=i)
    D('.., p:(5|10), .', legato=0.5, i=i, d=1)
    D('m|c:[4:9]', legato=0.2, i=i, d='4!12, 3!12')
    D('jupbass:[1:100]', # -> lost into jupfx
            cutoff=3000, # ->
            shape=0.5,
            pan='sin($/40)', # -> X
            legato=0.2, # ->
            begin='r', i=i)
    again(baba, p=1/4, i=i+1)

panic()
D('girls:2')


#####################################################################
# COMPUTER LAMENTO
#####################################################################

@swim
def structure(p=0.5, i=0):
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4)
    N("[G6]-[0:12]", chan=2, vel=120, i=i, r=0.25/2)
    CC(**jupcc['cutoff'], value=100)
    CC(**jupcc['decay'], value=80)
    N("[G6]-[0:12]", chan=1, vel=120, i=i, r=0.25/2)
    again(structure, p=0.5, i=i+1)

@swim
def structure(p=0.5, i=0):
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4)
    N("[G6|D5]-[0:12]", chan=2, vel=120, i=i, r=0.25/2)
    again(structure, p=0.5, i=i+1)

@swim
def structure(p=0.5, i=0):
    CC(**padcc['timbre'], value='50~120')
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4)
    N("[G6]-[0:12]", chan=2, vel=120, i=i, r=0.25/2)
    again(structure, p=0.5, i=i+1)

@swim
def structure(p=0.5, i=0):
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4)
    N("[G6]-[0:12]", chan=2, vel=120, i=i, r=0.25/2)
    N("[G7]-[0:12]", chan=2, vel=120, i=i, r=0.25/1)
    again(structure, p=0.5, i=i+1)

@swim
def structure(p=0.5, i=0):
    CC(**padcc['timbre'], value='(90~100)-10') # go down
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4) # middle voice
    N("Eb4, F4, G4", chan=2, vel='50~100', i=i, r=0.25/2)
    N("pal(C|C5|C6@minor)", d=2,
      chan=2, vel='50~100', i=i, r=0.25/2)
    again(structure, p=0.5, i=i+1)

@swim
def structure(p=0.5, i=0):
    CC(**padcc['timbre'], value='(70~110)') # go down
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4)
    N("Eb4, F4, G4", chan=2, vel='50~100', i=i, r=0.25/2)
    N("pal(C|C5|C6@minor)", d=2,
      chan=2, vel='50~100', i=i, r=0.25/2)
    CC(**basscc['timbre'], value='rand*127')
    CC(**basscc['fx'], value='80')
    CC(**basscc['cutoff'], value='[1:127,20]')
    N("disco(pal(C3|C5|C4@minor))", d=1,
      chan=0, vel='(50~100)-30', i=i, r=0.25)
    again(structure, p=0.5, i=i+1)

@swim
def structure(p=0.5, i=0):
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4)
    N("Eb4, F4, G4", chan=2, vel='50~100', i=i, r=0.25/2)
    CC(**basscc['cutoff'], value=127, i=i)
    N("pal(C|C5|C6@minor)", d=2,
      chan=2, vel='50~100', i=i, r=0.25/2)
    N("disco(pal(C3|C5|C4@minor))", d=1,
      chan=0, vel='50~100', i=i, r=0.25)
    D('ff', d='3, 3, 2', i=i, cutoff=2500)
    D('s, u, n, d, o, w, n', d='3, 3, 2', i=i, p=0.5)
    D('kk:2~8, bb:1~9', legato=0.2, d='2, 3, 1!4', i=i,
      speed='0.25, 0.5!5, 1!8')
    again(structure, p=0.5, i=i+1)


@swim
def structure(p=0.5, i=0):
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4)
    N("Eb4, F4, G4", chan=2, vel='50~100', i=i, r=0.25/2)
    CC(**basscc[pick('timbre', 'cutoff')], value='20~120', i=i)
    CC(**basscc[pick('time')], value='20', i=i)
    N("pal(C|C5|C6@minor)", d=2,
      chan=2, vel='50~100', i=i, r=0.25/2)
    N("disco(pal(C4|C6|C5@minor))", d=1,
      chan=0, vel='50~100', i=i, r=0.25)
    D('ff', d='3, 3, 2', i=i, cutoff=2500)
    D('s, u, n, d, o, w, n', d='3, 3, 2', i=i, p=0.5)
    D('kk:2~8, bb:1~9', legato=0.2, d='2, 3, 1!4', i=i,
      speed='0.25, 0.5!5, 1!8')
    again(structure, p=0.5, i=i+1)

Pb >> d('g,o,o,d,b,y,e,t,r,a,c,k', d='1', p=0.5, orbit=2, cut=0)

@swim
def structure(p=0.5, i=0):
    N("C2,C3, F2, F3", chan=2, vel=120, i=i)
    N("G5,G4, Ab5, Ab4", chan=2, vel=120, i=i, r=0.25/4)
    N("Eb4, F4, G4, Eb4, Eb5, Eb4, Eb5", chan=2, vel='50~100', i=i, r=0.25/2)
    N("pal(F|F5|G6@minor)", d=2,
      chan=2, vel='50~100', i=i, r=0.25/2)
    again(structure, p=0.5, i=i+1)


Pc >> d('s, u, n, d, o, w, n', d='3, 3, 2', p='0.25!16, 0.5!4', orbit=3, cut=1, speed='2,4')

@swim
def structure(p=0.5, i=0):
    N("pal(F|F4|G3@minor)", d=2,
      chan=2, vel='100~120', i=i, r=0.25/2)
    N("pal(F|F5|G6@minor)", d=2,
      chan=2, vel='100~120', i=i, r=0.25/2)
    again(structure, p=0.5, i=i+1)

############################################################
# IDEE POUR UN TROISIEME MORCEAU
############################################################

silence(structure)
Pc >> None
@swim(snap=0)
def baba(p=0.5, i=0):
    D('ff', i=i, d=4, shape=0.5)
    D('s:[1:20]', i=i, d=3, speed='1|1|2|4', legato=0.4, pan='r')
    D('l:[1:20]', i=i, d=2, speed='1|1|2|4', legato=0.2, pan='r')
    D('jupfx:[0:20]', midinote='rev(C3, Eb3, G, Bb4|Bb5)',
      room=0.5, size=0.21, dry=0.12, orbit=3, amp=0.25,
      i=i, d=2, speed='1|1|2|4', legato=0.08, pan='r')
    again(baba, p=0.25, i=i+1)


Pb >> None
@swim(snap=0)
def baba(p=0.5, i=0):
    D('long', orbit=3, cut=1, begin='r', i=i)
    D('ff', i=i, d=4)
    D('kit2:[1,20]', legato=0.1, i=i, d='3!32, 4!16', speed='1,2')
    again(baba, p=0.25, i=i+1)


@swim(snap=0)
def baba(p=0.5, i=0):
    D('ulh:60', orbit=3, cut=1, begin='r', i=i)
    D('ff', i=i, d=4)
    D('ff:9', i=i, d=8, orbit=2)
    if sometimes():
        D('ff:rand*40', i=i, d=2, orbit=2, legato=0.1)
    else:
        D('bb|gg:rand*40', speed='<1,2>,4', i=i, d=1, orbit=2, legato='0.01~0.2')
    D('kit2:[1,20]', legato=0.1, i=i, d='3!32, 4!16', speed='1,2')
    again(baba, p=0.25, i=i+1)
# Change p to 2, I don't know why but it is working

panic()


##################################################################
# VOLAILLE DE BRESSE
##################################################################

Pa >> d('juppad:12|51', begin='r', amp=0.20, speed='1', legato=4,
        room=0.5, orbit=3, dry=0.2, size=0.8,
        midinote='Do,Fa,Ab3,Eb4', cutoff=4000)

Pb >> d('bip:rand*50', begin='0,0.2,0.5', amp=0.45, speed='2',
        room=0.5, orbit=3, dry=0.2, size=0.8,
        legato=0.18, midinote='adisco(Do,Fa,Ab3,Eb4)', cutoff=8000, p=0.5)

Pd >> d('ff:4', shape=0.5, speed=1, p=0.5, cutoff='[200:2000,100]', amp=0.5)


Pa >> d('juppad:12|51', begin='r', amp=0.20, speed='1', legato=4,
        room=0.5, orbit=3, dry=0.2, size=0.8,
        midinote='Do,Fa,Ab3,Eb4', cutoff=4000)
Pb >> d('bip:rand*50', begin='0,0.2,0.5', amp=0.45, speed='2',
        room=0.5, orbit=3, dry=0.2, size=0.8,
        legato=0.18, midinote='adisco(Do,Fa,Ab3,Eb4)', cutoff=8000, p=0.5)
Pc >> d('ff', shape=0.5, speed=1, p=1, cutoff='[2000:5000,100]')
Pc >> d('nn:4~8', legato=0.2,
        shape=0.5, speed='1,2', p=0.5, cutoff='[2000:5000,100]')
Pe >> d('ff', shape=0.5, speed=1, p=2, cutoff='[200:2000,100]')

Pc >> d('[f,i,s,h,e,s]:[1:20]', shape=0.5, p=0.5, legato=0.02, pan='r')
Pd >> d('euclid([gg:rand*20]!8, 5,8)', shape=0.5, speed=4,
        p=0.5, cutoff='5000', resonance='0.1,0.2')

Pb >> None # d('j, a, j, a', orbit=2, p='1,0.5')
Pc >> None # d('f, l, o, w, e, e:rand*4', shape=0.5)
Pd >> None # d('bb:5~6', p='0.25, 0.125', legato=0.05)

panic()
#+end_src

*** Zorba in Belleville

This code is taken from an algorave that took place at the *Zorba* (Belleville, Paris) in early november (2022). It is a very straightforward dance oriented performance that plays a lot with simple audio sample manipulations. As stated in the opening banner, this performance was meant to test the stability of *Sardine* after introducing new features and control mechanisms. Everything lives in the baba function, meaning that you only need to keep track one function during the whole performance.

Sounds are extracted from a very heavy sound library, lazy-loaded when needed. This is how I like to make music, extracting a lof of raw audio files from my hard disk :)

#+begin_src python
# ██████████████████████████████████████████████████████████████████████████████
# █                                                                            █
# █  █   ▄▄   █▀█ ▄▀█ █▀▄▀█ █▀▀ █▀█   █▀ ▄▀█ █▄░█ █▀   █▀█ ▄▀█ █▀▄▀█ █▀▀       █
# █  █   ░░   █▀▄ █▀█ █░▀░█ ██▄ █▀▄   ▄█ █▀█ █░▀█ ▄█   █▀▄ █▀█ █░▀░█ ██▄       █
# █                                                                            █
# ██████████████████████████████████████████████████████████████████████████████

@swim
def baba(d=0.5, i=0):
    S('juppad:3, juppad:4', cutoff=5000, begin=0.1, orbit=2, cut=0, legato=1.1).out(i, 8, 0.25)
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('juppad:3, juppad:4', cutoff=5000, begin=0.1, orbit=2, cut=0, legato=1.1).out(i, 8, 0.25) # up
    # S('bip:rand*20', shape=0.4, midinote='quant([0,3,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25)
    S('boop:rand*40').out()
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    # S('f', shape=0.7).out(i, 4) # -> monter shape pour les harmoniques
    # S('hhh:3', amp='[0:0.4,0.05]', legato='0.1~0.5').out(i) # -> hhh ramp
    S('.., p:5, .', legato=0.5, shape=0.7).out(i, 1)
    # S('.., p:6, ., .., p:3, ..', legato=0.5, shape=0.7).out(i, 1)
    S('juppad:3, juppad:4', begin=0.1, orbit=2, cut=0, legato=1.1).out(i, 8, 0.25)
    # S('bip:rand*20', midinote='adisco((C|[C,F|Ab])!2)').out(i, 2) # petit surplus harmonique
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('f, f, ..', shape=0.7).out(i, 4) # -> monter shape pour les harmoniques
    S('hhh:3', amp='[0:0.4, 0.05]', legato='0.1~0.5').out(i) # -> hhh ramp
    S('.., p:5, .', legato=0.5, shape=0.7).out(i, 1)
    S('juppad:3, juppad:4', begin=0.1, orbit=2, cut=0,
            legato=1.1, speed='1',
            crush=4).out(i, 8, 0.25) # -> ici il y a de la réduction
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('f', shape=0.7).out(i, 4) # -> monter shape pour les harmoniques
    S('hhh:3', amp='[0:0.4, 0.05]', legato='0.1~0.5').out(i) # -> hhh ramp
    S('.., p:5, .', legato=0.5, shape=0.7).out(i, 1)
    S('laz:rand*20',
            speed="1, 2,4",  hcutoff=6000,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25)
    S('juppad:3, juppad:4', begin=0.1, orbit=2, cut=0,
            legato=1.1, speed='1, 2',
            crush=4).out(i, 8, 0.25) # -> ici il y a de la réduction
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('f', shape=0.7).out(i, 4) # -> monter shape pour les harmoniques
    S('hhh:3', amp='[0:0.4, 0.05]', legato='0.1~0.5').out(i) # -> hhh ramp
    S('.., p:5, .', legato=0.5, shape=0.7).out(i, 1)
    S('laz:rand*20',
            speed="1, 2,4",  hcutoff=6000,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25)
    S('juppad:3, juppad:4', begin=0.1, orbit=2, cut=0,
            pan='r',
            legato=1.1, speed='1|2|4', leslie=1, lesliespeed=8,
            crush=12).out(i, 8, 0.25) # -> ici il y a de la réduction
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('., f', shape=0.7).out(i, 4) # -> monter shape pour les harmoniques
    S('.., p:5, .', legato=0.5, shape=0.7).out(i, 1)
    # S('juppad:3, juppad:4', orbit=2, cut=0, legato=1.1).out(i, 8, 0.25)
    S('laz:rand*20',
            speed="1, 2,4",  hcutoff=3000, legato=1,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25)
    S('juppad:3, juppad:4',
            speed=0.75, squiz=2,
            orbit=2, cut=0,
            legato=1.1).out(i, 8, 0.25)
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('f', shape=0.7).out(i, 4)
    S('.., p:5, .', legato=0.5, shape=0.7).out(i, 1)
    S('conga:rand*20', speed="[1,2,4]/4", hcutoff=2000, shape=0.7,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25)
    S('juppad:3, juppad:4',
            speed=0.75, squiz=2,
            orbit=2, cut=0,
            legato=1.1).out(i, 8, 0.25)
    S('kit2:3', shape=0.5).out(i, 8)
    S('., kit2:10, ., kit2:9!2', shape=0.5).out(i, 2)
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('f', shape=0.7).out(i, 4)
    S('.., p:5, .', legato=0.5, shape=0.7).out(i, 1)
    S('conga:rand*20', speed="[1,2,4]/4", hcutoff=2000, shape=0.7,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25)
    S('conga:rand*20', speed="[1,2,2]/2", hcutoff=1000, shape=0.7,
              room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.5)
    # S('juppad:3, juppad:4', # commenter ce bloc
    #         speed=0.75, squiz=2,
    #         orbit=2, cut=0,
    #         legato=1.1).out(i, 8, 0.25)
    S('kit2:3', shape=0.5).out(i, 8)
    S('., kit2:10, ., kit2:9!2', shape=0.5).out(i, 2)
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    # S('f', shape=0.7).out(i, 4)
    S('.., p:5, .', legato=0.5, shape=0.7).out(i, 1)
    S('conga:rand*20', speed="[1,2,4]/4", hcutoff=2000, shape=0.7,
            room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25)
    # S('euclid(conga:rand*20, 12,16)', speed="[1,2,4]/2", hcutoff=1000, shape=0.7,
    #         room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25)
    # S('juppad:3, juppad:4', # commenter ce bloc
    #         speed=0.75, squiz=2,
    #         orbit=2, cut=0,
    #         legato=1.1).out(i, 8, 0.25)
    S('kit2:3', shape=0.5).out(i, 8)
    S('., kit2:10, ., kit2:9!2', shape=0.5).out(i, 2)
    a(baba, d=1/8, i=i+1)

# Remonter à la ligne 167 pour plus de fun

#############################################################################
## ICI RUPTURE VERS L'INCLUSION DES FOUND SOUNDS
#############################################################################

@swim
def baba(d=0.5, i=0):
    # S('f', shape=0.7, cutoff=100).out(i, 8)
    S('hhh:3', amp='[0:0.2,0.01]', legato='0.1~0.5').out(i) # -> hhh ramp
    S('.., p:(5|10), .', legato=0.5).out(i, 1)
    S('m|c:[4:9]', legato=0.2).out(i, P('4!12, 3!12', i))
    S('lost:[1:100]', # -> lost into jupfx
            cutoff=9000, # ->
            shape=0.5,
            pan='sin($/40)', # -> X
            legato=0.3, # ->
            begin='r').out(i) # -> begin r ou {0, 1, 0.1}
    a(baba, d=1/8, i=i+1)

# Inclure
@swim
def baba(d=0.5, i=0):
    S('a', shape=0.7).out(i, 4) # -> monter shape pour les harmoniques
    S('c', shape=0.7).out(i, 3) # -> monter shape pour les harmoniques
    S('d:7', orbit=3, room=0.2, size=0.8, dry=0.2).out(i, 8)
    S('hhh:3', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp
    S('.., p:5, .', legato=0.5).out(i, 1) # -> refaire entrer ça
    S('m|c:[4:9]', legato=0.2).out(i, P('4!12, 3!12', i))
    S('lost:[1:100]', # -> lost into jupfx
            cutoff=9000, # ->
            shape=0.5,
            pan='sin($/40)', # -> X
            legato=0.9, # ->
            begin='r').out(i) # -> begin r ou {0, 1, 0.1}
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0): # potentiomètre du réel
    S('a', shape=0.7).out(i, P('4!12, 5!12', i)) # -> monter shape pour les harmoniques
    S('c', shape=0.7).out(i, 3) # -> monter shape pour les harmoniques
    # S('c', shape=0.7).out(i, P('3!12, 2!12, 5!12',i)) # -> monter shape pour les harmoniques
    # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp
    S('d:4, d:5, .', legato=0.5).out(i, 3)
    S('m|g:[4:9]', legato=0.2).out(i, P('4!12, 1!24', i))
    S('long|(lost:rand*8)', # -> lost into jupfx
            midinote='C',
            cutoff=4000, # ->
            pan='[0:0.5, 0.1], [0.5:1, 0.1]', # -> X
            legato='0.1|0.2|0.7|0.1',
            cut=1, orbit=2, room=0.5, size=0.2, dry=0.1,
            begin='[0:1,0.01], [1:0,0.01]').out(i) # -> begin r ou {0, 1, 0.1}
    a(baba, d=1/8, i=i+1)

# Ici on peut explorer des choses plus ambient et se perdre un peu

@swim
def baba(d=0.5, i=0): # potentiomètre du réel
    S('a', cutoff=200, shape=0.7).out(i, P('4!12, 5!12', i))
    # S('c', cutoff=100, shape=0.7).out(i, 3)
    # S('c', shape=0.7).out(i, P('3!12, 2!12, 5!12',i))
    # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp
    # S('d:4, d:5, .', legato=0.5).out(i, 3)
    S('m|g:[4:9]', legato=0.2).out(i, P('4!12, 1!24', i))
    S('long|(lost:rand*8)', # -> lost into jupfx
            midinote='C',
            cutoff=4000, # ->
            pan='[0:0.5, 0.1], [0.5:1, 0.1]', # -> X
            legato='[0.1|0.2|0.7|0.1]+0.6', # -> facteur de fun
            cut='1|0, 1|0, 1!4', orbit=2, room=0.5, size=0.2, dry=0.1,
            begin='[0:1,0.01], [1:0,0.01]').out(i) # -> begin r ou {0, 1, 0.1}
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    # S('f', shape=0.5).out(i, 4)
    # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp
    # S('d:4, d:5, .', legato=0.5).out(i, 3)
    # S('d:{4,9}', legato=0.5).out(i, 4)
    # S('z', shape=0.8).out(i, 4)
    S('hhh:12', hcutoff=500, speed='[1:10]', shape=0.8).out(i, 1)
    # S('kit5:[6!4,7!2,5!5,4]', shape=0.8).out(i, 3)
    # S('q:rand*8', shape=0.4).out(i, P('1!12, 2!8', i))
    S('long:1', # -> lost into jupfx
            midinote='C',
            cutoff=4000, # ->
            pan='[0:0.5, 0.1], [0.5:1, 0.1]', # -> X
            legato='0.1|0.2|0.3|0.1',
            begin='[0:1,0.01], [1:0,0.01]').out(i) # -> begin r ou {0, 1, 0.1}
    a(baba, d=1/8, i=i+1)


@swim
def baba(d=0.5, i=0):
    # S('f', shape=0.5).out(i, 4)
    # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp
    # S('d:4, d:5, .', legato=0.5).out(i, 3)
    # S('d:{4,9}', legato=0.5).out(i, 4)
    # S('z', shape=0.8).out(i, 4)
    S('hhh:12', hcutoff=500, speed='[1:10]', shape=0.8).out(i, 1)
    # S('kit5:[6!4,7!2,5!5,4]', shape=0.8).out(i, 3)
    # S('q:rand*8', shape=0.4).out(i, P('1!12, 2!8', i))
    S('long:1', # -> lost into jupfx
            midinote='C',
            cutoff=4000, # ->
            pan='[0:0.5, 0.1], [0.5: 1, 0.1]', # -> X
            legato='0.1|0.2|0.3|0.1',
            begin='[0:1,0.01], [1:0,0.01]').out(i) # -> begin r ou {0, 1, 0.1}
    a(baba, d=1/8, i=i+1)

panic()

S('lost').out()

S('lost:2').out()

# Fêter Halloween

S('lost:7', legato=7, speed=0.5, release=7).out()

S('lost:0', legato=7, speed=0.5, release=7).out()

S('lost:3', legato=7, speed=0.5, release=7).out()

panic()

# ██████████████████████████████████████████████████████████████████████████████
# █                                                                            █
# █     █ █   ▄▄   █░█ ▄▀█ █░█ ▄▀█ █░░ █ █▄░█ ▄▀█                              █
# █     █ █   ░░   █▀█ █▀█ ▀▄▀ █▀█ █▄▄ █ █░▀█ █▀█                              █
# █                                                                            █
# ██████████████████████████████████████████████████████████████████████████████


@swim
def baba(d=0.5, i=0):
    # S('bip:rand*20', shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25)
    # S('bip:rand*20+20', shape=0.4, midinote='quant([0+12|24,3,6,10]+62, C@minor), quant([0,3,10]+62|74, F@minor)').out(i, 3, 0.25)
    S('boop:rand*40').out()
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('bip:rand*20',
            orbit=2, room=0.7, size='r', dry='0.1',
            shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25)
    S('bip:rand*20+20',
            orbit=2, room=0.5, size='r', dry='0.1',
            shape=0.4, midinote='quant([0+12|24,3,6,10]+62, C@minor), quant([0,3,10]+62|74, F@minor)').out(i, 3, 0.25)
    S('boop:rand*40').out()
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('bip:rand*20',
            orbit=2, room=0.7, size='r', dry='0.1', legato=1,
            shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25)
    S('bip:rand*20, boop:rand*200',
            orbit=2, room=0.7, size='r', dry='0.1', legato=1,
            shape=0.4, midinote='quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)').out(i, 3, 1)
    S('(ff):rand*20', # ulh electrowave ff
            orbit=2, room=0.7, size='r', dry='0.1', legato=0.2, hcutoff=500,
            shape=0.4, midinote='quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)').out(i, 2, 1)
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('ff', shape=0.5).out(i, 4)
    S('ll', shape=0.5).out(i, 4)
    S('gameboysnare', cutoff=800).out(i, 8)
    S('., hhh:rand*40', hcutoff=9000).out(i, 1)
    S('., hhh:rand*40', hcutoff=9000, speed='1~50').out(i, 1)
    S('bip:rand*20',
            orbit=2, room=0.7, size='r', dry='0.1', legato=1,
            shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25)
    S('bip:rand*20, boop:rand*200',
            orbit=2, room=0.7, size='r', dry='0.1', legato=1,
            shape=0.4, midinote='quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)').out(i, 3, 1)
    S('(ulh):rand*20', # ulh electrowave ff
            orbit=2, room=0.7, size='r', dry='0.1', legato=0.2, hcutoff=500,
            shape=0.4, midinote='quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)').out(i, 2, 1)
    a(baba, d=1/8, i=i+1)

# <-> des allers retours

@swim
def baba(d=0.5, i=0):
    # S('ff, gg:rand*29', shape=0.8, leslie=1, leslierate=5, lesliespeed=2).out(i, 2)
    # S('ll', shape=0.8).out(i, 4)
    S('gameboysnare', cutoff=800).out(i, 8)
    # S('., hhh:rand*40', hcutoff=9000).out(i, 1)
    S('., hhh:rand*40', hcutoff=9000, speed='1~50').out(i, 1)
    # S('bip:rand*20', lesliespeed='2*8', leslierate='rand*5', leslie=1,
    #         orbit=2, room=0.7, size='r', dry='0.1', legato=1,
    #         shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25)
    S('bip:rand*20, boop:rand*200', lesliespeed='2*8', leslierate='rand*5', leslie=1,
            orbit=2, room=0.7, size='r', dry='0.1', legato=1,
            shape=0.4, midinote='quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)').out(i, 3, 1)
    S('(ulh):rand*20', # ulh electrowave ff
            orbit=2, room=0.7, size='r', dry='0.1', legato=0.2, hcutoff=500,
            shape=0.4, midinote='quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)').out(i, 2, 1)
    a(baba, d=1/8, i=i+1)

# --|--> transition du coq à l'âne

@swim
def baba(d=0.5, i=0):
    S('m, ..., m, ...', shape=0.5).out(i, 2)
    S('rev([s,a,l,u,t, z,o,r,b,a]:rand*8)',
            legato=0.1, pan='tan(r/100)', accelerate=0.2,
            room=0.1, dry=0.1, size=0.1,
    ).out(i, 2)
    S('perca:[1:20], ..',
            speed=2 if rarely() else 'rand*4',
    ).out(i, 2)
    a(baba, d=1/16, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('m, ..., m, ...', shape=0.5).out(i, 2)
    S('long:13', shape=0.5,
            begin='0.5, 0.5, 0.42, 0.5!2, 0.6', orbit=3,
            cut=1, legato=2).out(i, 8, 0.25)
    S('perca:[1:20], ..', speed=2).out(i, 2)
    a(baba, d=1/16, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('f, ..., f, ...').out(i, 2)
    S('gg, ...', shape=0.5, orbit=4, room=0.2, size=0.2, dry=0.2).out(i, 2)
    S('perca:[1: 20], ..', speed='1+rand*4', cutoff='200+rand*8000').out(i, 2)
    S('perca:[20: 1], .', speed='0.1+sin($)', cutoff='200+rand*8000').out(i, 3)
    S('long:13', shape=0.7,
            begin='0.1, 0.2, 0.3, 0.5',
            orbit=3,
            cut=1).out(i, 8, 0.25) # 0.5 0.6
    a(baba, d=1/16, i=i+1)


@swim
def baba(d=0.5, i=0):
    S('m, ..., m, ...', shape=0.5).out(i, 2)
    S('hhh:rand*49', amp=0.3, hcutoff='sin(i.i/40)*7000').out(i, 2)
    S('long:13', shape=0.5,
            begin='0.6, 0.5, 0.42, 0.6, 0.7', orbit=3,
            cut=1, legato=2).out(i, 8, 0.25)
    S('q:[1:20], ..', speed=2).out(i, 2)
    a(baba, d=1/16, i=i+1)


@swim
def baba(d=0.5, i=0):
    S('m, ..., m, ...', shape=0.5).out(i, 2)
    S('hhh:rand*49', amp=0.3, hcutoff='sin(i.i/40)*7000').out(i, 2)
    S('long:13', shape=0.5,
            begin='0.5, 0.5, 0.42, 0.5!2, 0.6', orbit=3,
            cut=1, legato=2).out(i, 8, 0.25)
    S('q:[1:20], ..', speed=2).out(i, 2)
    a(baba, d=1/16, i=i+1)

# une petite transition jsp

@swim
def baba(d=0.5, i=0):
    # S('m, ..., m, ...', shape=0.5).out(i, 2)
    # S('hhh:rand*49', amp=0.3, hcutoff='sin(i.i/40)*7000').out(i, 2)
    S('jupfx:rand*20', shape=0.5, hcutoff='200 + rand*8000',
            begin='0.5, 0.5, 0.42, 0.5!2, 0.6', orbit=3,
            cut=1, legato=2).out(i, 8, 0.25)
    S('q:[1:20], ..', speed=2).out(i, 2)
    a(baba, d=1/16, i=i+1)

# Débrouille toi


# ██████████████████████████████████████████████████████████████████████████████
# █                                                                            █
# █ █ █ █   ▄▄   ▀█▀ ▄▀█ █▀█ ▀█▀ █▀▀   █ █▄░█ ▀█▀ █▀█   ▀█▀ █▀▀ █▀█            █
# █ █ █ █   ░░   ░█░ █▀█ █▀▄ ░█░ ██▄   █ █░▀█ ░█░ █▄█   ░█░ ██▄ █▀▄            █
# █                                                                            █
# █ █▀ ▄▀█ █ █▄░█ ▀█▀ ▄▄ █▀▀ ▀█▀ █ █▀▀ █▄░█ █▄░█ █▀▀                           █
# █ ▄█ █▀█ █ █░▀█ ░█░ ░░ ██▄ ░█░ █ ██▄ █░▀█ █░▀█ ██▄                           █
# █                                                                            █
# ██████████████████████████████████████████████████████████████████████████████

,*,,,,,,,,,,,,.,,,,..*****,,.  .. ,*,.   . ..        ........,,,.,,,,,,,,,,.,,.*
*(**/**,/*(**,**///**,,*////*,,..,,//.. ..,       . ....,,,,,,,,**********(//(((
*/***/***,/******/,. . ....,,,,..,,**.   ...     ..,.....,,.,,,,,*********(((//*
*((*//**,,/,,,,,*,.  .. ....,,,.../#%%%%#(,..    .,,,....,...,,,,.,,,,**,,****(/
*****/,,*,**,**,,,...,.,.,*/#%%%%%%%%%%%%%%%#(. .,,..,,...,...,..,..,,,,****/***
*//,**//*****/**,.....%#%&&%%&&&&%&%%%%%%%%%%%%##%#...... ,,..,..*.,,,,/**/*,,**
*//*,,*,,******,,/,,.#%&&&&&&&&&&&&&%#%&%%&%%%%###%( .. ..,,..,,,..,,..,.****,**
*//*,,,,****,,,,,,,,#%&&&&&&&%&%&%%%%&&&%&&&%%%%%###(#*  ....,,,,.,........,,**,
*//*****,***...... #%&%&&&%&%%&%%%%#%%%&&&&&%%%%%%%%%%%#**,*,....,,.,*.......,,,
*/*******,,,......#%%&%&%&&&%%%&&%%%%%#%%%%%%%%%###%%#%%(,,,,*, ....   ,..,,,,./
*/*****,,*,.....,(&&&%&&&%(***(&**,****,,*((##%/#/#%%%#%%(////**,,......,,,,,.*,
*/*,,,,,,.,*, ..#%%&&&&%#/***************,**,... .*#%%%%%#//*.,..........,*/*,.,
*/****,,,...,.,.#%&&&&%(/********,,,****,***,...   ,/%%#(*.............,.,,,..,*
*/**,,,,,,,,....,%%%&&&/**/////***,**/***,,*,*,...  ./(#,...,..,.,,..,,,,...,,,*
*/****,**,**,*,..*%&&&/**#(///(//((/*/*,**/////***,..#%(, .....,.....,,. ....,*,
*//**********,,,,//%%%**//(%#&%#////(,,#/*(*###*/*.../#(/,.,.,,.. ... .   .,,..,
*//*///**,,,,***,,//%%***/((((((//((,,,,((/(((//.*...,#/,...,,.,...,.. .,......,
*///(**//*****/***,(%#****///**/****,,,,.,**,,,,,.,,,(#*..,,...,.. ............,
*//*/*,,**,,,,**/***#%(**********/****,....,,,,,.....#(*,,......,.  .,,.,**,,,..
*//*/*,*/**,*,,,,,,.,##//**********,**,,..,,,,....  ,((******//(*.....*,,.,....*
*//*///**//,,.**,..,,,%#***********((/./(,*,,,,. ..,*((,,,....,,..,.,,,*,.,...,*
/#/((***/,***,,,.,,,**(((***,*,****((#/*/,,,...   .,(#,,.......  ..,,,***,,,.,.*
*((/(/***.*,,,..,.,*,//(#(//****//(((((/(///.*...,.//(/***,.,*..  ....,***,...,*
*((//*,,,,,.......,,..,*(##(//***//((//(*(*,*,...,*/*,... ..    .  ......,..,.,,
/((((/,,,,...........,,**/(#((/**/***/*,,,***,.,.////*******,,.,,.   .... ...,.,
*(((/*,,,,,,,./, .......*,,/###(/********,,.,*(*,.,,.....,,,..     ..  ......,..
*((//**,,.,,****,.,,,...*%(..(###%#((((((//(#(/.   ,.*,,,,..,..   ..... ......,.
*((///*,.,*,****...,*/.&&&%,.,,*(##%%%%%%%##(/.   .%#((,.,.., ...........,,,,,,.
/(/(**,,,..,,,,,**/**/&&@&&&/*,/.,*((((((((. ...,(%#%%%%%,,,,.......   ...,.,,,,
*(//**,***,**,*****(%&&&@&&@&%*,.,,*//(((/,..,/%%%%%%%%%%##*,*,...............,.
*(//***,,*/,*,,(&&&&@&@@@&&&&(,,,,,,,*(#,,,,,,*#%%%%%%%%%%%%%#**.........,/*****
*(///****,,(&&&&@@@@@@&&@&&&&##%&&&&&&&&&&&&%##%%&&&%%&%%%%%%%#(%(/*....***,*,,,
*((((((&@&&&&@@@@&&@&@&&&&&%%&&&&&@&&&&&@@@&&%%%%%%%%%%%%%#%%#%%*,,...,,,*,,***,
/%&%&@&%&@@@@@&&&&&%%&&@&&&@&&@@&&&#,,,,,##&%(%%&%%%%#%%##%/.  /#/...,,..,,,,...
/&&&%&&&&&%&&@&&&&&&&&&&&&&&%#%&&&&%(.,,,,,,/&&&&%%%%%##**,. ,,/,.,.,.*,*,(#&(..
/&&%#%%%###%&@&&&&&%%%%%%%&&&&&%&%&%*,.,,...%%%&%%%(%#*,,.,,./,,.,,,./(#(*#(%(#(
/&&@&@&%&@@@&@&&&%(#%%%#%&&&&&&&%%&&%#.... %%%%&&%#(*,,...(/,,,*,(%%###(####/*%(
/&@@@&@&&#%##&%(/*/(#%%%#%&@&&%#%%&&%&%,./&&&%%%#***....**,*/*%%%%&%(#%#####(/(*
/#%&@%%##&&&%(/((,,(%&%#%%%&&%%#%#%%&%&%&&&&%%(*.....(.*.,/#%%%&%%%%###%#%%###(.
/######/(%%&%(%%#(((/#%&@&&&&&%&&%%&&%&&&&&%/,,.. ,.,.,(#%&%&%%%&%%%#%%%(((//%%(
/%%%#(#%%%%%%%%#######(((%&&@&&%%%%%&&%%%(,,,,..,,,(%%&&%#%%%####((%#%(/(#%#(#**
/%%%%%%%&&&%&&%%%%#(((((((#*%&@&%%&&%%%/,*,,.*,//&%%&%%%%&&%####(/*#%(/(#%%#**,*
/&&%&%%%%%%%##%%###(#((#*#%((//(////***/*.**##%%%#%##%&%#(##%%%%#*/#//*/#(/#(***
# C'EST PIERRE BONNARD, IL FAUT ALLER LE VOIR.


@swim
def baba(d=0.5, i=0):
    M(velocity='90~110', note='inrot(C@maj7, F@maj7)-12').out(i, 2)
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    M(velocity='90~110', dur=1, note='inrot(C@maj7, F@maj7)-12').out(i, 2)
    M(velocity='90~110|70', dur='15~20', note="F', ..., G'', ..., [D, E, F, A]+12").out(i, 2)
    a(baba, d=1/8, i=i+1)


@swim
def baba(d=0.5, i=0):
    M(velocity='90~110', dur=1, note='inrot(C@maj7, F@maj7)-12').out(i, 2)
    M(velocity='90~110|90', dur='15~20', note="F., ..., F.., ...").out(i, 2)
    M(velocity='90~110|90', dur='15~20', note="F., A, .., F.., ...").out(i, 2)
    a(baba, d=1/8, i=i+1)

# <-> alterner

@swim
def baba(d=0.5, i=0):
    M(dur='2~5', note='inrot(C@maj7, F@maj7)-12').out(i, 2)
    M(dur='2~5', note='disco(inrot(C@maj7, F@maj7))').out(i, 5)
    M(dur='2~12', note='adisco(inrot(inrot(C@maj7, F@maj7), G@fifths))').out(i, 4)
    a(baba, d=1/8, i=i+1)

@swim
def baba(d=0.5, i=0):
    M(note='inrot(C@maj7, F@maj7)-12').out(i, 2)
    if rarely():
        M(note='disco(inrot(C@maj7, F@maj7))').out(i, 5)
    if sometimes():
        M(note='adisco(inrot(inrot(C@maj7, F@maj7), G@fifths))').out(i, 4)
    a(baba, d=1/8, i=i+1)


c._midi_nudge = 0.30

@swim
def baba(d=0.5, i=0):
    S('ff').out(i, 4)
    M(velocity='90~110', dur=1, note='inrot(C@maj7, F@maj7)-12').out(i, 2)
    M(velocity='90~110|90', dur='15~20', note="F., ..., F.., ...").out(i, 2)
    M(velocity='90~110|90', dur='15~20', note="F., A, .., F.., ...").out(i, 2)
    a(baba, d=1/8, i=i+1)



# ██████████████████████████████████████████████████████████████████████████████
# █                                                                            █
# █  █ █░█   ▄▄   █░░ █▀▀   █▀█ █ ▄▀█ █▄░█ █▀█   ▄▀█ █▄░█ ▄▀█ █░░ █▀█          █
# █  █ ▀▄▀   ░░   █▄▄ ██▄   █▀▀ █ █▀█ █░▀█ █▄█   █▀█ █░▀█ █▀█ █▄▄ █▄█          █
# █                                                                            █
# ██████████████████████████████████████████████████████████████████████████████

panic()


@swim
def baba(d=0.5, i=0):
    S('kit3:[1,2,1,2,4,5,4,6]', legato=1).out(i, 8)
    S('long:42', begin='r', cut=1).out(i, 8)
    a(baba, d=1/32, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('jupbass:28|44, jupbass:28', octave=4,
        legato=1, cut=1, orbit=3).out(i, 24, 1)
    if sometimes():
        S('z:6' if random() > 0.5 else 'z:7', shape=0.9, hcutoff=7000).out(i, 4)
    a(baba, d=1/32, i=i+1)


@swim
def baba(d=0.5, i=0):
    S('kit3:[1,2~10,1,2,4~10,5,4,6]', legato=1).out(i, 8)
    S('long:42', begin='r', cut=1).out(i, 8)
    a(baba, d=1/32, i=i+1)

@swim
def baba(d=0.5, i=0):
    # Ce truc est quand même giga fade :'(((((((((((((
    S('jupbass:28|44, jupbass:28', octave=4,
        legato=1, cut=1, orbit=3).out(i, 24, 1)
    if sometimes():
        S('z:6' if random() > 0.5 else 'z:7', shape=0.9, hcutoff=7000).out(i, 4)
    # Du du du du dudududududu dudu du du dud udu dudu
    a(baba, d=1/32, i=i+1)

# Réponse :

@swim
def baba(d=0.5, i=0):
    S('kit3:[0, 1,2,1,2,4,5,4,6,7,8, 1, 0]', legato=1).out(i, 8)
    S('long:42', begin='r', cut=1).out(i, 8)
    S('long:42~46', begin='r', cut=1, speed=0.5).out(i, 8)
    S('jupbass:28|44, jupbass:28', octave=4,
        legato=1, cut=1, orbit=3).out(i, 24, 1)
    if sometimes():
        S('z:6' if random() > 0.1 else 'z:7',
                pan='r',
                legato=1, shape=0.9, hcutoff=7000).out(i, 4)
    if sometimes():
        S('dd:6|7|8' if random() > 0.5 else 'j:0~7',
                pan='r',
                legato=1, shape=0.9, hcutoff=7000).out(i, 4)
    a(baba, d=1/32, i=i+1)


@swim
def baba(d=0.5, i=0):
    S('kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]', legato=1).out(i, 8)
    S('long:20~33', begin='r', cut=1).out(i, 8)
    S('long:42~46', begin='r', cut=1, speed=0.5).out(i, 8)
    S('jupbass:28|44, jupbass:28', octave=4,
        legato=1, cut=1, orbit=3).out(i, 24, 1)
    if sometimes():
        S('z:6' if random() > 0.1 else 'z:8~400',
                pan='r',
                legato=1, shape=0.9, hcutoff=7000).out(i, 4)
    if sometimes():
        S('dd:6|7|8' if random() > 0.5 else 'z:7~200',
                pan='r',
                legato=1, shape=0.9, hcutoff=7000).out(i, 4)
    a(baba, d=1/32, i=i+1)


@swim
def baba(d=0.5, i=0):
    S('kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]', legato=1).out(i, 8)
    # S('long:42', begin='{0,2,0.4}', cut=1).out(i, 16)
    S('long:42', begin='[0:1, 0.08]', cut=1).out(i, 16) # -> éplucher comme un oignon (solo de fichier .wav)
    # S('long:42~46', begin='r', cut=1, speed=0.5).out(i, 8)
    # S('jupbass:28|44, jupbass:28', octave=4,
    #     legato=1, cut=1, orbit=3).out(i, 24, 1)
    if sometimes():
        S('z:6' if random() > 0.1 else 'z:8~400',
                pan='r',
                legato=1, shape=0.9, hcutoff=7000).out(i, 4)
    if sometimes():
        S('dd:6|7|8' if random() > 0.5 else 'z:7~200',
                pan='r',
                legato=1, shape=0.9, hcutoff=7000).out(i, 4)
    a(baba, d=1/32, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]', legato=1).out(i, 8)
    S('long:10~33', begin='r', cut=1, speed="1~8").out(i, 8)
    S('long:20~46', begin='r', cut=1, speed="1~8").out(i, 8)
    a(baba, d=1/32, i=i+1)

# Réponse :

@swim
def baba(d=0.5, i=0):
    S('kit2:[0, 1,2, 0, 1,2,4,5,4,0,6,1,2,3,1,2,3,2,3,4,5~8!5]', legato=1).out(i, 8)
    S('kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]', legato=1).out(i, 8)
    S('long:103', begin='0.1, 0.5', cut=1, speed="1~8").out(i, 16)
    S('long:20', begin='0.1, 0.5', cut=1, speed="1~8").out(i, 8)
    a(baba, d=1/32, i=i+1)


@swim
def baba(d=0.5, i=0):
    S('cc').out(i, 12)
    S('kit2:[0, 1,2, 0, 1,2,4,5,4,0,6,1,2,3,1,2,3,2,3,4,5~8!5]', legato=1).out(i, 8)
    S('kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]', legato=1).out(i, 8)
    S('long:103', begin='0.1, 0.5', cut=1, speed="1~8").out(i, 16)
    S('long:20', begin='0.1, 0.5', cut=1, speed="1~8").out(i, 8)
    a(baba, d=1/32, i=i+1)

@swim
def baba(d=0.5, i=0):
    S('jupbass:28|44, jupbass:28', octave=4,
        legato=1, cut=1, orbit=3).out(i, 24, 1)
    S('kit4:rand*20', legato=0.4, begin=0.01).out(i, 12)
    S('kit3:[1,2,1,2,4,5,4,6]').out(i, 8)
    S('long:40', begin='0.60!4, 0.555!2, 0.27!4, 0.25!2', orbit=2, cut=1).out(i, 32)
    S('long:40', speed=1.01, begin='0.60!4, 0.555!2, 0.27!4, 0.25!2', orbit=2, cut=1).out(i, 32)
    if sometimes():
        S('z:6', shape=0.9, hcutoff=5000).out(i, 4)
    a(baba, d=1/32, i=i+1)

panic()

@swim
def baba(d=0.5, i=0):
    S('jupbass:28|44, jupbass:28', octave=4,
        legato=1, cut=1, orbit=3).out(i, 24, 1)
    S('kit4:rand*20', legato=0.4, begin=0.01).out(i, 12)
    S('kit3:[1,2,1,2,4,5,4,6]').out(i, 8)
    S('long:26', amp=0.5, begin='0.60!4, 0.555!2, 0.27!4, 0.25!2', orbit=2, cut=1).out(i, 32)
    S('long:26', speed=1.01, begin='0.60!4, 0.555!2, 0.27!4, 0.25!2', orbit=2, cut=1).out(i, 32)
    if sometimes():
        S('z:6', shape=0.9).out(i, 4)
    a(baba, d=1/32, i=i+1)

# Variation 3
@swim
def baba(d=0.5, i=0):
    S('jupbass:28|44, jupbass:28', octave=4,
        legato=1, cut=1, orbit=3).out(i, 24, 1)
    S('kit4:rand*20', legato=0.4, begin=0.01).out(i, 12)
    S('kit3:[1,2,1,2,4,5,4,6]').out(i, 8)
    S('long:40', begin='0.60!4, 0.555!2, 0.27!4, 0.25!2', orbit=2, cut=1).out(i, 32)
    S('long:40', speed=1.01, begin='0.60!4, 0.555!2, 0.27!4, 0.25!2', orbit=2, cut=1).out(i, 32)
    if sometimes():
        S('z:6', shape=0.9).out(i, 4)
    a(baba, d=1/32, i=i+1)

panic()
#+end_src

*** Dumpster Dive

*dumpsterDive* (*HighHarmonics*) is a short piece that can be performed with quasi live-coding practices. It uses a set of percussive field recordings made with a hard marimba mallet on various parts of a public metal dumpster. One sound was made with a plastic scraper. They are particularly resonant sounds that work well together. The *Sardine* function uses the stacked samples model, where each sample line can be played alone or together with others.

- *Audio equipment:* Tascam DR-100, Rode shotgun mic: NTG4.
- *Software:* Sardine
- Dumpster samples are available via the [[https://github.com/Bubobubobubobubo/sardine-sounds][sardine-sounds]] repository.
- *Sardine alpha version*

#+begin_src python
# Load audio effect and preset dictionaries first.
# Play one or both lines from each section (basic, reverse rhythms, melodic patterns, bass, scrape). Explore combinations.

c.bpm=60

@swim
def dumpsterDive(d=1, i=0):
## basic samples - cycle thru the sounds used by all layers
    S('dumpster:[0,1,4,2,5,3,.!2]', speed=1, amp=.5, **rev1, orbit=0).out(i, div=8)
    #S('dumpster:[2,0,1,4,3,5]', speed='2', pan=.7, amp=.5, **rev1, orbit=1).out(i, div=2) #**del1
## reverse rhythms
    #S('dumpster:1', begin=.065, end=.4, speed='-1', pan='[.14:.84,0.1],[.83:.15,0.1]', amp=.8, **rev0, orbit=2).out(i, div4)
    #S('dumpster:0!2,.', begin=0, end=.85, speed='1,-1', pan='[.9:.1,0.2],[.1:.9,0.2]', amp=.6, **rev1, orbit=3).out(i, rate=1, div=2) #**del1,
## melodic patterns
    #S('dumpster:[1!2,4!2,5!2,4]', begin=.052, end=.088, freq='[414,240,620,.,500,380,820,750]', timescale=1.4, pan='[.1,.9]', amp=.95, **rev2, orbit=4).out(i, rate=1, div=1)
    #S('dumpster:[0,1,0,3,4,]', begin='0', end='.2',speed='1', amp=.6, pan=.3, **rev1, orbit=5).out(i, rate=1, div=2)
    #S('dumpster:[6!2,8!3,7!2]', octave='7', cut=1, pan=.3, amp=.9, **rev2, orbit=6).out(i, div=4)
## bass - choose one or the other
    #S('dumpster:[2,1,0,.,4,1]', octave=4, amp=.5, **rev1, orbit=7).out(i, rate=1, div=4)
    #S('dumpster:2', octave='[4.8:5.1,.04],[4.6:4.8,.04]', amp=.95, **rev1, orbit=8).out(i, div=4)
## scrape
    #S('dumpster:[5,.,5]', octave='6', cut=1, amp=1.2, **del1, **rev1, orbit=8).out(i, rate=.5, div=4)
    #S('dumpster:[5,.,5]', octave='[6!3,6.62,5.4]', cut=1, amp=.9, **rev2, orbit=9).out(i, rate=1, div=1) #**del2
## presets
    #returnGroove['bass1'].out(i, rate=1, div=4)
    #returnGroove['melody2'].out(i, rate=1, div=2)
    #closing['basic2'].out(i, div=2)
    #closing['basic2a'].out(i, rate=2, div=2) ## div=1
    #closing['scrape2'].out(i, rate=1, div=2)
    #c.bpm = P('[60:90,.03]', i) #accelerate tempo at the end

    a(dumpsterDive, d=1/8, i=i+1)

######################################################
#hush(dumpsterDive)

######################## LOAD THESE FIRST - python dictionarys referenced in dumpsterDive function #################
c.bpm=60
## audio effects
rev0 = {'room':.8, 'size':0.5, 'dry':0.5}
rev1 = {'room':.9, 'size':0.6, 'dry':0.4}
rev2 = {'room':1.5, 'size':0.7, 'dry':0.4}
rev3 = {'room':2, 'size':0.8, 'dry':0.3}

del0 = {'delay':0.5, 'delaytime':0.3, 'delayfeedback':0.5, 'triode':0}
del1 = {'delay':0.5, 'delaytime':0.4, 'delayfeedback':0.6}
del2 = {'delay':0.5, 'delaytime':0.25, 'delayfeedback':0.8}

#Presets
returnGroove = {'bass1':  S('dumpster:[2,1,0,.,4,1]', octave=4, amp=.5, **rev1, orbit=7),
    'melody2': S('dumpster:[0,1,0,3,4,]', begin='0', end='.2',speed='1', amp=.4, pan=.3, **rev1, orbit=5) }
closing = {'basic2': S('dumpster:[12,0,1,4,3,5]', speed='2', pan=.7, amp=.5, **del1, **rev1, orbit=1),
    'basic2a': S('dumpster:[0,5,3,4,3,0]', speed='[2.01:1.96,.01],[1.96:2.01,.01]', pan='[.99:.01,0.3],[.01:.99,0.3]', amp=.7, **rev1, **del2, orbit=1),
    'scrape2': S('dumpster:[5,.,5]', octave='[6!3,6.62,5.4]', cut=1, amp=.9, **del2, **rev2, orbit=9) }
#+end_src

*** Artificial Life

Experimental use of the *Taichi* numerical simulation and graphics language for live visuals and artificial life simulation. Made by [[https://jackarmitage.com/][Jack Armitage]]. For more info, see the [[https://github.com/Intelligent-Instruments-Lab/iil-python-tools][iil-python-tools]]. Using an *alpha version of Sardine*. [[https://youtu.be/XSdHbPZSofo][Video n°1]], [[https://youtu.be/l6kx7lvGDy0][Video n°2]].

#+begin_src python
from sardine import *
import taichi as ti
import numpy as np
import math
import tulvera as tul

ti.init(arch=ti.vulkan)
c.bpm = 250
c.link()
resx = 1920
resy = 1080
n = 8192
boids = tul.vera.Boids(resx, resy, n)
window = ti.ui.Window("Boids", (resx, resy))
canvas = window.get_canvas()

@swim
def gui_loop(d=0.5, i=0):
    boids.update()
    canvas.set_image(boids.world.to_numpy().astype(np.uint8))
    window.show()
    a(gui_loop, d=1/16, i=i+1)

@swim
def param_loop(d=16, i=0):
    # boids.vis_radius[None] = P('40.0,80.0,150.0',i)
    # boids.max_speed[None] = P('1.0,2.0,3.0',i)
    boids.max_speed[None] = P('2*sin($/2)')
    a(param_loop, d=8, i=i+1)

hush()
#+end_src

* Installation
** Preliminary words

Being aware of your installed *Python* versions is of tremendous importance! You can have multiple versions of *Python* running on the same system, one being required by your operating system, some being installed by other applications, etc. These versions often don't live happily together. Find the command that will summon your *Python 3.10* or *Python 3.11* installation (can be ~python~, ~python3~, ~python3.10~, ~python3.11~ depending on the system you are currently using). Now, stick to it! You don't want to scatter files everywhere on your computer.

Don't let any error happen un-noticed! If you see an error, then there must be an error! Consider it seriously! Most people assume that seing errors is normal as long as nothing crashes. It may not be that bad but a missing package means a broken *Sardine*!

As funny as it may sound, I am not the owner of the ~sardine~ package on Pypi. *Sardine* is named ~sardine-system~. Some people sometimes end up installing a totally unrelated tool!

** Windows
*** Preparing your environment
:PROPERTIES:
:NOTOC: t
:END:

The first step to install *Sardine* is to prepare your system to make some sounds :)

- Install the latest [[https://www.python.org/][Python]] version for your OS (currently l3.11). *Sardine* will not work with a Python older than 3.10. Be careful with distribution provided Python versions, they are not yours! Install [[https://github.com/pyenv/pyenv][Pyenv]] or use [[https://docs.python.org/3/library/venv.html][virtual environments]] to keep everything nice and tidy!
- Install [[https://supercollider.github.io/][SuperCollider]], the default audio backend used by *Sardine*.
  - Once this step is over, open *SCIDE* (or click on the *SuperCollider* icon) and type:
#+begin_src sclang
Quarks.install("SuperDirt");
#+end_src
  - Press *Shift + Enter* and wait for the installation to be done! Close *SuperCollider* when done.
- (**Optional**) You can also install [[https://github.com/supercollider/sc3-plugins][sc3plugins]] to get more audio effects and synthesizers!

*** Installing Sardine
:PROPERTIES:
:NOTOC: t
:END:

To install *Sardine*, you can either:
- install the development version (recommanded -> *up to date*).
  #+begin_src shell
git clone https://github.com/Bubobubobubobubo/sardine
cd sardine
python -m pip install --find-links https://thegamecracks.github.io/python-rtmidi-wheels/ --editable .
  #+end_src
- install the [[https://pypi.org/project/sardine-system/][Pypi package]] (older, lagging behind).
  #+begin_src shell
python -m pip install --find-links https://thegamecracks.github.io/python-rtmidi-wheels/ --editable sardine-system
  #+end_src
- (*Note*) the ~--editable~ flag is optional. You can remove it if you are not planning to modify *Sardine*!

These commands will download and install *Sardine* using the recommended method. Once the installation is done, you now have officially installed *Sardine* with all its dependencies. Congratulations! You can now proceed to the configuration section. If you encounter an error, please head to the *Troubleshot* section or ask a question on the *Discord server* or in the *Github Issues*.

*Installing Ziffers*

*Sardine* is great but *Ziffers* is great as well. The two together form the perfect duo for making algorithmic music. *Ziffers* is developed by Miika Alonen independently from *Sardine* but we do collaborate to blend our tools together :) Install *Ziffers* now, you won't regret it later!

- Clone the [[https://github.com/Bubobubobubobubo/ziffers-python][ziffers-python]] repository.
- Install it like a regular Python package.

TLDR:
#+begin_src shell
git clone https://github.com/Bubobubobubobubo/ziffers-python
cd ziffers-python && python -m pip install --editable .
#+end_src

** MacOS
*** Preparing your environment
:PROPERTIES:
:NOTOC: t
:END:

The first step to install *Sardine* is to prepare your system to make some sounds :)

- Install the latest [[https://www.python.org/][Python]] version for your OS (currently l3.11). *Sardine* will not work with a Python older than 3.10. Be careful with distribution provided Python versions, they are not yours! Install [[https://github.com/pyenv/pyenv][Pyenv]] or use [[https://docs.python.org/3/library/venv.html][virtual environments]] to keep everything nice and tidy!
- Install [[https://supercollider.github.io/][SuperCollider]], the default audio backend used by *Sardine*.
  - Once this step is over, open *SCIDE* (or click on the *SuperCollider* icon) and type:
#+begin_src sclang
Quarks.install("SuperDirt");
#+end_src
  - Press *Shift + Enter* and wait for the installation to be done! Close *SuperCollider* when done.
- (**Optional**) You can also install [[https://github.com/supercollider/sc3-plugins][sc3plugins]] to get more audio effects and synthesizers!

*** Installing Sardine
:PROPERTIES:
:NOTOC: t
:END:

To install *Sardine*, you can either:
- install the development version (recommanded -> *up to date*).
  #+begin_src shell
git clone https://github.com/Bubobubobubobubo/sardine
cd sardine
python -m pip install --find-links https://thegamecracks.github.io/python-rtmidi-wheels/ --editable .
  #+end_src
- install the [[https://pypi.org/project/sardine-system/][Pypi package]] (older, lagging behind).
  #+begin_src shell
python -m pip install --find-links https://thegamecracks.github.io/python-rtmidi-wheels/ --editable sardine-system
  #+end_src
- (*Note*) the ~--editable~ flag is optional. You can remove it if you are not planning to modify *Sardine*!

These commands will download and install *Sardine* using the recommended method. Once the installation is done, you now have officially installed *Sardine* with all its dependencies. Congratulations! You can now proceed to the configuration section. If you encounter an error, please head to the *Troubleshot* section or ask a question on the *Discord server* or in the *Github Issues*.

*Installing Ziffers*

*Sardine* is great but *Ziffers* is great as well. The two together form the perfect duo for making algorithmic music. *Ziffers* is developed by Miika Alonen independently from *Sardine* but we do collaborate to blend our tools together :) Install *Ziffers* now, you won't regret it later!

- Clone the [[https://github.com/Bubobubobubobubo/ziffers-python][ziffers-python]] repository.
- Install it like a regular Python package.

TLDR:
#+begin_src shell
git clone https://github.com/Bubobubobubobubo/ziffers-python
cd ziffers-python && python -m pip install --editable .
#+end_src

** Linux
*** Preparing your environment
:PROPERTIES:
:NOTOC: t
:END:

The first step to install *Sardine* is to prepare your system to make some sounds :)

- Install the latest [[https://www.python.org/][Python]] version for your OS (currently l3.11). *Sardine* will not work with a Python older than 3.10. Be careful with distribution provided Python versions, they are not yours! Install [[https://github.com/pyenv/pyenv][Pyenv]] or use [[https://docs.python.org/3/library/venv.html][virtual environments]] to keep everything nice and tidy!
- Install [[https://supercollider.github.io/][SuperCollider]], the default audio backend used by *Sardine*.
  - Once this step is over, open *SCIDE* (or click on the *SuperCollider* icon) and type:
#+begin_src sclang
Quarks.install("SuperDirt");
#+end_src
  - Press *Shift + Enter* and wait for the installation to be done! Close *SuperCollider* when done.
- (**Optional**) You can also install [[https://github.com/supercollider/sc3-plugins][sc3plugins]] to get more audio effects and synthesizers!

*** Installing Sardine
:PROPERTIES:
:NOTOC: t
:END:

To install *Sardine*, you can either:
- install the development version (recommanded -> *up to date*).
  #+begin_src shell
git clone https://github.com/Bubobubobubobubo/sardine
cd sardine
python -m pip install --find-links https://thegamecracks.github.io/python-rtmidi-wheels/ --editable .
  #+end_src
- install the [[https://pypi.org/project/sardine-system/][Pypi package]] (older, lagging behind).
  #+begin_src shell
python -m pip install --find-links https://thegamecracks.github.io/python-rtmidi-wheels/ --editable sardine-system
  #+end_src
- (*Note*) the ~--editable~ flag is optional. You can remove it if you are not planning to modify *Sardine*!

These commands will download and install *Sardine* using the recommended method. Once the installation is done, you now have officially installed *Sardine* with all its dependencies. Congratulations! You can now proceed to the configuration section. If you encounter an error, please head to the *Troubleshot* section or ask a question on the *Discord server* or in the *Github Issues*.

*Installing Ziffers*

*Sardine* is great but *Ziffers* is great as well. The two together form the perfect duo for making algorithmic music. *Ziffers* is developed by Miika Alonen independently from *Sardine* but we do collaborate to blend our tools together :) Install *Ziffers* now, you won't regret it later!

- Clone the [[https://github.com/Bubobubobubobubo/ziffers-python][ziffers-python]] repository.
- Install it like a regular Python package.

TLDR:
#+begin_src shell
git clone https://github.com/Bubobubobubobubo/ziffers-python
cd ziffers-python && python -m pip install --editable .
#+end_src

** Updating / Uninstall

*Sardine* is distributed as a *Python* package. As such, it uses the same tools and techniques than a regular *Python* package to be updated / uninstalled, etc. After providing you some commands to act on your installation, I will give some details about the updating process.

*** Deleting Sardine

- In your terminal, run ~pip uninstall sardine~.
- Delete your *Sardine* directory if *Sardine* has been cloned using Git.
- You will have to get rid of the configuration files manually.
  - Their ~PATH~ is made visible when using *sardine-config*.

Note that you will still have an installation of *SuperCollider* and *SuperDirt* if you followed the full install.

*** Updating Sardine

I recommend installing *Sardine* using a freshly cloned version using *Git*. This will allow you to get updates much faster by just running ~git pull~ from your terminal inside of the *Sardine* folder. For the updates to be instantly applied to your version, note that you need to have installed *Sardine* using the ~--editable~ flag. Please refer to the installation section to learn more about this. If you followed the tutorial, you must have it installed in editable mode already.

The ~--editable~ mode means that your *Sardine* installation that *Python* refers to is folder you just cloned and not a copy of it. Any modification made to it will be immediately mirrored to the application you have installed.

* TODO Troubleshot
** Errors during installation
** SuperCollider/SuperDirt

*No sound, what should I do?*

Sometimes, *SuperDirt* will refuse to boot. You won't hear anything and *Sardine* will appear to be working perfectly. There are some steps I recommend to follow while trying to debug that issue:
- Check if *SuperDirt* is configured to boot in your *sardine-config*
- Check that your audio output and microphones are running at the audio sample rate (44100 or 48000hz) on both sides (audio output / input). You can check this using your operating system usual configuration tools. Note that pluging in and out a microphone can change the sampling rate automatically. This is annoying, but so is life!

*I still can't hear anything!*

- Sometimes, when you play around with booting and quiting *Sardine* repeatedly, your computer might start to get confused about who is using some of the network connections or not. You now have *zombie connexions* blocking the I/O process from running normally. This can also happen simply by opening multiple instances of *Sardine* on the same computer!
  - kill every instance of *Sardine* and *SuperCollider* and the code editors that hosted them.
  - run ~Server.killAll~ in a brand-new *SuperCollider* window.

This should solve the issue. If not, it might be something more serious and is less likely to be an error arising from *Sardine* itself. As crazy as it might sound, I'm not responsible of all the computer errors on this planet :)

- Use *sardine-config* and tell it not to boot *SuperCollider* automatically by itself.
- Open *SuperCollider* and *Sardine* side by side. From there:
  - type ~SuperDirt.start~ in your *SuperCollider* window and press *Shift+Enter* to manually start *SuperDirt*.
  - boot *Sardine* as usual, and try to play some sounds using it.

If you are stil unable to play sound then you have a broken install. Join us on the *Discord* server to get some help fixing the issue.

** Sardine

This section is about debugging *Sardine* itself. It can be anything ranging from a problem encountered while installing it to a problem encountered during a musical performance. If you notice an issue that is not currently documented here, please forward it by using the issue tracker on GitHub or by directly sending a mail out to me :) If you know the solution, write it here!

**** warning about uvloop

**uvloop** does not work on *Windows*. Fortunately, you can still run *Sardine* but you will not benefit from a very welcomed speed-up that comes for free on other systems! It's perfectly fine not to have *uvloop*.

**** *error creating ALSA sequencer client object*

This error can happen on some Linux systems. The solution to this problem is simple. It involves copying/pasting or creating symbolic links to a few files. Copy the content of ~/usr/lib/alsa-lib/~ into ~usr/lib/x86_64-linux-gnu/alsa-lib~ and ~usr/lib64/alsa-lib~. Solved! :)

* Configuration
** Configuration tool

#+attr_html: :width 400px
file:sardine_config.png

*Sardine* is shipping its own configuration tool, named *sardine-config*. Typing *sardine-config* in your terminal will open a configuration helper tool :) Using it, you can finetune your *Sardine* experience. Please note that *Sardine* is writing configuration files to a specific location depending on the OS you are using:
- *Windows:*
- *MacOS:*
- *Linux:*

The path leading to the configuration folder can be printed out by typing ~print_config()~ from inside your typical *Sardine* session. How convenient :) You can also manage to print the ~PATH~ to your configuration folder directly from the configuration tool.

There are three main files you can tweak to configure *Sardine*:
- ~config.json~: the main configuration file.
- ~default_superdirt.scd~: the default configuration for the audio engine.
- ~user_configuration.py~: a file that will be runned automatically everytime you start *Sardine*.
There is also a ~synths/~ folder (to store synthesizers) and a ~buffers/~ folder (used by the web editor).

** Configuration tour

Let's explain what the options in the configuration tool are. To start the configuration tool, please type ~sardine-config~ in your terminal. A splashscreen will appear and some options will pop up as well!

**** Show Config

This option will print the configuration file itself. It can be used to double-check if everything is convenably configured.

**** Reset

Reset the configuration file to installation default. This option will only override the *Sardine* configuration, not the *SuperDirt* configuration file.

**** MIDI

The *MIDI* menu will allow you to select the default *MIDI* port used by *Sardine*. This port will be used to automatically create some targets for you to play with when first starting a session. More ports can be configured manually later on.

- *Automatic*: *Sardine* will try to create the.. *Sardine* virtual port. This only works on *MacOS* and *Linux*.
- *Manual*: Select a *MIDI* port from the list. This list is composed of all the MIDI hardware or software ports currently available on your system.
- *Custom (advanced)*: write the name of your *MIDI* port directly. Do not use this except for very good reasons!

**** Clock

This menu will allow you to configure the default clock used by *Sardine* at the start of a session. You can always switch clock later (even when playing!) but you will usually stick to one clock only for the duration of a session.

- *No (internal clock)*: use the system clock. This will not allow you to sync with other players on the local network.
- *Yes (external clock)*: use the external Ableton Link clock. This will allow you to synchronize with other players or even with external software supporting the *Link Protocol*.

You will be prompted to enter a new default tempo and a default number of beats per measure.

**** SuperCollider

- *Add SuperDirt Handler*: do you want to interact with *SuperDirt* at all?! This is different from booting *SuperCollider*. *SuperDirt* is a more specialised engine for audio sampling and managing synthesizers. For newcomers, yes, you want to play with *SuperDirt*!
- *Boot a SuperCollider instance*: should *Sardine* try to manage *SuperCollider* by itself? This is a safe option to use for people using *MacOS* or *Linux* but can result in problems later on for those using *Windows*.
  - You will have to boot *SuperCollider* and *SuperDirt* manually if you untoggle this option!
- *Use Sardine boot file*: should we load our default boot file?
- *Turn on verbose output*: This is a very valuable option to toggle for debugging if *Sardine* does not work correctly. You will be able to capture the output of the *SuperCollider* process and see what is wrong on their end :)
- *Enter your SuperDirt booth path*: leave blank if you don't know what you are doing.

**** Editor

This menu will allow you to toggle the *web editor* by default or not. See the section concerning text editors to know if this is an option you want to consider. Note that this option is untoggled by default.

**** More

This section is used by developers to add custom debugging options to *Sardine*.

** MIDI
*** Receiving MIDI

*MIDI* Input is supported through the use of a special object, the *MidiListener* object. This object will open a connexion listening to incoming MIDI messages. There are only a few types of messages you should be able to listen to:

- *MIDI* notes through the ~NoteTarget~ object
- *MIDI* control changes through the ~ControlTarget~ object

Every MidiListener is expecting a target. You must declare one and await on it using the following syntax:

#+begin_src python
a = MidiListener(target=ControlTarget(20, 0))
@swim
def pluck(d=0.25):
    S('pluck', midinote=a.get()).out()
    a(pluck, d=0.25)
#+end_src

In this example, we are listening on the control change n°20 from the default port on the first channel (~0~). *Sardine* cannot assert the value of a given *MIDI* Control before it receives a first message therefore the initial value will be assumed to be ~0~.

You can fine tune your listening object by tweaking the parameters:

#+begin_src python
# picking a different MIDI Port
a = MidiListener('other_midi_port', target=ControlTarget(40, 4))
#+end_src

*** Sending MIDI

By default, *Sardine* will connect to a *MIDI* port. There is no such thing as a *Sardine* instance without a link to *MIDI*. Having only one port means that you will be limited to 16 channels. While this may already be a lot for some, other users will want to do something with their collection of 123 synthesizers. You can manually open up new MIDI ports by tweaking your *Sardine* session from the *Python* side:

#+begin_src python
# Add a new MidiHandler focusing on a specific port
your_midi_port: str = "exact_name_of_midi_port"
your_midi = MidiHandler(port_name=your_midi_port)

# Add the MIDI port to the session fishbowl
bowl.add_handler(your_midi)
#+end_src

Done! You now have a new MIDI port. The tricky part is now to add new objects to play with! Here is how to do so:

#+begin_src python
# If Ziffers is imported, grab a reference to its parser!
if ziffers_imported:
    midi._ziffers_parser = z2

N2 = your_midi.send  # For sending MIDI Notes
PC2 = your_midi.send_program  # For MIDI Program changes
CC2 = your_midi.send_control  # For MIDI Control Change messages
SY2 = your_midi.send_sysex  # For MIDI Sysex messages

if ziffers_imported:
    ZN2 = midi.send_ziffers  # Connecting the new Ziffers parser
#+end_src

You now have access to an interface to play *notes*, *control changes*, *program changes* and *sysex* messages. If you want to use the shorthand notation, you will have to do one extra step:

#+begin_src python
# Boilerplate for using the newly creating MIDI port with the shorthand
# syntax for swimming functions

def sy2(*args, **kwargs):
    return _play_factory(your_midi, your_midi.send_sysex, *args, **kwargs)

def n2(*args, **kwargs):
    return _play_factory(your_midi, your_midi.send, *args, **kwargs)

def zn2(*args, **kwargs):
    return _play_factory(your_midi, your_midi.send_ziffers, *args, **kwargs)

def cc2(*args, **kwargs):
    return _play_factory(your_midi, your_midi.send_control, *args, **kwargs)

def pc2(*args, **kwargs):
    return _play_factory(your_midi, your_midi.send_program, *args, **kwargs)
#+end_src

The ~_play_factory()~ method is not a function you are supposed to use directly. This function is mapping a *sender* (~d()~, ~n()~) to a function that can be understood by a *player* (~Pa~, ~Pb~).

This is everything you need to open new *MIDI* ports and replicate the normal behavior of the *Sardine* *MIDI* port. If you want to go even further, feel free to deep dive into the ~midi~ object itself. It might contain some sweet methods that you want to use!

** OSC

*Sardine* is capable of receiving and sending custom *OSC* messages. Obviously, this should be configured manually on your side. I am only providing the basic tools do to so without encountering any hurdle! Configuring *OSC* is prone to errors and has always been a very painful activity that computer musicians like to do for some reason.

*** Sending OSC

#+begin_src python
output_one = OSCHandler(
    ip="127.0.0.1", port=12345,
    name="A first test connexion",
    ahead_amount=0.0, loop=osc_loop, # The default OSC loop, don't ask why!
)
bowl.add_handler(output_one)

output_two = OSCHandler(
    ip="127.0.0.1", port=12346,
    name="A second test connexion",
    ahead_amount=0.0, loop=osc_loop,
)
bowl.add_handler(output_two)

# Look who's here, the send functions as usual
one = output_one.send
two = output_two.send
#+end_src

You can now use the methods one and two as OSC senders just like ~D()~ or ~N()~.

#+begin_src python
@swim
def one_two_test(p=0.5, i=0):
    """This is a dummy swimming function sending OSC."""
    one('random/address', value='1,2,3')
    again(one_two_test, p=0.5, i=i+1)
#+end_src

If you'd like, you can also make a ~Player~ out of it by using the following technique:

#+begin_src python
def osc_player(*args, **kwargs):
    """Partial function to add a new OSC player :)"""
    return play(
        output_one,
        output_one.send,
        ,*args, **kwargs
    )

Pa >> osc_player('random/address', value='1,2,3')
#+end_src

You are now able to send *OSC* messages just like if they were patterns. It means that you can use the *Sardine* pattern syntax to compose complex algorithmic sequences of OSC messages. Note that you can also pattern the address, making it a super fun/powerful way to explore your *OSC* bindings.

*** Receiving OSC

You can receive and track incoming *OSC* values coming from your controllers or devices. In fact, you can even attach callbacks to incoming *OSC* messages and turn *Sardine* into a soundbox so let's do it!

#+begin_src python
# Making a new OSC-In Handler
listener = OSCInHandler(
    ip="127.0.0.1",
    port=44444,
    name="Listener",
    loop=osc_loop
)

# Adding the listener to the bowl
bowl.add_handler(listener)

def funny_sound():
    D('bip', shape=0.9, room=0.9)

listener.attach('/bip/', funny_sound)
#+end_src

That's everything you need! In the above example, we are declaring a new ~OSCInHandler~ object that maps to a given *port* on the given *IP* address (with ~127.0.0.1~ being ~localhost~). All we have to do next is to map a function to every message being received at that address and poof. We now have a working soundbox. Let's break this down and take a look at all the features you can do when receiving OSC.

There are three methods you can call on your ~OSCInHandler~ object:

- ~.attach(address: str, function: Callable, watch: bool)~ : attach a callback to a given address. It must be a function. Additionally, you can set watch to ~True~ (~False~ by default) to also run the ~.watch~ method automatically afterhands.

- ~.watch(address: str)~ : give an address. The object will track the last received value on that address. If nothing has been received yet, it will return ~None~ instead of crashing \o/.

- ~.get(address)~ : retrieve the last received value to that address. You must have used ~.watch()~ before to register this address to be watched. Otherwise, you will get nothing.

** SuperCollider / SuperDirt

The ~default_superdirt.scd~ is... your default *SuperDirt* configuration. *SuperDirt* is the nickname of a very powerful audio engine used by some live coding libraries like *Sardine*. By default, this file will specify *where to look for audio samples* or *how many inputs and outputs* your system must use.

You must edit it manually if you are willing to change anything to it. This is outside of the reach of *Sardine* and it is preferable to let the user decide for the most suitable configuration. The [[https://github.com/musikinformatik/SuperDirt][SuperDirt]] repository is a good place to start, especially the ~hacks/~ folder. It will teach you how to edit and configure *SuperDirt* to your liking. *SuperDirt* was initially conceived for [[https://tidalcycles.org/][TidalCycles]]. You will find a great amount of customization options on their website too!

Here is an example showing of how to load more audio samples to play with:

#+begin_src supercollider
(
s.reboot {
    s.options.numBuffers = 1024 * 256;
    s.options.memSize = 8192 * 32;
    s.options.numWireBufs = 128;
    s.options.maxNodes = 1024 * 32;
    s.options.numOutputBusChannels = 2;
    s.options.numInputBusChannels = 2;
    s.waitForBoot {
        ~dirt = SuperDirt(2, s);
        ~dirt.loadSoundFiles;
        ~dirt.loadSoundFiles("/Users/bubo/Dropbox/MUSIQUE/LIVE_SMC/DRUMS/*");
        s.sync;
        ~dirt.start(57120, 0 ! 12);
        (
            ~d1 = ~dirt.orbits[0]; ~d2 = ~dirt.orbits[1]; ~d3 = ~dirt.orbits[2];
            ~d4 = ~dirt.orbits[3]; ~d5 = ~dirt.orbits[4]; ~d6 = ~dirt.orbits[5];
            ~d7 = ~dirt.orbits[6]; ~d8 = ~dirt.orbits[7]; ~d9 = ~dirt.orbits[8];
            ~d10 = ~dirt.orbits[9]; ~d11 = ~dirt.orbits[10]; ~d12 = ~dirt.orbits[11];
        );
    };
    s.latency = 0.3;
};
)
#+end_src

SuperDirt treats a wildcard (~*~) at the end of the path to mean that there are named subdirectories. If you want to load just one sample directory, omit the wildcard.

* Text Editor

Text editors are particularly important to get the most out of *Sardine*. Remember that this is a tool for *live coding* and that you will need to setup everything to feel comfortable. *Sardine* can support most text editors and IDEs. I have been using *Sardine* using *Vim*, *Neovim*, *Emacs*, *VSCode* and of course... the integrated text editor. This editor is provided mostly for workshops and demos. If you are planning for a gig or anything serious, please consider using and learning a real text editor.

** Fishery Web

You don't need a text editor to play with *Sardine*. Just start the software by typing ~fishery web~. Optionally, you can specify the ~--port~ and  ~--???~ arguments. Your web browser will promptly open, generally at ~https://localhost:8000~. Your code will automatically be saved in your configuration folder, under the ~buffer/~ folder, meaning you can retrieve it later for a new session!

#+begin_src shell
fishery web
fishery web --port 12345
#+end_src

#+attr_html: :width 800px
[[file:fishery_web.png]]

*Pre v0.2.3 version:* note that you have to manually build the text editor to be able to use it. In the ~/fishery/client~ directory, run ~yarn install~ and ~yarn run build~ to build the text editor. This should only be runned once everytime you install *Sardine*.

** Flok

*Sardine* has been integrated to [[https://github.com/munshkr/flok][Flok]], a collaborative text editor for live coding. Using ~Flok~, you can easily share a *Sardine* session with other musicians and visualists. ~Flok~ *is not an online version of Sardine*. You will still need to install it locally to have sound. However, if you are playing together with some friends in a single room, one only needs to have *Sardine* installed and active! To use ~Flok~, follow the following instructions:
- Install [[https://github.com/munshkr/flok][Flok]] on your computer if you want to use the audio backend (*Sardine* itself)!
- Go to [[https://flok.cc][flok.cc]] or [[https://sardine.doesnotexist.club][sardine.doesnotexist]] and create a new session by following the prompt.
- Share the session link with your friends. Use the command to connect your ~REPL~ to the session.
- Have fun!

To be 100% sure that everything will work perfectly, please use *Firefox*. *Chrome* has been reported not to work well with *MacOS*.

** VSCode

[[https://code.visualstudio.com/][VSCode]] is a powerful and all-devouring code editor developed by **Microsoft**. It is the most widely spread code editor out there with millions of users, thousands of plugins and corporate support. *VSCode* is more than capable of handling *Sardine* sessions and there are multiple ways to configure everything for it.

- Install the Python support for VSCode using the lateral menu. It might be the first package they will propose you given the popularity of Python!
- Open up a new terminal using the ~Create new Terminal in the Active Workspace~ command (Ctrl/Cmd + Shift + P and search ~>~).
- Type ~fishery~ and press enter to start a new session.
- Use ~Shift + Enter~ to send code to the terminal session.

This is a simple yet effective way of using *Sardine* while retaining all the power of *VSCode* at your fingertips!

** Vim / Neovim

*NeoVim* (and by extension *Vim*) is the editor I currently use on stage but its target audience is mostly developers, old Unix gurus and command-line users. *Vim* is a modal text editor with multiple modes for editing and jumping around in the source code. It can be extended using plugins and tweaked to your liking. Quite powerful, but it requires some learning to be proficient. The process for working with *Sardine* from *Neovim* is pretty straightforward:

1) install the [[https://github.com/jpalardy/vim-slime][slime]] plugin.
   - note that the technique to do so might vary depending on your configuration. I am using [[https://github.com/nanotee/nvim-lua-guide][Lua]] to write my configuration. In the past, I had previously used [[https://github.com/junegunn/vim-plug][Plug]] for years without encountering any issue!
2) split your workspace in two vertical (~:vs~) or horizontal (~:sp~) panes.
3) open up a ~:terminal~ in one of them and run ~fishery~.
4) work in the other one and use ~C-c C-c~ (~Control+C~ twice) to send code from one side to the other.
   - *slime* will probably ask you which job to target, just press enter!

** (Doom) Emacs

I am using *Doom Emacs* for many things in my life: writing this documentation, writing manuscripts and papers and.. playing some music with *Sardine*. The venerable *Emacs* is -- of course -- able to manage *Sardine*! Please use the ~python.el~ plugin. This mode will allow you to pipe easily your code from a text buffer to a running interpeter. The plugin is adding quality-of-life features for working with *Python* in general but also makes working with a *REPL* much easier and much more convenient. If you are new to the vast world of *Emacs*, it is probably worthwhile to take a look at [[https://github.com/doomemacs/doomemacs][Doom Emacs]] or [[https://github.com/syl20bnr/spacemacs][Spacemacs]], both being equally great. I will not dive into more details. If you are able to configure *Emacs*, you will be able to configure your editor for *Sardine* :).

The following code is the one I use for running *Sardine* using *Doom Emacs*. It is not great and I should probably make something cleaner or even create a dedicated package for *Sardine* but life is short, and nobody is writing the docs while I finetune my *Emacs* config.

#+begin_src lisp
;; =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;; SARDINE MODE
;; =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;; Customize the python-mode to run Sardine code using the terminal.

(setq
 python-shell-interpreter "fishery"
 python-shell-interpreter-args "")

(defun sardine/start-sardine ()
  "Start a new interactive Sardine Session"
  (interactive)
  (run-python))

(defun sardine/eval-block ()
  "Evaluate a sardine code block"
  (interactive)
  (mark-paragraph)
  (if (and transient-mark-mode mark-active)
      (python-shell-send-region (point) (mark))
    (python-shell-send-region (point-at-bol) (point-at-eol)))
  (forward-paragraph))

(defun sardine/stop-code ()
  "Stop all the Sardine code currently running"
  (interactive)
  (python-shell-send-string "panic()"))

; Unmapping keys from the Python mode
(add-hook 'python-mode-hook
          (lambda() (local-unset-key (kbd "C-c C-c"))))
(add-hook 'python-mode-hook
          (lambda() (local-unset-key (kbd "C-c C-s"))))

; Remapping keys
(global-set-key (kbd "C-c C-c") #'sardine/eval-block)
(global-set-key (kbd "C-c C-s") #'sardine/stop-code)
#+end_src

** Others


In the past, people have been running *Sardine* code on many different text editors and platforms:
- [[https://jupyter.org][Jupyter Notebook]]: a very popular framework for using *Python* in data sciences, machine learning, etc.
- [[https://github.com/atom][Atom]] (*depracated*) / [[https://pulsar-edit.dev/][Pulsar]]: killed by *Microsoft*, was once a very nice but slow text editor/IDE.

We know this is working, but there is no documentation about it or the one we have is outdated!

* Getting started
** Starting Sardine

Before starting *Sardine*, you need understand what *Sardine* is and where it sits on your system:
- *Fishery* is the *Sardine* interpreter. To play with *Sardine*, you need to start ~fishery~.
- *Sardine* is the main *Python* library that you will be interacting with.
- Behind the scene, everything will be translated to *SuperCollider*, *MIDI* or *OSC* messages : ~text editor -> fishery -> sardine -> SuperCollider/MIDI/OSC~

Do not try to import ~sardine~ in a regular *Python* interpreter! It won't work, you will be disappointed. Whenever you start ~fishery~ in your terminal, the following splashscreen will appear:
#+begin_src python
╭──────────────────────────────────────────────────────╮
│                                                      │
│ ░██████╗░█████╗░██████╗░██████╗░██╗███╗░░██╗███████╗ │
│ ██╔════╝██╔══██╗██╔══██╗██╔══██╗██║████╗░██║██╔════╝ │
│ ╚█████╗░███████║██████╔╝██║░░██║██║██╔██╗██║█████╗░░ │
│ ░╚═══██╗██╔══██║██╔══██╗██║░░██║██║██║╚████║██╔══╝░░ │
│ ██████╔╝██║░░██║██║░░██║██████╔╝██║██║░╚███║███████╗ │
│ ╚═════╝░╚═╝░░╚═╝╚═╝░░╚═╝╚═════╝░╚═╝╚═╝░░╚══╝╚══════╝ │
│                                                      │
│ Sardine is a MIDI/OSC sequencer made for live-coding │
│ Play music, read the docs, contribute, and have fun! │
│ WEBSITE: https://sardine.raphaelforment.fr           │
│ GITHUB: https://github.com/Bubobubobubobubo/sardine  │
│                                                      │
╰──────────────────────────────────────────────────────╯
BPM: 120.0,BEATS: 4 SC: [X], DEFER: [X] MIDI: Sardine
>>>
#+end_src

Only then will you know that *Sardine* has started and that everything is working! Some additional messages are likely to appear shortly after, warning you that the audio engine was hooked correctly or that an error has happened somewhere.

- You can write code directly in the interpreter. However, this is not a recommended practice!
  - You will soon begin to see that the system will print some useful information, preventing you from writing easily in the interpreter window. You should jump to your text editor!

- For the duration of this tutorial, I will make the assumption that you are using ~fishery web~, our internal text editor and environment!

** Code evaluation

To live code, you always need to have two things :
- a document where you write your code.
- a running interpreter that will receive code.

One pattern is the base of everything, *sending new code for evaluation* :
- Your main document is your playing interface. Write / edit / change code.
- Send new code whenever you are ready by pressing a key.

On the included web text editor, press *Shift + Enter* or *Ctrl+E* to send code for evaluation. The entire code block will be evaluated! If an error occurs, the application will not stop but will report the error and continue running using an older version of the code. The interpreter will warn you if something goes wrong!

Write the following line and evaluate it:
#+begin_src python
Pa >> d('bd, cp')
#+end_src

At the beginning of the next bar, a musical pattern will start to play. This pattern will be composed of a kickdrum and a clapping sound in quick succession. We just evaluated our first *pattern*. This pattern will repeat indefinitely until you stop it.

To stop a pattern, use one of the following functions:
#+begin_src python
silence() #  gentle shutdown
panic() #  hard stop (will be detailed later)
#+end_src

You can also be more precise about your intentions by giving the name of the pattern you want to stop:
#+begin_src python
silence(Pa)
#+end_src

We will now repeat the kickdrum two times. Change the code and press *Shift+Enter* again:
#+begin_src python
Pa >> d('bd!2, cp')

silence(Pa)
#+end_src

You can  *live code* anything. The system will jump to the new version of your code as soon as you submit it. This is how you *live code*. From now on, we will only get more specific and precise in the code we submit.

Evaluating code takes some practice. There are some pitfalls to avoid:
- you sometimes need to evaluate things in a specific order.
- you need to make sure that ALL your needed code is evaluated.
- sending code can fail for cryptic reasons (invisible characters), etc.

*Summary:*
- *Shift + Enter*: submitting new code.
- ~silence()~ or ~panic()~: stop the execution of code.

** Samples and Synths

Why were we hearing a bassdrum and then a clap? Where does the rhythm comes from? *Sardine* is based on the *SuperDirt* audio engine. This is *SuperDirt*'s doing. *SuperDirt* expects to receive information about audio samples and synthesizers using a simple messaging system. *SuperDirt* expects to receive information about audio samples and synthesizers using a string (~bd~, ~cp~, etc.).

When you say ~Pa >> d('bd')~, the sound played will be the first audio sample contained in a folder called ~bd~. By default, there are a lot of samples automatically loaded by *SuperDirt*:
#+begin_src text
217 existing sample banks:
808 (6) 808bd (25) 808cy (25) 808hc (5) 808ht (5) 808lc (5) 808lt (5) 808mc (5)
808mt (5) 808oh (5) 808sd (25) 909 (1) ab (12) ade (10) ades2 (9) ades3 (7)
ades4 (6) alex (2) alphabet (26) amencutup (32) armora (7) arp (2) arpy (11)
auto (11) baa (7) baa2 (7) bass (4) bass0 (3) bass1 (30) bass2 (5) bass3 (11)
bassdm (24) bassfoo (3) battles (2) bd (24) bend (4) bev (2) bin (2) birds (10)
birds3 (19) bleep (13) blip (2) blue (2) bottle (13) breaks125 (2) breaks152 (1)
breaks157 (1) breaks165 (1) breath (1) bubble (8) can (14) casio (3) cb (1) cc (6)
chin (4) circus (3) clak (2) click (4) clubkick (5) co (4) coins (1) control (2)
cosmicg (15) cp (2) cr (6) crow (4) d (4) db (13) diphone (38) diphone2 (12) dist (16)
dork2 (4) dorkbot (2) dr (42) dr2 (6) dr55 (4) dr_few (8) drum (6) drumtraks (13)
e (8) east (9) electro1 (13) em2 (6) erk (1) f (1) feel (7) feelfx (8) fest (1) fire (1)
flick (17) fm (17) foo (27) future (17) gab (10) gabba (4) gabbaloud (4) gabbalouder (4)
glasstap (3) glitch (8) glitch2 (8) gretsch (24) gtr (3) h (7) hand (17) hardcore (12)
hardkick (6) haw (6) hc (6) hh (13) hh27 (13) hit (6) hmm (1) ho (6) hoover (6) house (8)
ht (16) if (5) ifdrums (3) incoming (8) industrial (32) insect (3) invaders (18) jazz (8)
jungbass (20) jungle (13) juno (12) jvbass (13) kicklinn (1) koy (2) kurt (7) latibro (8)
led (1) less (4) lighter (33) linnhats (6) lt (16) made (7) made2 (1) mash (2) mash2 (4)
metal (10) miniyeah (4) monsterb (6) moog (7) mouth (15) mp3 (4) msg (9) mt (16) mute (28)
newnotes (15) noise (1) noise2 (8) notes (15) numbers (9) oc (4) odx (15) off (1) outdoor (6)
pad (3) padlong (1) pebbles (1) perc (6) peri (15) pluck (17) popkick (10) print (11) proc (2)
procshort (8) psr (30) rave (8) rave2 (4) ravemono (2) realclaps (4) reverbkick (1)
rm (2) rs (1) sax (22) sd (2) seawolf (3) sequential (8) sf (18) sheffield (1) short (5)
sid (12) sine (6) sitar (8) sn (52) space (18) speakspell (12) speech (7) speechless (10)
speedupdown (9) stab (23) stomp (10) subroc3d (11) sugar (2) sundance (6) tabla (26)
tabla2 (46) tablex (3) tacscan (22) tech (13) techno (7) tink (5) tok (4) toys (13)
trump (11) ul (10) ulgab (5) uxay (3) v (6) voodoo (5) wind (10) wobble (1) world (3)
xmas (1) yeah (31)
... file reading complete. Required 444 MB of memory.
#+end_src

It means that you can replace ~bd~ by ~tech~ and it will work! You can summon any audio sample you like.

The same syntax is used to call synthesizers:
#+begin_src python
# You will need sc3_plugins for it to work
Pa >> d('supersaw, superpiano')

silence(Pa)
#+end_src

These synths are labelled ~super~ because they come installed by default with *SuperDirt*. You can write your own synthesizers using [[https://supercollider.github.io/][SuperColider]] and add them to your setup. That's what experimented players do. They have custom libraries full of synthesizers and audio samples! For now, we will stick to default.

For audio samples, note that you can also be more specific about the file you want to select:
#+begin_src python
Pa >> d('voodoo:0, voodoo:1, voodoo:2')

silence(Pa)
#+end_src

This pattern will play the first, second and third sample from the ~voodoo~ folder. The sample count starts at *0* and never ends. Don't be afraid of adding a very high number, it will wrap around! It wont crash!

*Summary:*
- You can call synthesizers of samples using ~"strings"~.
- You can call a specific sample by using a specific number: ~bd:4~.
- ~"names"~ can refer to a synth or a sample. There is no difference.

** Sound Patterns

We know how to play basic sounds, but we don't know why this is happening. How unfortunate! Remember for a moment about the pattern we wrote before:

#+begin_src python
Pa >> d('bd, cp')
#+end_src

This line is using a shorthand syntax for writing down patterns. This is a useful syntax to master, especially for new users.

~Pa~ is a player. ~Pa~ wants to eat a pattern. ~d()~ is providing him a pattern. There are 48 players by default:
#+begin_src python
all_players = [Pa, Pb, Pc..., PA, PB, PC, ...]
#+end_src

This pattern can take *any number of arguments*. These arguments will help to precise the timbre, rhythm and pitch of your pattern. A *Sardine* pattern is... *a sandwich of values*. Here is a more complex pattern based on the one we saw earlier:
#+begin_src python
Pa >> d('bd, cp', speed='1,2', shape=0.5, room=0.5, dry=0.25, size=0.1, p='0.5!4, 0.25')

# This is easier to read
Pa >> d('bd, cp',
        speed='1,2',
        shape=0.5,
        room=0.5,
        dry=0.25,
        size=0.1,
        p='0.5!4, 0.25'
)
#+end_src

- ~p~ for *period*: the rhythm of each step in *beats*. It can be a number or *string*.
  - This value is always relative to the tempo!
- ~shape~, ~room~, etc.: parameters of the audio sampler, helping us to shape the sound.

There are two types of arguments you can give to a pattern:
- *pattern-relative*: They will teach the system how your pattern will unfold in time (~period~, ~divisor~, ~rate~, etc).
- *instrument-relative :* arguments specific to *SuperDirt* / *MIDI* / *OSC*. They will help to precise what output you would like to get out of your pattern.

To know the complete list of all the possible parameters, you will have to refer to the *SuperDirt Reference* included in the sidebar! Note that you can also add more parameters later on if you tweak your audio engine.

As you might have noticed already, there is a difference between arguments that are plain numbers and arguments that are specified as a string (in green). The difference is that numbers are just numbers but strings are interpreted as *patterns*. They move in time with each step. It means that the following pattern: ~"0.5!4, 0.25!2"~ is in fact: ~[0.5, 0.5, 0.5, 0.5, 0.25, 0.25]~. Don't focus too much on it for the moment, we will come back to it later on! There is much depth to what a pattern is and what you can do with them.

*Summary:*
- *Patterns* are a complete description of an algorithmic musical pattern: *pitch*, *timbre*, *rhythm*, etc.
- *Patterns* are collection of values or other patterns.
- *Patterns* can take an undefinite amount of arguments.
- *Patterns* can use a special syntax in between ~strings~ for writing better patterns.

** Tempo and playback

*Sardine* will always try to execute code based on a timing given by its clock. The clock is always there, from the moment you start the software until the moment you exit. The clock is the main mechanism that takes your code and makes it live. There are currently two different clocks you can use:
- *the internal clock:* Your regular system clock.
- *the external clock:* A special clock *for synchronisation on the network*.

These clocks have the same interface! If you learn how to use one of them, you know how to use them all.

If you type ~clock~ in your *fishery* window, you will get a similar message:
#+begin_src python
<InternalClock running time=1.9 tempo=135 beats_per_bar=4>
#+end_src
Time has passed since the beginning of time. We are currently sailing, and you can see that the clock is active.

Here are some attributes that you might find interesting :

- ~clock.tempo~ : reports the current tempo.
  - to change the tempo, you can type ~clock.tempo = 140~
- ~clock.phase~ / ~clock.beat~ / ~clock.bar~
  - our position in time, from the smallest division to the largest division. You will be able to use these attributes later on for composing in time!
- ~clock.time~: the most basic representation of time (monotonic time)

You can pause, resume, restart or stop your code at any given time using the ~bowl~:
- ~bowl.pause()~ / ~bowl.resume()~ : pause and resume.
~ ~bowl.stop()~ / ~bowl.start()~: stop and play.

#+begin_src python
print(clock)
bowl.pause()
print(clock)
bowl.resume()
print(clock)
#+end_src

* Basics
** Swimming functions

*Sardine* very existence is tied to the notion of *swimming functions*. A *swimming function* is a specific type of function that can easily be modified and updated *on the fly*, whenever you want. Strictly speaking, a *swimming function* is a *temporally recursive function*, a construct used by many programming languages in the realm of music and digital art. This way of writing functions is extremely interesting. People have been playing with the concept for more than 30 years now. If you dig deep enough, you will find that the concept of *temporal recursive functions* is at the very base of computer music systems such as *SuperCollider*.

Here is a basic Python function that you might already be familiar with:
#+begin_src python
def hello_world():
    print('Hello, World!')
#+end_src

You can call this function like so:
#+begin_src python
hello_world()
#+end_src

However, this will only be executed once. It is not very interesting for live coding or playing on stage. A few remarks:
- it would be much better if the function could be called again, indefinitely, in rhythm.
- it would be nice if we could reevaluate that function to change its behavior, whenever you want.

A *swimming function* is doing precisely doing that! It comes at a cost, a slightly different syntax. Evalute this:
#+begin_src python
@swim
def hello_world():
    print('Hello, World!')
    again(hello_world)
#+end_src

Your interpreter window will now be polluted by the message ~Hello, World!~ printing on repeat. This is a good sign! The function will now be repeated indefinitely, until you change something. Let's change something then:
#+begin_src python
@swim
def hello_world():
    print('Goodbye, World!')
    again(hello_world)
#+end_src

Now it prints ~Goodbye, World!~. You can alter a swimming function whenever you want. Whenever you add ~@swim~ and ~again()~, you make the function recursive. It is calling itself again and again.

You can stop a *swimming function* by changing the decorator (the ~@~ that /decorates/ our function):
- ~@swim~: the function will loop.
- ~@die~: the function stops looping.

Let's stop our first *swimming function* then:
#+begin_src python
@die
def hello_world():
    print('Goodbye, World!')
    again(hello_world)
#+end_src

Even though the function is fully written, it will not play anymore. Try to rewrite ~@swim~ again to make it start anew. You can also try to remove some parts of the function (the call to ~again()~) to see what happens. Try to familiarise yourself with *swimming functions* because they are exciting!

You might be wondering what happens if a function is invalid. Under pressure, on stage, you can easily write a function that just doesn't make sense. Here is a fictional one written by an animal suddenly falling on the keyboard:
#+begin_src python
@swim
def hello_world():
    qsjdfmlsqfdkjlm
    print('Goodbye, World!')
    again(hello_world)
#+end_src

You can try to evaluate this function. If you do so, the following will happen:
- If the function was previously running: *Sardine* will continue with the previous one that worked!
- If the function is brand new: *Sardine* will refuse to play and will warn you.

This means that you are immune to crash! You can experiment freely. The next step for you is now to try to make the system crash even by respecting these rules. It can happen, you have to be creative!

** Time and swimming

*Swimming functions* are interesting but they always repeat at the same rate. What if we want to repeat the function, but in rhythm?

The answer, once again, is the ~p~ (~period~) argument. This argument will allow you to precise the time of your *temporal recursion*. You can repeat the function every beat, every two beats, twice in a beat, etc...

This function will clap twice per beat. Try to change the value in the last call to ~again()~:
#+begin_src python
@swim
def yes(p=0.5):
    D('cp')
    again(yes, p=0.5)
#+end_src

You now control the rate of repetition, which is the very basic of playing in rhythm. Obviously, we can be more clever than that. Hold on for a moment :)

What you are doing here, basically speaking, is passing a new ~period~ to your future function. You call that function *again* with a new period. The first value you give to ~p~ if your function signature has no importance because time is not flowing yet. After the first iteration, you basically *recall* your function with a new value of ~p~, and again, and again, and again.. It loops! With loops, we can describe a lot of different things!

But.. wait. If we can pass a new value to the same function in the future, it means that we can also pass it some information! Let's try this:

This function will start to count, because the value of ~i~ will be incremented every time we loop around:
#+begin_src python
@swim
def counter(p=0.5, i=0):
    print(f"Counter: {i}")
    again(counter, p=0.5, i=i+1)
#+end_src

This is *the stereotypical swimming function* and *you need to learn it by heart*. You can even start training writing it as fast as you can. You will type it a lot because this is an extremely convenient way to think about time both as a /cycle/ (it loops) and as a continuity (we can count how many times it loops). Many many things in *Sardine* are based on this concept. Pretty much all of it!

** Swimming rhythm

This section will teach you the last basic concepts you need to understand to truly master *Sardine*! By reading what comes before, you should now know:
- how to evaluate and update your code anytime you want.
- how to play sounds and send notes to your synthesizers and instruments.
- how to play with the shorthand syntax and with *swimming functions*.
- how to describe looping processes and how to count in time.

This is where *Sardine* starts to get more creative because we will do something with these new found powers. *Sardine* is basing a lot on two concepts:
- *temporal recursion* aka *swimming functions*
- *iterations*: counting up and down.

*** Iterator

Remember about patterns? Patterns were these things that we were writing in ~strings~ like so:
#+begin_src python
"C, E, G, B"
"bd!2, cp:rand*20, tabla"
"1, 2, 3, 4"
#+end_src

I told you before that you could *use strings in your senders* and that this *would transform them into sequences*. Let's explore that:
#+begin_src python
@swim
def sequence(p=0.5, i=0):
    D("bd!2, cp:rand*20, tabla")
    again(sequence, p=0.5, i=i+1)
#+end_src

All you are hearing is a kick, right? We are looping, but how do we tell *Sardine* to move ahead in time? For that, we will be using that counter we saw earlier. This counter can be fed to a pattern to tell him where we are in time:
#+begin_src python
@swim
def sequence(p=0.5, i=0):
    D("bd!2, cp:rand*20, tabla", i=i)
    again(sequence, p=0.5, i=i+1)
#+end_src

~i~ stands for ~iterator~ and *every sender can receive an iterator*. Your pattern is now alternating between ~bd~, ~cp~ and ~tabla~. That is because it plays the first sound in the sequence, then the second one, then the third one, and all over again. Your iterator can be infinitely big, the sequence will just loop around!

Take a look at this musical sequence using patterns of different lengths with a single iterator:
#+begin_src python
@swim
def sequence(p=0.5, i=0):
    D("bd!2, cp:rand*20, tabla",
      speed='1,2,3,4,5,6',
      lpf="200+rand*2000",
      i=i
    )
    again(sequence, p=0.5, i=i+1)
#+end_src

This opens up a new world of complexity because *every parameter can be patterned*, including the ones that you wouldn't have thought about: MIDI channels, instruments, etc... You can start patterning every musical information at your fingertips!

*** Jumping in time(s)

Time flows. We all know that. With *Sardine*, you can also play with the idea of making time flow backwards, or randomly. Time is only symbolised by a single number, your iterator. It means that by controllign this iterator wisely, you can control the direction to give to your musical sequence:
#+begin_src python
@swim
def sequence(p=0.5, i=0):
    ...
    again(sequence, p=0.5, i=i-1) # Code changed here
#+end_src

It now flow backwards, but let's also make it flow... randomly. To do that, we can use the ~random.randint()~ function from *Python*:

#+begin_src python
from random import randint

@swim
def sequence(p=0.5, i=0):
    ...
    again(sequence, p=0.5, i=randint(1,100)) # Code changed here
#+end_src

And it will now jump between 100 different positions. You can also start to play around with different ideas:
- having multiple iterators flowing at different speeds.
- freezing an iterator, resuming it based on a condition.
- etc...

*** Divisor and rate

And now it becomes truly bizarre. What if we had some other tools to control how fast we iterate over our musical sequence?

I told you about ~i~ (the ~iterator~) but it also comes to the party with some friends: ~r~ (the rate) and ~d~ (the divisor):
- the ~rate~ will count how many times you need to increment your number for it to move upwards or backwards by 1. It will basically make it much harder or much easier to increase or decrease the index of your patterns.
- the ~divisor~ will just refuse to play some events if the iterator ~modulo~ the ~divisor~ is equal to zero. Doesn't make sense to you? Think rhythm generator. Try to experiment with this :)

** Basic of Senders

Previously, you might have noticed that we used ~d()~ without talking about its true nature!

~d()~ is what we call a *Sender*. It is a special function that takes care of sending messages to your musical applications or audio tools. It also provides an interface to any pattern language that you'd like to use. Basically, *senders are a gate to the outside world*.

*Senders* are numerous, and more can be created depending on your needs. By default, there are a couple of pre-declared ones that you will be using *all the time*:
- ~D()~ and ~d()~: *SuperDirt* sender.
- ~N()~ and ~n()~: *MIDI* notes.
- ~CC()~ and ~cc()~: *MIDI* control messages.
- ~PC()~ and ~pc()~: *MIDI* program changes.

These *senders* both exist in uppercase and lowercase. Why is that?
- *UPPERCASE* players are the basic *senders*.
- *lowercase* players are to be used with the shorthand notation: ~Pa >> d('bd')~.

There are some additional *senders* that you can use to play with the *Ziffers* patterning language:
- ~ZD()~ or ~zd()~: the *Ziffers SuperDirt* senders.
- ~ZN()~ or ~zn()~: the *Ziffers MIDI* note senders.

The following example is highlighting the very basic usage of these *senders*:
  #+begin_src python
Pa >> n('C5, E5, G5', p=0.25) # playing a chord, one note every 1/4 of a beat.
Pb >> cc(ctrl=20, chan=0, value='rand*127') # sending a random MIDI control on ctrl 20, channel 0
Pc >> d('tabla, tabla:2') # Playing audio samples of an indian tabla
  #+end_src

** Player arguments

Every *sender* is specialised for a task. Every *sender* will have its own special arguments. Some of them can also be aliased (/e.g/ ~vel~ for ~velocity~). Learning these arguments is part of learning the *Sardine* instrument. There is no way around it!

*** MIDI Arguments

There are multiple *senders* for *MIDI* because there are different *MIDI* messages you can write. To each messsage its sender.

- ~N("pattern", velocity, channel, duration)~: the *sender* for MIDI notes.
  - ~velocity~ or ~vel~: how hard the note is played, from 0 to 127.
  - ~channel~ or ~chan~: on which channel to play the note (from 0 to 15).
  - ~duration~ or ~dur~: for how long to play the note (in beats).


- ~CC(control, channel, value)~: the *sender* for MIDI control changes.
  - ~control~ or ~ctrl~: number of the control to target (0 to 127).
  - ~channel~ or ~chan~: on which channel to send the control.
  - ~value~ or ~val~: value of that control (0 to 127).


- ~PC(program, channel)~: the *sender* for *MIDI* program changes.
  - ~program~ or ~prog~: program number to send.
  - ~channel~ or ~chan~: on which channel to send the control.

There is also a special ~SY~ sender that is very experimental and is used to control some very specific gear. I have currently no plan to open it for others to play but you can still send Sysex messages by using private methods of the ~midi~ object. The basic senders should cover 99% of your needs. If ever you were to miss one, it is easy to add them. Just contact me!

*** SuperDirt Arguments

There is only one *sender* for *SuperDirt*: ~D()~ or ~d()~. This sender is a basic interface to *SuperDirt*, allowing you to play sounds or synthesizers and to add effects to them. You will notice that the *SuperDirt* sender can take any number of arguments. It all depends on how much arguments your synthesizers can take and on how precise you want to be in the description of a specific musical event.

- ~D("pattern", orbit=0)~: the *sender* for *SuperDirt*.
  - ~orbit~ : channel the sound will played on (mono or stereo).

The concept of ~orbit~ is just a way to precise on which channel of the audio console some specific effects should be applied. Assigning an orbit to an event guarantees that the sound you want to play (reverb amount, low-pass filter, etc...) will only be local and not global to every other pattern currently playing. This concept of ~orbit~ is an important concept specific to *SuperDirt*.

* Pattern Languages
** Sardine Pattern Language

The pattern language is everywhere in *Sardine*. Everytime you use any of the senders (~D()~, ~N()~, ~P()~ and their lowercase variants), you are likely to encounter it. *Sardine* automatically turns every argument it receives as a ~string~ in an expression that is read using the *pattern language*:

#+begin_src python
D('bd', speed=1, legato=2) # speed and legato are using regular Python types

D('b', speed='1|2', legato='1~4') # speed and legato are now patterns (string)
#+end_src

You can't even use a synthesizer or play a note without writing at least one pattern (the initial string). One call to the senders/handlers can result in multiple patterns being interpreted by the *Sardine pattern language* at once.

Think of it as having a second programming language inside your programming language.

Why?

- It saves space, it makes it easier to express complex transformations fast.
- It gives you access to new operators that *Python* doesn't provide.
- It makes writing lists way easier and less verbose.

*** Numbers

#+begin_src python
@swim
def number(p=0.5, i=0):
    print(Pat('1, 1+1, 1*2, 1/3, 1%4, 1+(2+(5/2))', i))
    again(number, p=0.5, i=i+1)
#+end_src

You can write numbers (both *integers* and *floating point numbers*) and use common operators such as addition, substraction, division, multiplication, modulo. Parentheses are supported. *Sardine* makes it so that most arithmetic operators can be used on anything expect if intuitively it doesn't make sense at all like multiplying a string against a string.

*You can apply arithmetic operators to numbers but also to lists!* You can for instance write an addition between a number and a list, between two lists, between a number and a note, between a chord and a list, etc..

Incidentally, it means that functions that work on lists can also work on single tokens. It also means that functions that are supposed to work for single numbers will work for lists, because the function will be mapped to every element in the list. *It turns the act of composing patterns into a rather interesting process.*

**** Time-dependant numbers

#+begin_src python
@swim
def number(p=0.5, i=0):
    # We print time-dependant values
    print(P('$, $.p, $.m', i))
    again(number, p=0.5, i=i+1)
#+end_src

Some number tokens are clock-time dependant (based on *Sardine* clock time).  Depending on the moment your loop/operation takes place, you might see some values recurring because you are not polling time continuously but at predictible rhythmic moments of time. Read that sentence twice, then read it again, *please*!

- ~$~: *beat*, the current beat, with floating point precision.
- ~$.p~: *phase*, a number between ~0~ and ~1~ denoting where you are in the beat.
- ~$.m~: *measure*, the measure since the clock started.

#+begin_src python
@swim
def number(p=0.5, i=0):
    print(Pat('$, $.m, $.p', i))
    again(number, p=0.5, i=i+1)
#+end_src

Some other number tokens are based on *absolute time*. They are not dependent on the clock. Use them for long-running sequences for introducing randomization. You will notice that they are all prefixed by ~T~. ~T~ is a symbol very often associated with *time* in *Sardine*, while ~$~ denotes the clock time.

#+begin_src python
@swim
def wow(p=0.5, i=0):
    print(Pat('T.U, T.Y, T.M, T.D, T.h, T.m, T.s, T.µ', i))
    again(wow, p=0.5, i=i+1)
#+end_src

- ~T.U~: Unix Time, the current Unix Time.
- ~T.Y~: year, the current year.
- ~T.M~: month, the current month.
- ~T.D~: day, the current day.
- ~T.h~: hour, the current hour.
- ~T.m~: minute, the current minute.
- ~T.s~: second, the current second.
- ~T.µ~: microsecond, the current microsecond.

**** Random numbers

- You can write random numbers by using the word ~rand~. ~rand~ will return a floating point number between ~0.0~ and ~1.0~.
  - In some contexts, ~rand~ will be casted to *Integer* if it makes more sense (context dependant, _e.g_ ~sample:r*8~).
- ~rand~ and ~0.0~1.0~ yield a similar result. Two ways to express the same idea.

**** Patterns out of time

#+begin_src python
@swim
def outof(p=0.25, i=0):
    D('cp', speed='$%10', i=i)
    again(outof, p=0.25, i=i+1)
#+end_src

Timed tokens make good *low frequency oscillators*, *ramps* or oscillating patterns. Playing with time tokens using modulos or the ~sin()~, ~cos()~ or ~tan()~ functions is a great way to get generative results out of a predictible sequence.

- The faster you recurse (low ~p~), the better your timing resolution is. You can start to enter into the realm of signal-like patterns that can be particularly good for generating fluid patterns. *Use this to generate fluid patterns.*

*** Names

#+begin_src python
@swim
def names(p=0.5, i=0):
    D('bd, pluck, bd, pluck:2+4', i=i)
    again(names, p=0.5, i=i+1)
#+end_src

You are using names since your first *Sardine* session! A single letter (if it's not already a note name) can be considered as a name. Be careful! There are a few hidden rules for names. Names can be one letter long but some letters are already taken by some tokens of the language (such as ~rand~). Names cannot begin with a number. It is also forbidden to use any symbol inside your names.

Names can't start with a number. It will cause you problems with playing some default samples. Be warned!

*** Addresses

#+begin_src python
O(osc_client, "an/address, another/address", value=1, other_value=2)
#+end_src

- Addresses are just like names except that they can contain a `/` separator just like any other typical OSC address.
- They are not really distinct from a name. The difference is only conceptual.

Be careful, some functions might still require you to write addresses using a ~/~ first. Check twice.

*** Operators

*Python* is limited to a set of operators and you can't create your own. That's not good for us because live coding is also about speed. It is faster to write ~!!~ than to write ~repeat_and_copy~. That's also why having a *pattern language* is important. We have new operators to work with to create musical patterns.

**** Choice

#+begin_src python
@swim
def choosing_stuff(p=0.5, i=0):
    D('bd|pluck', speed='1|2', i=i)
    again(choosing_stuff, p=0.5, i=i+1)
#+end_src


The pipe operator ~|~ can be used on anything to make a 50/50% choice between two tokens. You can also chain them: ~1|2|3|4~. The behavior of chaining multiple choice operators has not been clearly defined. The distribution might not be the one you expect.

**** Ranges

#+begin_src python
@swim
def rangeD(p=0.5, i=0):
    D('pluck|jvbass', speed='1~5', i=i)
    again(ranges, p=0.5, i=i+1)
#+end_src

- If you want to generate a number in the range ~x~ to ~y~ included, you can use the ~~~ operator. This operator will adapt to context (integer or floating point number).

- It can be used as an alternative to ~rand~ for scaled randomisation.

**** Ramps

#+begin_src python
@swim
def rampD(p=0.5, i=0):
    D('amencutup:[0:10]',
        room='[0:1,0.1]',
        cutoff='[1:10]*100', i=i)
    again(ramps, p=0.5, i=i+1)
#+end_src

- This operator is very reminiscent of the *range()* function, only better.

- You can generate ramps of integers using the ~[1:10]~ syntax.
  - This expression will yield ~[1,2,3,4,5,6,7,8,9,10]~.

- You can ramp up and you can ramp down!

- You can be more specific: ~[1:10,2]~.
  - This expression will yield: ~[1,3,5,7,9]~.

- It also works with floating point numbers and floating point number steps: ~[1:10,0.5]~!

**** Repeat

#+begin_src python
@swim
def repeat_stuff(p=0.5, i=0):
    D('pluck|jvbass', speed='1:2', midinote='C4!4, E4!3, E5, G4!4', i=i)
    again(repeat_stuff, p=0.5, i=i+1)
#+end_src

- The ~!~ operator inspired by **TidalCycles** is used to denote the repetition of a value.
  - You need to add a number or a list to its right side.

- There is also the ~!!~ to be used on lists. This second one will not repeat the content of the list but repeat each element ~x~ times.

**** Silence

#+begin_src python
@swim
def silence_demo(p=0.5, i=0):
    D('bd,...', i=i, d=1)
    D('hh,., hh,..', i=i, d=1)
    again(silence_demo, p=1/8, i=i+1)
#+end_src

- You can use a dot (~.~) inside any pattern to denote a silence. Be careful, the concept of silence in *Sardine* can be pretty confusing.

Silence is a very important and complex topic. Adding silences is a great way to generate interesting patterns. Silences are different for each sender because silence doesn't have the same meaning for a sampler, a MIDI output or an OSC output (~D()~, ~N()~, etc.).
- ~D()~: a silence is the absence of a sample. The event will be skipped.
- ~N()~: a silence is the absence of a note. The event will be skipped.
- any OSC based Sender: a silence is the absence of an address. The event will be skipped.

Perfect, but what about other patterns that live alongside the main pattern? A silence in an auxilliary pattern will cause a *'parametric silence'* to happen. Take a look at the following example:

#+begin_src python
@swim
def silence_demo(p=0.5, i=0):
    D('sitar', legato='0.5', speed='[1:4], .!8', i=i, d=1)
    again(silence_demo, p=1/8, i=i+1)
#+end_src

We always have a sample here. There is no *real* silence, only a parametric one (in ~speed~).

Denoting the absence of something the silence will cause the pattern to search its last value and hold it. *Sardine* will backtrack and search the last value that could have been generated by the pattern. The result of the ~speed~ parameter will then be ~[1,2,3,4,8,8,8,8,8,8,8,8]~.

For people familiar with modular synthesizers and analog circuits, this is pretty much a *sample & hold* mechanism.

Note that it is impossible to write a *parametric silence* composed only of silences. A pattern of nothing is not a pattern.

**** Lists and Collections

The *Sardine* pattern notation is built around the idea of having multiple ways to deal with linear lists and collections. The basic arithmetic syntax and most operators work on single tokens *but will also work on lists*. It means that you can write expressions such as :

#+begin_src python
[0,1,2,3]%8
[0,2,4,5]*[4,5]
[1:8,0.1]&[2,9]
[0,2,4,5,9,10,12,14]!2
[0,2,4,5,9,10,12,14]!!4
#+end_src

There are a few special operators that are only available when you deal with lists. This is something you will get familiar with by trying. You will see that most things work while some will not yield the result you expect.

**** Slicing and indexing

#+begin_src python
@swim
def test_slice(p=0.5, i=0):
    D('pluck:19',
            legato=0.2,
            midinote='([60,63,67,69, 71]&[i.i, i.i + 8])^(1~8)', i=i)
    again(test_slice, p=0.125, i=i+1)
#+end_src

- You can get a slice or just one value from a list by using the special ~&~ operator.
- It will work with any list on the right side of the operator but it will only take the first and second value of it no matter what to compose a slice.

- The index value can be infinite because the index is looping on the list. You can feed a random number generator and get something out.

On the down side, it can become quite complex to write very fast, so be careful with it:

#+begin_src python
@swim
def test_slice(p=0.5, i=0):
    D('pluck:19',
            legato=0.2,
            midinote='[60,62, 63,67, 69, 71]^(1~5)&[r, rand*4]', i=i)
    again(test_slice, p=0.125, i=i+1)
#+end_src

**** Extend

#+begin_src python
@swim
def test_extend(p=0.5, i=0):
    D('pluck:19', legato=0.2, midinote='[60,62]!2', i=i)
    again(test_extend, p=0.125, i=i+1)
#+end_src

Just like with numbers, names and addresses, you can extend a list by calling the ~!~ operator on it. It will repeat the list x times.

**** Extend-repeat

#+begin_src python
@swim
def test_extend_repeat(p=0.5, i=0):
    D('pluck:19', legato=0.2, midinote='[60,62,63]!!3', i=i) #note the repetition of values within the list
    again(test_extend_repeat, p=0.125, i=i+1)
```
The variant `!!` now makes sense. It allows you to repeat each individual value in a list `x` times.
#+end_src

*** TODO Function Library
*** TODO Conditions

Every function from the function library can be applied conditionnally. It means that every function can be applied based on a probability or based on a deterministic event (~e.g.~ being on beat 1).

*** Amphibian

This is probably the worst feature of *Sardine*. Do not use this until I fix it!

**** Amphibian variables

#+begin_src python
V.s = 60 # this is an amphibian variable

@swim
def fun():
    # Calling it and setting it to v.s + 5
    N(note='v.s = v.s + 5')
    if random() > 0.8:
        V.s = 60 # resetting so it doesn't go too high
    again(fun)
#+end_src

- There are variables called *amphibian variables*. They are both valid inside and outside the pattern notation.
- They are defined by ~v~ followed by a letter from the alphabet (uppercase or lowercase) : ~V.a~, ~V.A~, ~V.Z~, ~V.j~. These variables can be freely manipulated from the Python side or from the pattern side. *They are amphibian because they exist in the two languages*.

#+begin_src python
@swim
def fun(p=0.25):
    # Now having fun with it
    N(note='v.s = v.s + 5|2') # more fun
    if random() > 0.8:
        v.s = 50
    again(fun, p=0.25)
#+end_src

You can use them to leverage Python or the pattern syntax for what they do best: patterning or dealing with complex algorithmic transformations. Having them both available makes the pattern syntax even more expressive.

There is a finite list of actions you can perform on *amphibian variables*:
- using them (just by calling them)
- setting them: ~V.i = 5~ 
- resetting them to 0: ~V.i.reset~

**** Amphibian iterators

#+begin_src python
@swim
def amphi_iter(p=0.25):
    D('amencutup:[1:10]', i=i.i)
    if random() > 0.8:
        i.i = 0
    again(amphi_iter, p=0.25)
#+end_src

- Similarly to *amphibian variables*, there are *amphibian iterators*.
- They are defined by ~I~ followed by a letter from the alphabet: ~I.a~, ~I.A~, ~I.Z~, ~I.j~.
- They are supposed to help you dealing with multiple iterators.

#+begin_src python
@swim
def amphi_iter(p=0.25):
    D('amencutup:[1:10]', speed='1|2|i.i=0', i=i.i)
    again(amphi_iter, p=0.25)
#+end_src

These iterators can be reset or set on the pattern side!

#+begin_src python
@swim
def amphi_iter(p=0.25):
    if random() > 0.8:
        I.i = [1, 5]
    else:
        i.i = [1, 2]
    D('amencutup:[1:10]', speed='i.v|i.v=[1,2]', i=i.i)
    again(amphi_iter, p=0.25)
#+end_src

Similarly, you can define the step value between each value by providing a list of two numbers. This is valid on both sides.

**** The Function Library

**Sardine** pattern notation now comes with a function library. These are functions that should be used directly in the pattern notation to alter a list or a pattern you are working on. They can take basically any input but you will soon figure that some are more specialised than others. This is the part of the language that is the more subject to changes in upcoming versions. That's why I am only talking about it now, at the bottom of a fairly long page.

I want to explore how far you can go by introducing functional concepts to handle linear sequences. So far, only functions are available. The next step will be to introduce high-order functions and to build a small set of functional operations to pattern functions themselves. Only then will I be happy. I will base myself on that work to write a decent and complex function library.


***** Sinus, Cosinus, Tangent

- ~sin(x)~: *sinus of input* (single tokens or lists). Classic mathematical sinus function.
- ~cos(x)~: *cosinus of input* (single tokens or lists). Classic mathematical cosinus function.
- ~tan(x)~: *tangent of input* (single tokens or lists). Classic mathematical tangent function.

***** Scaling, measuring

- ~abs(x)~: Absolute value.
- ~max(x)~: Maximum value of list or token itself.
- ~min(x)~: Minimum value of list or token itself.
- ~mean(x)~: Mean of list or token itself.
- ~scale(z, x, y, x', y')~: Bring a value ~z~ from range ~x-y~ to range ~x'-y'~.
- ~clamp(x, y, z)~: Clamp function, limit a value `x` to the minimum ~y~ to the maximum ~z~.

***** Reversal, shuffling

- ~rev(x)~: Reverse a list.
- ~shuf(x)~: Shuffle a list.
- ~pal(x)~: palindrome of list.
- ~apal(x)~: palindrome of list without repetition of last value.

***** Musical functions

- ~disco(x)~: Disco function. Every pair note down an octave.
- ~bass(x)~: The first note of list is down an octave (not very useful).
- ~sopr(x)~: The last note of list is up an octave (not very useful).
- ~quant(x, y)~: The last note of list is up an octave (not very useful).

***** Voice Leading

These are two voice leading algorithms. These are only temporary until I figure out a better solution. They usually take a list of four note chords and arrange the voice to minimise movement. They work great but they are not the funniest thing you've ever seen. I'll work on them to make it better!

- ~voice(x)~: four-note voice leading algorithm. Naive implementation.
- ~dmitri(x)~: four-note voice leading algorithm. Algorithm inspired by Dmitri Tymoczko's work.

***** Probabilities 

- ~vanish(x, y)~ : Takes a list ~x~, output only ~y~% of values from it.

***** Booleans

- ~euclid(a, b, c, d)~: Euclidian rhythm function applied to patterns. Takes a pattern ~a~, a number of pulses ~b~, a number of steps ~c~ and a rotation amount ~d~. Outputs a pattern where the absence of a pulse is a silence and where pulses are values from the pattern.

- ~mask(x, y)~: Generalisation of the euclidian rhythm algorithm. Works for any pattern and list of booleans.

***** Insertion and rotation


- ~in(x, y)~:
- ~inPat(x, y)~:
- ~inrot(x, y)~:
- ~inprot(x, y)~:

*** Notes

#+begin_src python
@swim
def notes(p=0.5, i=0):
    D('pluck', midinote='C5,D5,E5,F5,G5', i=i)
    again(notes, p=0.5, i=i+1)
#+end_src

Notes are one of the primitives you can use in patterns. Notes will always be converted to some MIDI value (an integer value between ~0~ and ~127~). Notes will be converted to some MIDI value used by *SuperDirt*. If you need more precision, speak in hertzs (~freq=402.230239~).

The syntax to write notes is the following:
1) *[MANDATORY]* capital letter indicating the note name: ~C~, ~D~, ~E~, ~F~, ~G~, ~A~, ~B~. *Sardine* also supports the french notation system, so you can write ~Do, Ré, Mi, Fa, Sol, La, Si~ if it feels more natural to you.
2) *[FACULTATIVE]* flat or sharp: ~#~, ~b~.
3) *[FACULTATIVE]* octave number: ~0~..~9~.

If you are a robot, you might prefer to speak in numbers. Because notes are turned into numbers, you can everything on them just like if they were numbers. It can be particularly useful to generate custom voicings or weirdly shaped chords that you want to transpose and invert around: ~{([0,4,7,9,10,11]+50)^1}~.

**** Note qualifiers

#+begin_src python
@swim
def notes(p=0.5, i=0):
    D('pluck', midinote='C5@penta', i=i)
    again(notes, p=0.5, i=i+1)
#+end_src

You can use the ~@~ operator to *qualify* a note. This will turn a note into a collection of notes based your initial note.

~C@penta~ will summon a major pentatonic scale based on the middle C note: ~[60, 62, 64, 67, 69]~.

Be careful while using them as they will instantly turn a single token into a list of x tokens. You might want to filter part of your newly generated collection or you will just play.. a chord or a scale. You will have to learn techniques to get better at summoning the exact materials you want and some processing by using functions might be needed to get a better result. Writing your patterns by hand is also an option if you are able to think and write down precise harmonic / melodic materials. Check out functions like ~filt()~ or ~quant()~.

Take note that the following list is not always perfectly up to date. Moreover, it can be particularly tricky for you to remember how I named some of the structures:

#+begin_src python
qualifiers = {

    ##########
    # Chords #
    ##########

    "dim": [0, 3, 6, 12],
    "dim9": [0, 3, 6, 9, 14],
    "hdim7": [0, 3, 6, 10],
    "hdim9": [0, 3, 6, 10, 14],
    "hdimb9": [0, 3, 6, 10, 13],
    "dim7": [0, 3, 6, 9],
    "aug": [0, 4, 8, 12],
    "augMaj7": [0, 4, 8, 11],
    "aug7": [0, 4, 8, 10],
    "aug9": [0, 4, 10, 14],
    "maj": [0, 4, 7, 12],
    "maj7": [0, 4, 7, 11],
    "maj9": [0, 4, 11, 14],
    "minmaj7": [0, 3, 7, 11],
    "five": [0, 7, 12],
    "six": [0, 4, 7, 9],
    "seven": [0, 4, 7, 10],
    "nine": [0, 4, 10, 14],
    "b9": [0, 4, 10, 13],
    "mM9": [0, 3, 11, 14],
    "min": [0, 3, 7, 12],
    "min7": [0, 3, 7, 10],
    "min9": [0, 3, 10, 14],
    "sus4": [0, 5, 7, 12],
    "sus2": [0, 2, 7, 12],
    "b5": [0, 4, 6, 12],
    "mb5": [0, 3, 6, 12],

    ##########
    # Scales #
    ##########

    "major": [0, 2, 4, 5, 7, 9, 11],
    "minor": [0, 2, 3, 5, 7, 8, 10],
    "hminor": [0, 2, 3, 5, 7, 8, 11],
    "vminor": [0, 2, 3, 5, 7, 8, 10],
    "penta": [0, 2, 4, 7, 9],
    "acoustic": [0, 2, 4, 6, 7, 9, 10],
    "aeolian": [0, 2, 3, 5, 7, 8, 10],
    "algerian": [0, 2, 3, 6, 7, 9, 11, 12, 14, 15, 17],
    "superlocrian": [0, 1, 3, 4, 6, 8, 10],
    "augmented": [0, 3, 4, 7, 8, 11],
    "bebop": [0, 2, 4, 5, 7, 9, 10, 11],
    "blues": [0, 3, 5, 6, 7, 10],
    "chromatic": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    "dorian": [0, 2, 3, 5, 7, 9, 10],
    "doubleharmonic": [0, 1, 4, 5, 8, 11],
    "enigmatic": [0, 1, 4, 6, 8, 10, 11],
    "flamenco": [0, 1, 4, 5, 7, 8, 11],
    "gypsy": [0, 2, 3, 6, 7, 8, 10],
    "halfdim": [0, 2, 3, 5, 6, 8, 10],
    "harmmajor": [0, 2, 4, 5, 7, 8, 11],
    "harmminor": [0, 2, 3, 5, 7, 8, 11],
    "hirajoshi": [0, 4, 6, 7, 11],
    "hungarianminor": [0, 2, 3, 6, 7, 8, 11],
    "hungarianmajor": [0, 3, 4, 6, 7, 9, 10],
    "in": [0, 1, 5, 7, 8],
    "insen": [0, 1, 5, 7, 10],
    "ionian": [0, 2, 4, 5, 7, 9, 11],
    "istrian": [0, 1, 3, 4, 6, 7],
    "iwato": [0, 1, 5, 6, 10],
    "locrian": [0, 1, 3, 5, 6, 8, 10],
    "lydianaug": [0, 2, 4, 6, 8, 9, 11],
    "lydian": [0, 2, 4, 5, 7, 8, 9, 11],
    "majorlocrian": [0, 2, 4, 5, 6, 8, 10],
    "majorpenta": [0, 2, 4, 7, 9],
    "minorpenta": [0, 3, 5, 7, 10],
    "melominup": [0, 2, 3, 5, 7, 9, 11],
    "melomindown": [0, 2, 3, 5, 7, 8, 10],
    "mixolydian": [0, 2, 4, 5, 7, 9, 10],
    "neapolitan": [0, 1, 3, 5, 7, 8, 11],
    "octatonic": [0, 2, 3, 5, 6, 8, 9, 11],
    "octatonic2": [0, 1, 3, 4, 6, 7, 9, 10],
    "persian": [0, 1, 4, 5, 6, 8, 11],
    "phrygian": [0, 1, 4, 5, 7, 8, 10],
    "prometheus": [0, 2, 4, 6, 9, 10],
    "harmonics": [0, 3, 4, 5, 7, 9],
    "tritone": [0, 1, 4, 6, 7, 10],
    "ukrainian": [0, 2, 3, 6, 7, 9, 10],
    "whole": [0, 2, 4, 6, 8, 10],
    "yo": [0, 3, 5, 7, 10],
    "symetrical": [0, 1, 2, 6, 7, 10],
    "symetrical2": [0, 2, 3, 6, 8, 10],
    "messiaen1": [0, 2, 4, 6, 8, 10],
    "messiaen2": [0, 1, 3, 4, 6, 7, 9, 10],
    "messiaen3": [0, 2, 3, 4, 6, 7, 8, 10, 11],
    "messiaen4": [0, 1, 2, 4, 6, 7, 8, 11],
    "messiaen5": [0, 1, 5, 6, 7, 11],
    "messiaen6": [0, 2, 4, 5, 6, 8],
    "messiaen7": [0, 1, 2, 3, 5, 6, 7, 8, 9, 11],

    ##############
    # Structures #
    ##############

    "fourths": [0, 4, 10, 15, 20],
    "fifths": [0, 7, 14, 21, 28],
    "sixths": [0, 9, 17, 26, 35],
    "thirds": [0, 4, 8, 12],
    "octaves": [0, 12, 24, 36, 48],
}
#+end_src

**** Chord / Collection inversion

#+begin_src python
@swim
def notes(p=0.5, i=0):
    D('pluck', midinote='disco(C5@maj7^(0~4))', i=i)
    again(notes, p=0.5, i=i+1)
#+end_src

You can write chord/sequence inversions using the ~^~ syntax. It will accept any valid expression like ~^(1~5)~. You can also feed negative numbers for inverting a chord downwards. Chord inversions work on anything that is a list. Write custom chords!

**** Mathematics on notes

#+begin_src python
@swim
def notes(p=0.2, i=0):
    D('pluck', midinote='disco(braid(C5+ 10|20|30')), i=i)
    again(notes, p=0.2, i=i+1)
#+end_src python

You can use arithmetic operators on notes like if they were numbers. Think about it twice. There are many things that are numbers in *Sardine*. It might be fun.

*** Polyphony

**** Note polyphony

#+begin_src python
@swim
def poly(p=0.5, i=0):
    D('superpiano', cutoff=500, midinote='{D@maj9}, {G@maj7^0}, {D@maj9}, {G@dim7^1}', i=i, d=2, r=0.25)
    again(poly, p=P('0.5!4, 0.25!2', i), i=i+1)
#+end_src

- You can use the ~<~ and ~>~ delimiters to make parts of your pattern polyphonic.
  - There is *note polyphony*, aka when multiple notes are played together.
  - There is *parametric polyphonic*, aka when the same event is played multiple times with different parameters.

There a few rules to understand about polyphony and polyphonic messages. These rules can sound quite counter-intuitive if you think about polyphony just like you think of it on a musical score.

- The *size* of a polyphonic event -- meaning the number of messages sent for one occurence of an event -- is equal to the length of the largest polyphonic pattern you declared.

In the first example, we have a 4-5 note polyphony. Every polyphonic element from our pattern is a major 9 or 7 chord (_e.g_ ~[62, 66, 69, 73, 76]~). It means that if you have a polyphony of ~2~ somewhere and a polyphony of ~4~ elsewhere, your first polyphony will be distributed over the second one:

#+begin_quote
PATTERN:
1) [1,2,3,4]
2) [0,1]

RESULT:
1) [1,2,3,4]
2) [0,1,0,1]

   POLYPHONY
#+end_quote

To illustrate the preceding rule we just talked about, here is a truly bizarre example. Half of our chord is played by a tuned bassdrum, the other half by a piano. Even though this may look odd, this is fully compliant with how parameters are handled by *Sardine*.

#+begin_src python
@swim
def poly(p=0.5, i=0):
    D('<[bd, superpiano]>', cutoff=500, midinote='<D@maj9>, <G@maj7^0>, <D@maj9>, <G@dim7^1>', i=i, d=2, r=0.25)
    again(poly, p=Pat('0.5!4, 0.25!2', i), i=i+1)
#+end_src

We have two clear alternations, one between the ~superpiano~ and ~bd~ sound sets, the other between the four or five values that form our chords. It is then natural that half of our polyphony will be composed from a tuned bassdrum and the remaining half from a tuned piano. Once you get use to this novel way of thinking about polyphonic patterns, you will see that it opens up some space for interesting polyphonic interactions between sounds :)

It is currently not possible to limit the number of voices generated by an event. Be careful! It is quite easy to get overrun and to kill your computer playing with polyphony!

**** Parametric polyphony

#+begin_src python
@swim
def poly(p=0.5, i=0):
    D('drum:[1,6]', speed='{[1,rand]}, {[2,1.9]}', i=i, d=3)
    D('drum:2', cutoff='{[500:2000,500]*sin($%rand*80/40)*10}', i=i, d=2)
    D('bd', shape=0.5).out(i, 4)
    again(poly, p=0.5/2, i=i+1)
#+end_src

Everything can become polyphonic. Just wrap anything between ~{~ and ~}~ and you will return x events, one for each value. It allows you to be very creative with patterns.

** Ziffers
*** What is Ziffers?

[[https://github.com/amiika/ziffers][Ziffers]] is a number based patterning language for writing melodies and harmonies made by Miika Alonen. It is a powerful addition to the *Sardine* environment. This language is another flavor of patterning that you get just like this, boom! It is fully compatible with the *Sardine* pattern language and can be seen as a more specialised way to speak about common musical objects such as chords, notes, scales, bars, etc...

When I first created *Sardine*, I told myself that having something like *Ziffers* would be great. Now I have it thanks to Amiika :)

*** How to get Ziffers?

You can start *Sardine* without installing *Ziffers*. It will work. The *Ziffers* layer will not be activated and you will lose some functionalities!

*** Testing a Ziffers without looping

#+begin_src python
def _weird(instrument: str, ziffer: str, *args, **kwargs):
	"""Play a ziffer ZD pattern once"""
	zif = len(z(ziffer))
    pattern = lambda x: ZD(instrument, ziffer, *args, **kwargs, i=x)
	for i in range(zif):
    	dur = pattern(i)
		sleep(dur)

def weird(instrument: str, ziffer: str, *args, **kwargs):
	def test_function():
    	_weird(instrument, ziffer, *args, **kwargs)
	swim(test_function())
#+end_src

* Diving Deeper

This section is dedicated to a deeper-dive in the *Sardine* system for *users willing to learn more after reading the basics section*. Some knowledge of the syntax is required and the content of this section is written assuming that basic concepts are well understood.

** The FishBowl

The ~FishBowl~ is central to the *Sardine* system. As its name might suggest, it is what holds everything together. Properly speaking, it is the environment, the water, what makes the fishes swim :) The system is composed of some *hard dependencies* and many *soft dependencies*. *Hard dependencies* are important components like the *clock* or the *parser*. They are needed all the time. As such, you can't really remove them or everything would fall apart. *Soft dependencies* are the various *senders* or I/O components that you use to perform your music. Some of them are installed based on the content of your configuration, some can be created on the fly later on.

*** Hard dependencies

Core components cannot be removed from the ~FishBowl~. However, they can be swapped! It means that you can all of the sudden rip off the current *clock* and switch to a new one. The system might hiccup a bit but it will recover! To do so, note that you can use two important methods:
- ~bowl.swap_clock(clock: "BaseClock")~: swaps a clock. ~InternalClock()~ and ~LinkClock()~ are the two clocks currently implemented. The latter is used for synchronisation with every device capable of using the Ableton Link protocol.
- ~bowl.swap_parser(parser: "BaseParser")~: switch from a parser to another parser. There is no reason to do that because there is only one parser for the moment but it might be useful in the future.

*** Soft dependencies

This is where the fun begins. Pretty much everything in the *Sardine* system is a modular component that can be added or removed. Take a look at the ~run.py~ file if you want to see how the system is first initialized. By default, Sardine is proposing a small collection of *handlers* / *senders* that will allow you to send or receive *MIDI*, *OSC* or *SuperDirt* messages. Some other handlers are used for various internal functions that you might not care about. Take a look at the following code detailing how to add modular components:

#+begin_src python
# Adding a MIDI Out handler: sending MIDI notes
# control changes, program changes, etc...
midi = MidiHandler(port_name=str(config.midi)) # new instance of the Handler
bowl.add_handler(midi) # adding the handler to the FishBowl

# OSC Loop: internal component used for handling OSC messages
osc_loop = OSCLoop() # new instance of the Handler
bowl.add_handler(osc_loop)  # adding the handler to the FishBowl

# OSC Handler: dummy OSC handler
dummy_osc = OSCHandler(
    ip="127.0.0.1",
    port=12345,
    name="My OSC sender",
    ahead_amount=0.0,
    loop=osc_loop,
)

# Aliasing some methods from the handlers for later :)
M = midi.send
CC = midi.send_control_changes
PC = midi.send_program_changes
O = dummy_osc.send
#+end_src

Please take note of the ~bowl.add_handler method~. If you don't add your component to the ~FishBowl~, your component will inevitably crash! This is a fairly common mistake, especially if you are working in a hurry.


*** Messaging system

You might wonder what the ~FishBowl~ is actually doing behind the scene. Factually, it allows component to talk with each other by sharing a reference to the bowl. It means that any component can send a message to any other component. It also means that this same component can promptly react to any event dispatched through the ~FishBowl~. Internal messages are sent using the ~bowl.dispatch(message_type: str, *args)~ method. This is how messages such as ~bowl.('pause')~, ~bowl.('resume')~, ~bowl.('stop')~ and ~bowl.('play')~ are able to stop and resume everything when needed. They are messages dispatched to the ~FishBowl~ making everyone aware that a major event occured.





- Introduction to the concept.
- Hard dependencies
- Soft dependencies
- Messaging system.

** Nudging and time-alignment

Synchronising computers and audio softwares together is a rather difficult process. Some people have built careers trying to tackle this problem. You are very unlikely to get proper synchronisation out of the box. It's not because *Sardine* is incapable of doing it, it's just that the topic is very complex and that there are lot of different places where things can go wrong.

You already know about the *Ableton Link clock* that you can take advantage of to synchronise code or sound with your friends. It does 90% of the job. However, you might have to flick *Sardine* just a little to get it properly on time. Think of it as putting your finger on a vinyl disk while it is playing, just like a *DJ*.

- the ~midi.nudge~ attribute can help you to add a little /delay/ to your MIDI output: ~midi.nudge = 0.2~.
- the ~dirt.nudge~ attribute can help you to add a little /delay/ to your *SuperDirt* output: ~dirt.nudge = 0.3~.
  - it is actually recommanded to do so in order to give time to the system to react to instructions in time!

By preparing carefully before a session, you should be able to time-sync properly with your friends. The same also applies for recording! If you see ever see that *Sardine* is spitting out *MIDI* too soon or too late, you can even try an additional trick:

#+begin_src python
@swim(snap=0.5) # change this variable
def midifun():
    N('C5')
    again(midifun)
#+end_src

The ~snap~ argument will start the function before or after the first beat of the measure. A ~snap~ of 0.5 means that we want to start half a beat after the beginning of the bar. It can be a negative value too.

** Swimming functions oddities

*** Span argument in shorthand notation

There are a few extra arguments that you can use in your functions to control time even more. These arguments, respectively ~snap~ and ~span~ are time-strecthing or time-shifting patterns.

~span~ is meant to be used in conjunction with the shorthand syntax. The following patterns are identic. However, note that we are using ~span~. The first pattern is *1.5* times longer than the normal version, while the second one is 50% shorter than the normal version:
#+begin_src python
Pa >> d('voodoo, voodoo:4, linnhats:(rand*20)!4', span=1.5, p=0.5)
Pb >> d('voodoo, voodoo:4, linnhats:(rand*20)!4', span=0.5, p=0.5, speed=2)
#+end_src

~span~ is used to compress or to extend the duration of a pattern. Play carefully with these as they might result in weird results, especially if you are playing with complex rhythms! They will take all of your rhythmic values and will try to make them match a given *timespan*.

*** Snap argument for swimming functions

~snap~ is an additional argument that you can give to your ~@swim~ decorator. ~snap~ will time-shift the beginning of your pattern around the first beat of the measure:
- ~snap=1~ will start the pattern one beat after the beginning of the bar.
- ~snap=-0.5~ will start the pattern half a beat before the beginning of the next bar.

It is a useful function for shifting things around and for synchronising *Sardine* in some scenarios (recording, etc..).

** Sleeping and oversleeping

*Sardine* has a few tricks up its sleeves. *Swimming functions* can mimick [[https://sonic-pi.net/][Sonic Pi]] ~sleep()~ method because why not! The ~sleep()~ method from *Python* (and from most programming languages) is very imprecise. It doesn't offer any guarantee on the duration of the sleep. Your program will halt and come back after a certain time, but not always when you need it the most. It won't be really helpful to write precise rhythms like we do in music. *Sonic Pi*, long time ago, acknowledged that issue. They did something about it.

Following its model, *Sardine* is overriding the default ~sleep()~ method. You can use the new version just like the old one. The interface is very similar. However, it will allow you to write precise rhythms:

#+begin_src python
@swim
def super_sleeping(p=2, i=0):
    D('bd')
    sleep(1)
    D('cp')
    again(super_sleeping, p=2, i=i+1)
#+end_src

Let me explain what I just wrote:
- we are using a regular *swimming function*. The syntax is untouched.
- we use a central ~sleep(1)~ statement to make a pause in our pattern.
- we do the recursion after a period of ~two beats~.

There is something a bit un-intuitive about this. Strictly speaking, *the sleep method is not halting anything, it just report the events coming after it to some point in the future*. Read this twice!

It means that you can ~sleep()~ for some time but the function will not end if the recursion is coming much later. If will just defer the execution of what comes after the sleep and wait until the function is done looping:

#+begin_src python
clock.tempo = 100
@swim
def super_sleeping(p=2, i=0):
    D('bd')
    sleep(0.25)
    D('{cp, sn}')
    D('tabla')
    # ...
    # Nothing happens
    # ...
    again(super_sleeping, p=2, i=i+1)

#+end_src

There is a last thing to know about *sleeping*. You can *oversleep* the duration of you function. You can defer an event so hard that it will be deferred after the end of your *swimming function*:

#+begin_src python
clock.tempo = 100
@swim
def super_sleeping(p=2, i=0):
    D('cp', speed='[1:5,0.25]', i=i)
    sleep(0.75)
    D('linnhats', speed='[1:5,0.25]', i=i)
    again(super_sleeping, p=0.5, i=i+1)
#+end_src

In the example above, the ~linnhats~ sound is deferred to later, and later means on the *next loop* of our *swimming function*. Rhythms piling up on top of rhythms!

** Patterning everything

You can use the ~P()~ object to get a generic interface to *Sardine* patterns. This object can be used just anywhere you would like to see a pattern. It means that you can contaminate your *Python* functions or anything in your code with them. Under the hood, *Sardine* patterns are spitting out valid *Python* integers, floats or strings.

#+begin_src python
@swim
def free(p=0.5, i=0):
    print(P('1,2,3,4', i))
    again(free, p=0.5, i=i+1)
#+end_src

In the example above, we are just using a *swimming function* to print the result of a pattern in the interpreter window. Note that ~P()~ can take your basic iterator arguments as always (~P(pattern, iterator, divisor, rate)~.

We can do the same thing but using ~P()~ in a strategic location, replacing the static value for ~p~:

#+begin_src python
@swim
def free(p=0.5, i=0):
    D('cp')
    again(free, p=P('0.5!4, 0.25!2', i), i=i+1)
#+end_src

Using this technique, you can easily generate rhythms or pattern data that you send to any *Python* function. Using ~P()~ is a good way to study *Sardine* patterns. You can just take a few minutes and study some specific patterns if you have a hard time understanding them. That's what I do sometimes when developping them :)

** SuperCollider interaction

If you are using *SuperDirt*, you are also somehow using *SuperCollider*. Most of the time, you can't really know about this because the process handling *SuperCollider* is invisible. Everytime you start *Sardine*, you also incidentally start *SuperCollider* and *SuperDirt* with only one command. *SuperCollider* is a very exciting programming language and audio server. Since its first publication in 1996, this software has been adopted by many musicians worldwide because of its robustness and performance. Some people are *live coding* directly in *SuperCollider* because they can handle its verbosity and complexity. Most of the time, people are developing high-level layers to communicate more easily with *SuperCollider* just like we do.

To get a better understanding of the *Sardine* environment, think about it this way:
- *Sardine* is an independant layer on top of everything. It can do *MIDI* and *OSC* alone.
- *SuperDirt* is a specialised audio engine designed to make *live coding* on *SuperCollider* simpler.
- *SuperCollider* is the fundamental audio server that receives all the information and processes audio.

#+attr_html: :width 800px
file:usage.png


We can't do the audio synthesis or the scheduling directly in *Python*. The language is not fast enough to handle most of it and we must rely on external software to make things work smoothly. However, we can collaborate with it very easily.

It means that *Sardine* has a few commands that will help you get the most out of *SuperCollider*:
- ~SC.scope()~ will open an /oscilloscope/ pop-up window to visualise all your audio channels.
- ~SC.freqscope()~ will open a frequency analyzer pop-up window to visualise your audio output.
- ~SC.info()~ will open a general pop-up window that can help you with a few things:
  - monitoring your CPU usage.
  - monitoring the audio volume.
  - recording sound on the server.

It does not end here. You can also execute arbitrary code written in *SCLang*, *SuperCollider's* programming language. To do so, simply pass a string to the ~SC()~ object:

#+begin_src python
# Play a sinewave at 200hz
SC("a = play({SinOsc.ar(200) * 0.25});")

# Stop that sinewave
SC("s.freeAll;")
#+end_src

In the future, it is very likely that *Sardine* interaction with *SuperCollider* will be further refined. For the moment, it is only used as lightweight high-level layer on top of *SuperCollider* :)

** Writing presets

You can use *Python* dictionaries to write presets for your patterns. It is very simple to do so using the ~**~ operator that allows you to map dictionaries as keywords. See for yourself:
#+begin_src python
padcc = { 'timbre': {'control' : 18, 'chan': 2}, 'time': {'control' : 19, 'chan': 2},
        'metal': {'control' : 16, 'chan': 2}, 'fx': {'control' : 17, 'chan': 2}}
basscc = { 'timbre': {'control' : 18, 'chan': 0}, 'time': {'control' : 19, 'chan': 0},
        'cutoff': {'control' : 16, 'chan': 0}, 'fx': {'control' : 17, 'chan': 0}}
jupcc = { 'decay': {'control' : 81, 'chan': 1}, 'time': {'control' : 19, 'chan': 1},
        'cutoff': {'control' : 74, 'chan': 1}, 'resonance': {'control' : 71, 'chan': 1}}

@swim
def structure(p=0.5, i=0):
    N("C2,C3", chan=2, vel=120, i=i)
    N("G5,G4", chan=2, vel=120, i=i, r=0.25/4)
    N("[G6]-[0:12]", chan=2, vel=120, i=i, r=0.25/2)
    CC(**jupcc['cutoff'], value=100) # Here, I am injecting stuff
    CC(**jupcc['decay'], value=80)
    N("[G6]-[0:12]", chan=1, vel=120, i=i, r=0.25/2)
    again(structure, p=0.5, i=i+1)
#+end_src

* Audio engine Reference

*SuperDirt* documentation is rather scarce and most of it needs to be inferred by looking at the source code. However, the behavior of most parameters is well known -- usually from experience -- by live coders. Moreover, *SuperDirt* can be customised freely to add custom effects and synthesizers. I'm working hard on gathering information about each and every parameter I can find :) Some of them are rather arcane. They are probably not meant to be used directly. Keep in mind that not all of them are useful and that you will likely find better options by building your own environment.

** Sampler

Everytime you play an audio sample, this sampler will be invoked. It is pretty powerful and it is worth spending some time studying its behavior.

| Parameter  | Brief description                                           | Typical range | alias |
|------------+-------------------------------------------------------------+---------------+-------|
| amp        | Sound volume (linear scaling)                               | 0->x          |       |
| gain       | Sound volume (exponential scaling)                          | 0->1          |       |
| freq       | Pitch around given frequency                                | 0->x          |       |
| midinote   | Pitch around given MIDI note                                | 0-127         |       |
| note       | Pitch around given note                                     | ???           |       |
| octave     | Pitch up or down depending on octave number                 | 0->x          | oct   |
| sound      | Implicit (first argument of *D()*)                          |               |       |
| begin      | Start position of audio playback                            | 0->1          |       |
| end        | End position of audio playback                              | 0->1          |       |
| speed      | Sample playback, impacts pitch. Negative will play reverse  | -x->0->x      |       |
| accelerate | Rising sample playback speed (pitch glissando)              | -x->0->x      | accel |
| cps        | Implicit (cycles per second, inherited from Tidal)          |               |       |
| loop       | ???                                                         |               |       |
| delta      | Unused                                                      |               |       |
| cut        | Cut other sounds playing on same orbit, start playing       | 0 or 1        |       |
| legato     | Play sample for the given duration (without cutting others) | 0->x          | leg   |
| pan        | Pan sound from left to right speaker (by default)           | 0->1          |       |
| orbit      | Play sound/synth on the given audio effect bus (0 - 11)     | 0->11         |       |
| latency    | Add a latency to audio playback (in seconds)                | 0->x          |       |
| lag        | Similar to latency/offset                                   | 0->x          |       |
| offset     | Similar to latency/lag                                      | 0->x          |       |

** Effects

*** Reverb

This is a pretty basic metallic sounding reverb. Not very usable but still.

| Parameter | Brief description                       | Typical range |
|-----------+-----------------------------------------+---------------|
| room      | Size of the room                        | 0->x          |
| size      | Size of the reverb - keep below 1 (inf) | 0->1          |
| dry       | Dry/Wet balance                         | 0->1          |

#+begin_src python
@swim
def test_fx(p=0.25):
    D('hh', amp=1, room='sin($.S)', dry=0.1, size='sin($)')
    again(test_fx, p=0.25)

#+end_src

*** Delay

The delay effect is initially built for *Tidal*, which is based on a cyclical time representation. However, it has been pre-configured here to work properly with *Sardine*. Be careful with the _feedback_ if you don't want to see things explode!


| Parameter     | Brief description                       | Typical range |
|---------------+-----------------------------------------+---------------|
| delay         | Wet / Dry                               | 0->1          |
| delaytime     | Delay time                              | 0->x          |
| delayfeedback | Amount of reinjection of the dry signal | 0->.99        |

#+begin_src python
@swim
def test_fx(p=0.25):
    D('hh',
            speep='1|2|4',
            delay=1/2, delaytime=1/(2/3),
            delayfeedback='0.5+(rand/4)',
            amp=1)
    again(test_fx, p=0.25)
#+end_src

*** Phaser

| Parameter   | Brief description | Typical range |
|-------------+-------------------+---------------|
| phaserrate  | Speed of phaser   | 0->x          |
| phaserdepth | Depth of phaser   | 0->x          |

#+begin_src python
@swim
def test_fx(p=0.25):
    D('jvbass',
            midinote='C|Eb|G|Bb',
            phaserrate='1~10',
            phaserdepth='sin($*2)', amp=1)
    again(test_fx, p=0.5)
#+end_src

*** Leslie

This is a simple emulation of a Leslie rotating speaker typically used in music for treating organ sounds, voices, and to add an eary tint to everything that goes through it. This is basically a way to play creatively with doppler effects.

| Parameter | Brief description               | Typical range |
|-----------+---------------------------------+---------------|
| Leslie    | Dry / wet                       | 0->1          |
| lrate     | Rate                            | 0->x          |
| lsize     | Wooden cabinet size (in meters) | 0->x          |
#+begin_src python
@swim
def test_fx(p=0.25):
    D('jvbass', amp=1, leslie=0.9,
            lrate=0.1, lsize='0.1+rand*2')
    again(test_fx, p=0.25)
#+end_src

*** Tremolo

A simple tremolo effect.

| Parameter    | Brief description | Typical range |
|--------------+-------------------+---------------|
| tremolorate  | Tremolo speed     | 0->x          |
| tremolodepth | Depth of tremolo  | 0->x          |

#+begin_src python
@swim
def test_fx(p=0.25, i=0):
    D('amencutup:[1:20]',
            tremolorate='16|32',
            tremolodepth='[0.0~1.0,0.25]', i=i)
    again(test_fx, p=0.5, i=i+1)
#+end_src

*** Granular weird

This is a weird granular effect probably intended to serve as a building block for some other effect but you can use it as is nonetheless. It will slice your audio sample into tiny fragments of it while applying some amount of pitch-shifting on every sample.


| Parameter | Brief description      | Typical range |
|-----------+------------------------+---------------|
| psrate    | Pitch-shift rate       | 0->x          |
| psdisp    | Pitch-shift dispersion | 0->x          |

#+begin_src python
@swim
def test_fx(p=0.25, i=0):
    D('amencutup:[1:20]',
            psrate='2',
            psdisp='[0:1,0.5]',
            i=i)
    again(test_fx, p=0.5, i=i+1)
#+end_src

** Filtering

| Parameter | Brief description                            | Typical range  | alias |
|-----------+----------------------------------------------+----------------+-------|
| cutoff    | Low-pass filter cutoff frequency (in hertz)  | 0->x us. >2Khz | lpf   |
| hcutoff   | High-pass filter cutoff frequency (in hertz) | 0->x us. <1Khz | hpf   |
| bandf     | Bandpass filter cutoff frequency (in hertz)  | 0->x           | bpf   |
| resonance | Filter resonance                             | 0->.99         | res   |
| bandqf    | Bandpass resonance                           | 0->.99         | ???   |

#+begin_src python
@swim
def test_fx(p=0.25):
    D('jvbass',
            midinote='C|C|Eb|G|Bb',
            cutoff='rand*7000', resonance='rand/2', amp=1)
    again(test_fx, p=0.5)
#+end_src

** Distortion

Nobody knows why but *SuperDirt* is full of distortion effects. Hope you like it.

*** Squiz

Will distort your signal, combination of multiple effects put together. It works better if you input multiples of two as parameters.

| Parameter | Brief description | Typical range |
|-----------+-------------------+---------------|
| squiz     | amount            | 0.2->x        |


#+begin_src python
@swim
def test_fx(p=0.25):
    D('tabla:rand*200', cut=1,
            squiz='0|2|4|8',
            midinote='C|F|Bb|E5b', amp=1)
    again(test_fx, p=0.5)
#+end_src

*** Triode

Another type of distortion. Emulating a triode distortion unit.

| Parameter | Brief description | Typical range |
|-----------+-------------------+---------------|
| triode    | Distortion amount | 0->x          |

#+begin_src python
@swim
def test_fx(p=0.25):
    D('tabla:rand*200', cut=1,
            triode='r', # comment me
            midinote='C|F|Bb|E5b', amp=1)
    again(test_fx, p=0.5)
#+end_src

*** Distort

Heavy distortion that will/can wildly change the spectrum of your sound.

| Parameter | Brief description | Typical range |
|-----------+-------------------+---------------|
| distort   | Distortion amount | 0->x          |

#+begin_src python
@swim
def test_fx(p=0.25):
    D('sd:rand*200', cut=1,
            distort='0|0.5',
            midinote='C|G', amp=1)
    again(test_fx, p=0.5)
#+end_src

*** Shaping

| Parameter | Brief description    | Typical range |
|-----------+----------------------+---------------|
| shape     | Amplification amount | 0->x          |

#+begin_src python
@swim
def test_fx(p=0.25, i=0):
    D('amencutup:[1:20]', shape='[0:1,0.1]', i=i)
    again(test_fx, p=0.5, i=i+1)
#+end_src

*** Crush

Crush will.. crush your sound. You get it!

| Parameter | Brief description | Typical range |
|-----------+-------------------+---------------|
| crush     | Crushing Factor   | 0->x          |

#+begin_src python
@swim
def test_fx(p=0.25, i=0):
    D('bd, sn, hh, sn', crush=4, i=i)
    again(test_fx, p=0.5, i=i+1)
#+end_src

** Hidden Gems

There are hidden gems in the *SuperDirt* engine. Note that you can also customize it with your own effects. This documentation, thus, is only covering the tip of the iceberg.

* About
** Why Sardine?

*Sardine* is a side-project that initially started as an attempt to demonstrate some live coding techniques for my PhD dissertation in musicology at the University of Saint-Etienne / Paris 8 University. *Sardine* is trying to encompass various programming paradigms and gestures used by live coders: declarative and imperative programming, DSLs for pattern processing, clock synchronisation with other tools, etc. Initially, everything was working according to the plan. And then, the tool started mutating from all sides and it gained its own identity. It is now a new live coding library in need of support :)

Obviously, I'm also trying to develop *Sardine* for my friends and I. Programming new tools is fun and rewarding! I am playing music with the [[https://cookie.paris/][Cookie Collective]] in Paris and with the [[https://discord.gg/arRBSfdXV3][Creative Code Lyon]] community. I am also very much attached to the values of the [[https://toplap.org/][TOPLAP]] collective once was contributing to the documentation of [[https://tidalcycles.org/][TidalCycles]]. Live coding is a fun musical practice, that I nowadays consider very much alike playing a different kind of musical instrument!

I learned how to program by live coding music! The next logical step I could see in my learning was to code my own tool so I can share it with others and make people see the incredibly fruitful intersection between code and music. Since I started live coding a few years ago, I always wished to develop my own tool just to see how things work! I am now finding the need to write documentation for my own work.. heh...

** Contributions

Contributions of any sort are really welcome! I am not a professional developer and am just trying to do my best with *Sardine*! I might code things in a weird or unefficient way. Everything takes place on the main [[https://github.com/Bubobubobubobubo/sardine][GitHub]] repo. Don't be afraid of proposing drastic changes or to take a different direction from mine! I'm here for the fun!

** About this website

This website is maintained using [[https://orgmode.org/][Org Mode]], a wonderful tool for documentation. The whole documentation is a monolithic ~.org~ file that you can find (and edit!) on GitHub. The styling is plain CSS, using a customized [[https://github.com/fniessen/org-html-themes][gray]] theme.

I am using some very nice custom fonts:
- [[http://velvetyne.fr/fonts/compagnon/][Compagnon Font]], used in headers.
- [[https://tug.org/FontCatalogue/latinmodernroman/][Latin Modern Roman]], used for text.
- [[https://larsenwork.com/monoid/][Monoid]], used for code.

Some help was provided by Yassin Siouda and Raphaël Bastide for CSS design.

** Sardine Strategies

The *Oblique Strategies* are a set of cards once written by Brian Eno and Peter Schmidt. These are cards that you should take a look at when you are feeling down when working in the studio. They are pretty famous and were used by many musicians worldwide. To my knowledge, nobody ever tried to write a _live coding flavour_ of these cards... until now. Here they are, have fun:

#+begin_src
1) Computers are good at maths.
2) Do what musicians can't do. Elaborate.
3) This is not the function you are looking for.
4) If my grandmother had wheels, she would have been a bike.
5) Your code is totally fine. It just doesn't sound good.
6) Record, Listen, Reuse the recording!
7) What is truly yours?
8) Complex things are simple if you cut them up.
9) Simple things are infinitely difficult if you look at them closely.
10) What is a computer keyboard?
11) Text is for speaking.
12) That one thing that deserves to be live coded
13) What would you do if you had to apy each letter you type
14) Write the most complex thing you can think of.
15) Computers love files. Use lots of files.
16) Will you ever be able to sound human?
17) Cybernetic hour. Add more to the system.
18) Why did you learn how to program?
19) Beautiful things are scarce. Think of colors.
20) Ugly things are plentiful, but they can be pretty if you try.
21) Computer musicians have invented DAWs. Why?
22) Perspective and layers.
23) What is time. Does your computer think the same?.
24) Digital sound is a material. We want to hear it.
25) The triangle of your orchestra.
26) Solos are great.
27) What's the worst thing about a computer? Can you get your revenge?
28) Beep beep, this is internet.
29) There are musicians who play their instruments well.
30) You are not yourself anymore. You are free!.
31) Computers are stubborn and you are not!
32) The beginning and the end. See them.
33) Bigger font, bigger ideas.
34) Ping-pong with your friend.
35) What is computer folklore?
36) Tappity tap, you write in rhythm.
37) Computers are not helping you at all.
38) Get political!
39) Do it yourself, fail hard doing it.
40) Where does the sound comes from?
41) Music is all about expressiveness and mannerisms.
42) Will animals like it?
43) Pretend that you can play jazz music.
44) Nobody is watching, people don't get it.
45) Remember that your favorite music is probably made with a DAW.
46) You often don't play the music you want, same thing goes for code.
47) Live code is temporary, what are you going to do after?
48) Expect bugs, not joy!
49) Everything you do has been done before.
50) And again, and again, and again, and again!
51) BOOM, pshhht, plip plop, and all over again.
52) What is the ABC of what you do?
53) Remember that everything is in your own mind.
54) Doing things alone is ok. Doing it again with someone, funnier!
55) Show us what you are hiding behind your back.
56) Computer code, more like Pomputer pode.
57) "In the end you get tired of this old world".
58) Snacks, forbidden snacks. Code, forbidden code.
59) Hit it with a stick, now blow inside it.
60) Tools are making us. Change your tools, change yourself.
61) Tout le monde ne parle pas anglais, vous saviez ?
62) Linear or cyclic? Is that everything there is?
63) You will always be a cliché for someone else.
64) Yeah, TOPLAP. But now think of something else.
65) Borrow code that you don't understand at all.
66) Computer keyboard is lava!
67) I got shoes, you got shoes. All o' God's chillun got shoes.
68) Is there some sort of progress?
69) Just clicking around is probably fine!
70) Read about computers: LISP, FORTH, and the nerdy stuff.
71) Water is everywhere.
72) It's not because you code that you do computer music. Kraftwerk does it better.
73) Everybody is going to love that gimmick!
74) Stay fresh!
75) If your computer could sing, what would the lyrics look like?
76) Why do modular synthesizers still exist?
77) We have more and more computers but people are more and more alone.
78) 100 years of electric guitar. 100 years of computer music?
79) Design your music/code to be universally appreciated.
80) Clever yes, but is it interesting?
81) You have a very big brush and big boots.
82) The sound is all around. No need to spatialize if you listen in the right place.
83) Think of all the silly code that runs important things.
84) Nobody sees you live coding if you don't show it. Is it really necessary to see what you do?
85) Welcome to my TED Talk, live coding is not going to change the world.
86) We have to stop making new music. We already know how it works.
87) Yeah, well, go on.
88) Three rules. If you lose, you start again.
89) Write for one minute, delete for thirty seconds.
90) Beat around the bush.
91) Why don't you code everything yourself?
92) Oh no, midnight already! Your code has become a score.
93) Perhaps you should consider stopping taking advice.
94) AZERTY, QWERTY, DVORAK, does it matter?
95) Everything fits on one line, the rest is superfluous.
96) Think about others.
97) If you're looking for something complicated, maybe it's for the good. Some thoughts don't have words.. yet.
98) Make a list, put everything down on paper.
99) Planes don't fly without buttons and knobs. Wings, ok? But what about the other stuff?
100) It always works better when you press twice.
101) The Greeks already had computers. They were better at philosophy and poetry.
102) If you feel sad, clean your computer. Look around.
103) Why do we feel compelled to type?
104) Food and beverage pairing, live coding version.
105) The things kids like, excessive and brutal.
106) Go to your neighbor, tell him you live code. So what?
107) Live code something that shouldn't be.
108) Essay on the border between the virtual and the actual.
109) We do this mostly because it's fun.
110) At least the ugly things work.
111) If it crashes, that's your fault.
112) Does the computer really let you scream?
113) Find your motto: mine is: "Sail on sight".
114) I don't work with computers.
115) Frankly, there are programs that deserve not to be live.
116) If it works, maybe we should break it?
117) No one cares about the code. We want records, words, thoughts.
118) The device you use is not a computer.
119) To do is to understand. Well, not always.
120) Try to find a profound aphorism about live coding too. It's not easy, is it?
121) 127 cards, 127 MIDI notes. Is MIDI 2.0 killing the mood?
122) Why does language matter?
123) Be non binary.
124) Is there anything really divisive? Why is that?
125) Pianists play chords on their keyboards. You can do too, but what does it mean?
126) Does your computer seem to like anything in particular? Think about its well-being.
127) Who could have coded live but never did?
#+end_src
