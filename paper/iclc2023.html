<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Sardine: a Modular Python Live Coding Environment</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="css/iclc.css" />
  
  
  
</head>
<body>
<div id="header">
<h1 class="title">Sardine: a Modular Python Live Coding Environment</h1>
<ul id="authorlist">
<li>true</li>
</ul>
</div>

<h2 class="abstract">Abstract</h2>
<div id="abstract">
<p><strong>Sardine</strong> is a live coding environment and library for
Python 3.10+ focusing on the modularity and extensibility of its base
components (clocks, parser, <em>handlers</em>). Sardine has been
designed to be easily integrated with existing <em>live-coding</em>
environments as both a tool for experimentation and demonstration of
various live coding techniques : temporal recursion, patterning,
integration in various hardware and software setups. Although the tool
is still in active early development, it has already been used in
multiple public performances and algoraves. This paper is dedicated to
the introduction of the <strong>Sardine</strong> system and the
explanation of the main guidelines currently followed by contributors to
the project. It will also present the preliminary results of our work
through practical realizations that served as experimental validations
during the early stages of development. Sardine already supports MIDI
IN/Out, OSC IN/Out and <em>SuperCollider</em>/<em>SuperDirt</em> one-way
communication through OSC.</p>
</div>

<figure>
<img src="images/sardine_intro_picture.png"
alt="Sardine first algorave in Lorient (France), 2022, October 13th. Photography: Guillaume Kerjean." />
<figcaption aria-hidden="true"><em>Sardine first algorave in Lorient
(France), 2022, October 13th. Photography: Guillaume
Kerjean.</em></figcaption>
</figure>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction</h1>
<p>Sardine is a live coding library based on Python 3.10+ focusing on
modularity and extensibility of its base components. Despite still being
in early alpha stage, Sardine is extensively documented on a <a
href="https://sardine.raphaelforment.fr">dedicated website</a> providing
installation guides, tutorials and media examples. Sardine is providing
three main features linked together by the <code>FishBowl</code>, an
environment handling synchronisation and communication between them:</p>
<ul>
<li><p><em>a scheduling system</em> based on asynchronous and recursive
function calls inspired by the concept of temporal recursion <span
class="citation" data-cites="SorensenTemporal">(Sorensen 2013)</span>.
Calls can be scheduled in musical time either on an
<code>InternalClock</code> or a <code>LinkClock</code> based on the Link
Protocol <span class="citation" data-cites="goltz2018ableton">(Goltz
2018)</span>.</p></li>
<li><p><em>a small and tidy number based pattern programming
language</em> with support for basic generative and musical syntax (MIDI
notes, polyphony, etc…), time-based patterns (<em>clock</em> and
<em>absolute</em> time), handling of symbolic names.</p></li>
<li><p><em>a modular handlers</em> system allowing the creation and/or
removal of various I/O (<em>OSC</em>, <em>MIDI</em>) or base
components.</p></li>
</ul>
<p>Sardine, by design, is in the direct lineage of previously released
Python based libraries such as <a href="https://foxdot.org">FoxDot</a>
<span class="citation" data-cites="kirkbride2016foxdot">(Kirkbride
2016)</span>, <a href="https://github.com/ideoforms/isobar">Isobar</a>
<span class="citation" data-cites="isobar">(Jones, n.d.)</span> or the
very recent <a
href="https://github.com/tidalcycles/vortex">TidalVortex</a> <span
class="citation" data-cites="vortex">(McLean et al. 2022)</span>.
Initially conceived as a demonstration tool, Sardine partially emulates
some selected features from the previously mentioned libraries or from
the dominant live-coding <em>dialects</em> such as the <a
href="https://tidalcycles.org">TidalCycles</a> <span class="citation"
data-cites="mclean2014making">(McLean 2014)</span> rhythmical
mininotation or the <a href="https://sonic-pi.net/">Sonic Pi</a> <span
class="citation" data-cites="aaron2016sonic">(Aaron 2016)</span>
imperative writing syntax. Sardine is designed as a general
<em>agnostic</em> framework for approaching live coding using Python.
Thus, the library is aiming to support different writing paradigms and
different approaches to live performance based on the manipulation of
source code. The reliance on regular Python asynchronous functions for
scheduling and music writing has for consequence that Sardine is
particulary suited to let each developer-musician follow its own
personal coding style, ensuring a blank slate for experimentation.
Furthermore, Sardine design has been strongly influenced by Andrew Mc
Pherson’s and Koray Tahiroğlu concerns about the <em>idiomatic
patterns</em> <span class="citation"
data-cites="mcpherson2020idiomatic">(McPherson and Tahıroğlu
2020)</span> of usage enforced by computer music softwares, pushing
users to repeat and strictly follow prefered patterns of usage.</p>
<p>The version hereby presented, labelled as <code>0.2.0</code>, is
offering a first-look into the complete intended design for the library.
It features a near complete rewrite over the <code>0.1.0</code> version
previously used by members of the french live coding scene and by the
first global Sardine users. It features two different clock
implementations, multiple handlers for <em>I/O</em>
(<strong>MIDI</strong>, <strong>OSC</strong>,
<strong>SuperDirt</strong>), a robust asynchronous temporal recursive
scheduling system and a reimagining of the <em>‘Player’</em> system
previously introduced by FoxDot<span class="citation"
data-cites="kirkbride2016foxdot">(Kirkbride 2016)</span>. Sardine
originality lies in its temporal model, strongly anchored in Python’s
default mechanisms for asynchronous programming. The use of the
<code>asyncio</code> library is offering a variant to other threaded
musical clocks featured by past Python based live coding libraries.
Sardine also presents itself as an <em>agnostic</em> and minimal tool
modular enough to be integrated into any live-coder tooling and setup,
capable of handling any Python-based scheduling duties. As such, Sardine
has been already successfully integrated in various laptop-based
performance setups involving audio, video and hardware components.</p>
<p>On the technical side, Sardine has been developed entirely using the
Python programming language, with few libraries depending on C++ code
through bindings to external libraries. Despite the known short-comings
of Python for interpreted conversational real time programming
(incomplete support of dynamic programming, slowness relative to other
interpreted languages), we do believe that this language is suitable for
the implementation of a live coding library. The large collection of
available librairies and modules and the popularity of the language
ensures the affordance of good tooling and rich customization and
Sardine integration options into different text editors, running
environments, etc… Sardine already takes advantage of a thorough
ecosystem of libraries focused on data <em>input</em>/<em>output</em>,
network communication and text manipulation. Moreover, thanks to its
lightweight and clear syntax, Python can be read by programmers coming
from different domains with a minimal adaptation time, making it a
convenient platform for collaboration and experimentation over the
implementation of bespoke features needed by performers.</p>
<p>In the present article, we will introduce the
<strong>Sardine</strong> system by detailing its goals (1) and base
implementation (2). By doing so, we hope to highlight the basic
principles of its inner working while providing some context on the
current direction taken by the project and by its users (3).</p>
<h1 data-number="2"
id="methodology-and-objectives-a-framework-for-exploring-live-coding-in-python"><span
class="header-section-number">2</span> Methodology and objectives: a
framework for exploring live-coding in Python</h1>
<p>Sardine is born out of a curiosity for the implementation of
similarly featured Python-based live-coding libraries such as <a
href="https://foxdot.org">FoxDot</a>, <a
href="https://github.com/ideoforms/isobar">Isobar</a> or the very recent
<a href="https://github.com/tidalcycles/vortex">TidalVortex</a> <span
class="citation" data-cites="vortex">(McLean et al. 2022)</span>. At it
inception, the Sardine project was thought as an attempt to provide a
functional but barebones live coding library for demonstration purposes
in a dissertation manuscript; a library capable enough for showing the
impact of design and implementation choices on the possibilities of
musical expression and on the expressiveness offered by a live coding
environment. Therefore, a particular attention has been given to
reproducing or <em>at least</em> paving the way for the reproduction of
different coding styles and representation of timed musical information.
The base design has quickly evolved after the first initial public
tests. It has been decided to aim for an increased modularity of the
system in order to support and maximise the <em>input</em> and
<em>output</em> options offered by Sardine. This has allowed for the
quick integration of the tool with other neighbor interfaces and live
coding environments.</p>
<p>The development of Sardine began initially in a period of frantic
collaborations and joint performances with the parisian <em>Cookie
Collective</em> <span class="citation"
data-cites="cookiewebsite">(Collective 2016)</span> and the Digital
Audio Community from Lyon (<em>th4</em>, <em>ralt144MI</em>, etc..).
Stemming from the <em>demoscene</em> and shader-coding scene, the
<em>Cookie</em> is known for its complex multimedia performances, each
member relying on bespoke hybrid audio-visual setups ranging from low
end computing devices to complex synthesizers and circuit-bended video
mixers. It is also known for working in an improvised manner,
customising its setup for each venue depending on the audience needs and
expectations. The need to adapt and customize the live coding interfaces
already in use to the needs of each performance and each artist gave
rise to the idea of creating a modular interface that could be used and
mastered by all the members of the collective, while allowing for
jam-ready synchronisation with other musicians and live-coders. The
splitting of Foxdot’s development into several competing branches
reinforced the need for a customizable and easily editable Python
interface by the community. Due to the open-ended nature of the
development process, Sardine has been gradually shifting towards its
current modular architecture, allowing each performer to refine the
nature of the <em>inputs</em> and <em>outputs</em> controllable by the
system, from simple MIDI note output to more convoluted custom Sysex and
OSC message support. The invaluable help and expertise from John Phan
has allowed for a complete deep rewrite of every base mechanism. The
completion of the program rewrite marks the beginning of a new stage in
the development process, focused on introducing new features (new audio
backends? better OSC support?) and improving existing ones (parser?).
This process is managed in an <em>ad-hoc</em> manner, by encouraging
users to propose ideas and contribute to an extensively documented
codebase.</p>
<h1 data-number="3" id="sardine-implementation"><span
class="header-section-number">3</span> Sardine implementation</h1>
<img src="images/usage.png" alt="Sardine usage workflow" /><br />

<p>Sardine is implemented and distributed as two complementary Python
modules: <code>sardine</code> and <code>fishery</code>. They work hand
in hand in a layered and coordinated fashion. <code>fishery</code>
provides amendments to the default Python asynchronous REPL<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> and constitutes the entry point for
the Sardine system, accessible by typing <code>python -m fishery</code>
or simply <code>fishery</code> right after install. <code>fishery</code>
is nothing more but a slightly modified version of the base Python
asynchronous REPL. Importing it also imports <code>sardine</code> and
will <em>de facto</em> starting a new playing session. As an helper for
new users, a terminal based configuration client
(<code>sardine-config</code>) is also provided and can be used to setup
various options before starting <code>fishery</code>. Configuration
files are stored in a default standard location depending on the OS
currently in use (<code>e.g.</code> <code>.local/share</code> on UNIX
systems). Configuration files include a general JSON configuration file,
a <code>.py</code> file usable to load user-specifc Python code at the
start of each session and files needed to properly configure a
<em>SuperCollider</em>/<em>SuperDirt</em> session. This architecture,
despite its initial complexity, is being used to make Sardine more
accessible to novice users who may not be familiar with using the
command line and Python development tools. Files relative to Sardine
will be kept in a single configuration folder. Note that modularity of
the system is greatly encouraged, with many <em>input</em> and
<em>output</em> components being disabled by default. This makes the
installation of any audio-backend like SuperCollider entirely optional,
being considered more as a target than a dependency.</p>
<p>Thanks to the generally great IDE support for Python,
<em>Sardine</em> is not shipping with its own text-editor or dedicated
text editor plugin. Sardine has been tested with third-party code
writing tools such as <em>Atom</em>, <em>VSCode</em>, <em>Emacs</em>,
<em>Vim/Neovim</em> or even <em>Jupyter Notebooks</em>. Each one of
these text editors generally support the spawning of an asynchronous
REPL and the piping of code from a text buffer to a running interpreter.
The setup process for each one of these interfaces generally relies on
the installation of a simple general-purpose Python plugin<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.
This state of fact has lead us to consider the Python interpreter as a
code receiver and monitoring tool mainly used to mirror useful
information to the user, such as the state of the SuperCollider
sub-process, of the event loop and <em>runners</em>, etc… Every other
operation is directly handled by calls internal to a Sardine
session.</p>
<p>Reliance on any audio backend can / will require the boot of another
application. For the time being, only <em>SuperCollider</em> and
<em>SuperDirt</em> are natively supported by their own Sardine
components. Even though the installation of these backends is still
necessary for users willing to use them, integration is done in such a
way that there is no need – later on – to actively take care and monitor
manually any of these dependencies. A basic API to
<em>SuperCollider</em> and <em>SuperDirt</em> is offered through the
<code>SC.send()</code> function, allowing to run arbitrary
<code>sclang</code> code in the subprocess session. The addition of more
automatically-managed audio-backend <em>subprocesses</em> is actively
planned and will be explored in the coming months (deeper
<em>SuperCollider</em> integration, <em>CSound</em> backend, etc…).
Clever combination of Sardine provided functions is already allowing
some amount of customization for patterning hardware and software
synthesizers through MIDI or OSC.</p>
<p>Being packaged as a regular Python module, Sardine makes use of the
<code>pyproject.toml</code> module configuration and packaging format
defined by PEP 660. This has for advantages that no third party tool is
currently required to install Sardine other than a base
<em>complete</em> installation of a modern (3.10+) Python runtime.
However, one must note that the package is not, at the time of writing,
fully installable in the binary <em>‘wheels’</em> format generally
favored by Python developers and users alike. This has to do with the
problematic packaging of some C++ external dependencies used by Sardine
to process various I/O processes. Future versions will hopefully be
tighly packaged and served through the central <em>Pipy</em> package
distribution system. Most users will still have to install part of the
compilation toolchain (<code>CMake</code> and any compatible C++
compiler) to be able to manually compile these dependencies for the
target system.</p>
<h2 data-number="3.1" id="event-loop-and-scheduling-system"><span
class="header-section-number">3.1</span> Event loop and scheduling
System</h2>
<h3 data-number="3.1.1" id="event-loop"><span
class="header-section-number">3.1.1</span> Event loop</h3>
<img src="images/event_loop.png" style="width:100.0%"
alt="Event Loop Diagram" />`
<p>Sardine is making use of the asynchronous programming features
offered by Python. More specifically, Sardine takes advantage of the not
well known <code>asyncio</code> REPL prototype introduced by Python
3.8 <span class="citation" data-cites="asynciorepl">(Selivanov,
n.d.)</span>. The UVLoop <span class="citation"
data-cites="uvloop">(Stack) 2016)</span> drop-in replacement event loop
is also being used in order to speed up the scheduling of asynchronous
calls. Several hot-patches to the asynchronous loop have been introduced
by John Phan (<em>thegamecracks</em>) in order to make its behaviour
consistent on every major OS platform. Sardine is laid out as a series
of abstractions built on the base loop, making it aware of tempo and
timing. Sardine <em>clock</em> (either the <code>internal</code> or
<code>link</code>) clock automatically starts whenever the system is
imported but pure asynchronous calls can still be handled even if the
clock is being stopped.</p>
<p>The consistency of the asynchronous clocks is being covered by tests
(in the <code>tests/</code> folder) and has been checked to be
<em>on-par</em> with the alternatives offered by similar more widely
used threaded clocks. Development of such a feature has proven to be a
difficult technical challenge due to the specificity of the task and of
the relatively obscure inner workings of internal OS’s schedulers.
Threaded components are still used for various <em>I/O</em> operations
in order to lighten the load of the event loop and to alleviate the
temporal cost of message processing. Note that many <em>Sardine</em>
components are entirely optional and can be activated on demand by the
user. Only the <code>clock</code>, <code>AsyncRunners</code> and
<code>SleepHandler</code> constitute the core abstractions needed over
Python <code>asyncio</code> loop. Basing the custom event loop on top of
the Python asynchronous interpreter is allowing for the evaluation of
any top-level asynchronous <code>await</code> instructions that would be
forbidden by the main interpreter. It must be noted that Python
<code>asyncio</code> features have their own logic for every major OS
and that some differences can be noted when testing under different
systems.</p>
<h3 data-number="3.1.2" id="scheduling"><span
class="header-section-number">3.1.2</span> Scheduling</h3>
<img src="images/asyncrunner_diagram.png" style="width:51.0%"
alt="Lifetime of an asynchronous ‘swimming’ function" /> 
<p>Python is known to be a language that doesn’t have native support for
tail-call recursion <span class="citation"
data-cites="guido1 guido2">(Rossum 2009b, 2009a)</span>, making the
infinite recursion of a function a delicate task. To properly support
this central feature, a complex system based on John Phan’s
<code>AsyncRunners</code> has been developed and is used as the basis
for every repetitive operation (such as a pattern) scheduled with
Sardine. In the spirit of the metaphor followed by the whole program, a
temporal recursive function is called by the development team a
<em>swimming function</em>, and is labelled in code as an
<code>AsyncRunner</code>. A <em>swimming function</em> can be started
using the <code>@swim</code> decorator<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>,
stopped using the <code>@die</code> decorator and can receive updates
all along its lifetime on the scheduler.</p>
<p>Decorating a Python function is enough to push a given synchronous or
asynchronous function to the scheduler, making it repeat every
<code>p</code> (for <code>period</code>), a time measured in beats
relative to the clock currently in use. The content of a given function
will be re-evaluated for every recursion cycle and state can be
preserved either by passing arguments to a subsequent call or by relying
on global state. <em>Swimming functions</em> are a powerful construct
for building abstractions dealing with time, code re-evaluation and
dynamic lifetime management of code components. Iterators, for example,
can be built by incrementing a variable passed as argument. Random
generators can be built by calling a simple native random function whose
result will be dynamically updated for each recursion.</p>
<p><em>Swimming functions</em> will automatically start
<em>on-the-beat</em>. The start of a function can target a specific
point in musical time by specifying a special <code>snap</code> argument
that is understood as an offset, in beats, from the beginning of the
next bar. The <code>period</code> argument of a given function is the
only required argument for a function to be considered as a valid
<em>swimming function</em>. Every other component of the
<em>Sardine</em> system works on the assumption that its evaluation
context will be the <em>swimming function</em>. They can receive any
arbitrary Python code and/or call the various players defined by the
Sardine system to properly handle <em>I/O</em> operations. Thus, the
prototype of a basic musical function using the base model looks
like:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">@swim</span> <span class="co"># swimming decorator (swim or die)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> swimming_function(p<span class="op">=</span><span class="fl">0.5</span>, i<span class="op">=</span><span class="dv">0</span>): <span class="co"># p: (period), i (custom iterator)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&#39;I am swimming in time.&#39;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    D(<span class="st">&#39;bd, hh, cp, hh&#39;</span>, i<span class="op">=</span>i) <span class="co"># call to the &#39;Dirt&#39; SuperDirt interface.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    ... <span class="co"># user specified code</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    again(swimming_function, p<span class="op">=</span><span class="fl">0.5</span>, i<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span>) <span class="co"># recursion callback with argument passing</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># remove the call to again() to stop the recursion from happening, stopping the runner.</span></span></code></pre></div>
<p>Multiple abstractions can be built on top of the basic <em>swimming
function</em> mechanism, allowing for a terser user-facing syntax. We
believe that building abstraction on top of the <em>swimming
function</em> is helpful to allow newcomers to get a grasp on the
temporal model offered by the system. The FoxDot’s inspired
<em>surfboard</em> mechanism is currently the only abstraction available
demonstrating this principle. It automatically handles its own
scheduling logic and also provides iterators needed by the
<em>Senders</em> that we will detail later on:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Pa <span class="op">&gt;&gt;</span> d(<span class="st">&#39;bd, hh, cp, hh&#39;</span>, p<span class="op">=</span><span class="fl">0.5</span>) <span class="co"># Terser version of the above swimming function</span></span></code></pre></div>
<h3 data-number="3.1.3" id="central-dispatch-environment"><span
class="header-section-number">3.1.3</span> Central dispatch
environment</h3>
<p>Every component of the system can talk or access the data held by any
other component through the central <em>‘FishBowl’</em> mechanism. The
environment has been implemented as a message dispatcher allowing each
component to subscribe to it throuh <em>hooks</em> and making each
component capable of answering to <code>dispatch</code> messages (such
as <code>bowl.dispatch('stop')</code> for stopping the clock). Some
components are to be considered as hard dependencies, such as the
<code>clock</code> and the <code>parser</code> as they provide the basic
mechanisms needed by every other modular component to properly function.
Every other can just take advantage of the central environment to
provide additional features or logic (such as a midi output, an osc
input, or any other user-defined construct).</p>
<h2 data-number="3.2" id="sardine-pattern-language"><span
class="header-section-number">3.2</span> Sardine Pattern Language</h2>
<p>A small patterning language has been developed for
<strong>Sardine</strong> using the <a
href="https://github.com/lark-parser/lark">Lark</a> parsing toolkit.
Defined as a LALR parser, the syntax of the language is best described
as a list-based calculator capable of dealing with basic MIDI note
definition, custom chance operators and other composition tools.</p>
<h2 data-number="3.3" id="players-and-handlers"><span
class="header-section-number">3.3</span> Players and Handlers</h2>
<p>Description of the event based system. How to define an handler, what
is an hadler, etc…</p>
<p>Demo of the <strong>SuperDirt</strong> handler, etc…</p>
<h1 data-number="4" id="sardine-usage"><span
class="header-section-number">4</span> Sardine usage</h1>
<p>Basic facts about the usage of Sardine in various text editing
environments + how to install and handle a Sardine installation.</p>
<figure>
<img src="images/sardine_and_config_tool.png"
alt="On the left pane, Sardine being imported through fishery*. On the right, the sardine-config configuration client." />
<figcaption aria-hidden="true"><em>On the left pane, Sardine being
imported through </em>fishery*. On the right, the
<code>sardine-config</code> configuration client.</figcaption>
</figure>
<h2 data-number="4.1" id="algorave-and-performance"><span
class="header-section-number">4.1</span> Algorave and performance</h2>
<p>Zorba, Lorient, example code taken from performances.</p>
<h2 data-number="4.2" id="controlling-legacy-midi-synthesizers"><span
class="header-section-number">4.2</span> Controlling Legacy MIDI
Synthesizers</h2>
<p>Rémi Georges usage of Sardine: controlling legacy synthesizers along
with TidalCycles, etc…</p>
<h2 data-number="4.3" id="usage-of-sardine-at-the-ii-laboratory"><span
class="header-section-number">4.3</span> Usage of Sardine at the II
Laboratory</h2>
<p>Projects involving the Magnetic Resonator Piano, Boids, etc…</p>
<h1 data-number="5" id="project-directions"><span
class="header-section-number">5</span> Project directions</h1>
<h2 data-number="5.1" id="packaging-and-distribution"><span
class="header-section-number">5.1</span> Packaging and distribution</h2>
<p>Distribution and release for Python 3.11 with updated C++
dependencies whenever possible. Distribution on Pypi when it’ll be bug
free, etc…</p>
<h2 data-number="5.2" id="opening-up-for-collaboration"><span
class="header-section-number">5.2</span> Opening up for
collaboration</h2>
<p>Documenting, section about the website and integration of the
Sardinopedia.</p>
<h2 data-number="5.3" id="creation-and-performance"><span
class="header-section-number">5.3</span> Creation and performance</h2>
<h1 data-number="6" id="conclusion"><span
class="header-section-number">6</span> Conclusion</h1>
<p>Call for contributors, etc…</p>
<h1 data-number="7" id="acknowledgments"><span
class="header-section-number">7</span> Acknowledgments</h1>
<p>I warmly thank my thesis supervisors Laurent Pottier and Alain
Bonardi for their support and advice in the creation of this tool. I
thank the doctoral school <em>3LA</em> from the University of Lyon for
the funding it provided to this research. I extend my thanks to the
musicians and friends who allowed me to take <strong>Sardine</strong> on
stage and to present it to a wider audience these few last months: the
<strong>Cookie Collective</strong>, Rémi Georges, etc…</p>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
role="doc-bibliography">
<div id="ref-aaron2016sonic" class="csl-entry" role="doc-biblioentry">
Aaron, Sam. 2016. <span>“Sonic Pi–Performance in Education, Technology
and Art.”</span> <em>International Journal of Performance Arts and
Digital Media</em> 12 (2): 171–78.
</div>
<div id="ref-cookiewebsite" class="csl-entry" role="doc-biblioentry">
Collective, Cookie. 2016. <span>“Cookie Collective.”</span> <a
href="https://cookie.paris/all/"
class="uri">https://cookie.paris/all/</a>.
</div>
<div id="ref-goltz2018ableton" class="csl-entry" role="doc-biblioentry">
Goltz, Florian. 2018. <span>“Ableton Link–a Technology to Synchronize
Music Software.”</span> In <em>Proceedings of the Linux Audio
Conference</em>, 39–42.
</div>
<div id="ref-isobar" class="csl-entry" role="doc-biblioentry">
Jones, Daniel John. n.d. <span>“Isobar.”</span> <a
href="https://github.com/ideoforms/isobar">https://github.com/ideoforms/isobar</a>.
</div>
<div id="ref-kirkbride2016foxdot" class="csl-entry"
role="doc-biblioentry">
Kirkbride, Ryan. 2016. <span>“Foxdot: Live Coding with Python and
Supercollider.”</span> In <em>Proceedings of the International
Conference on Live Interfaces</em>, 194–98.
</div>
<div id="ref-mclean2014making" class="csl-entry" role="doc-biblioentry">
McLean, Alex. 2014. <span>“Making Programming Languages to Dance to:
Live Coding with Tidal.”</span> In <em>Proceedings of the 2nd ACM
SIGPLAN International Workshop on Functional Art, Music, Modeling &amp;
Design</em>, 63–70.
</div>
<div id="ref-vortex" class="csl-entry" role="doc-biblioentry">
McLean, Alex, Damian Silvani, Raphaël Forment, and Sylvain Le Beux.
2022. <em>TidalVortex Zero</em>. Zenodo. <a
href="https://doi.org/10.5281/zenodo.6456380">https://doi.org/10.5281/zenodo.6456380</a>.
</div>
<div id="ref-mcpherson2020idiomatic" class="csl-entry"
role="doc-biblioentry">
McPherson, Andrew, and Koray Tahıroğlu. 2020. <span>“Idiomatic Patterns
and Aesthetic Influence in Computer Music Languages.”</span>
<em>Organised Sound</em> 25 (1): 53–63.
</div>
<div id="ref-guido2" class="csl-entry" role="doc-biblioentry">
Rossum, Guido Van. 2009a. <span>“Final Word on Tail Calls.”</span> Blog.
</div>
<div id="ref-guido1" class="csl-entry" role="doc-biblioentry">
———. 2009b. <span>“Tail Recursion Elimination.”</span> Blog.
</div>
<div id="ref-asynciorepl" class="csl-entry" role="doc-biblioentry">
Selivanov, Yuri. n.d. <span>“Implement Asyncio REPL.”</span> <a
href="https://github.com/python/cpython/issues/81209"
class="uri">https://github.com/python/cpython/issues/81209</a>.
</div>
<div id="ref-SorensenTemporal" class="csl-entry" role="doc-biblioentry">
Sorensen, Andrew. 2013. <span>“The Many Faces of a Temporal
Recursion.”</span> <a
href="http://extempore.moso.com.au/temporal_recursion.html">http://extempore.moso.com.au/temporal_recursion.html</a>.
</div>
<div id="ref-uvloop" class="csl-entry" role="doc-biblioentry">
Stack), Yury Selivanov (Magic. 2016. <span>“UVLoop.”</span> <em>GitHub
Repository</em>. <a href="https://github.com/MagicStack/uvloop"
class="uri">https://github.com/MagicStack/uvloop</a>; GitHub.
</div>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><em>Read, Eval, Print, Loop</em>: mechanism used by most
interpreted languages to quickly process user input from the command
line.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The process for setting up various interfaces is
extensively detailed on <a
href="https://sardine.raphaelforment.fr">Sardine Website</a><a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Decorators in Python are used to add a behaviour to an
object without modifying the base object itself.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
