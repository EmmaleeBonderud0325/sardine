from lark import Lark, Tree
from pathlib import Path
from .TreeCalc import CalculateTree

__all__ = ("ListParser", "Pnote", "Pname", "Pnum")


class ParserError(Exception):
    pass


# This section of the code is charged with retrieval and loading of grammar
# files stored in the grammars/ subfolder next to ListParser.py. Each file
# contains the formal specification of the grammar, and is used by Lark to
# build an abstract syntax tree and get the combination rules for each token.


grammar_path = Path(__file__).parent
grammars = {
    "number": grammar_path / "grammars/number.lark",
    "name": grammar_path / "grammars/name.lark",
    "note": grammar_path / "grammars/note.lark",
    "proto": grammar_path / "grammars/proto.lark",
}


parsers = {
    "number": {
        "raw": Lark.open(
            grammars["number"],
            rel_to=__file__,
            parser="lalr",
            start="start",
            cache=True,
            lexer="contextual",
        ),
        "full": Lark.open(
            grammars["number"],
            rel_to=__file__,
            parser="lalr",
            start="start",
            cache=True,
            lexer="contextual",
            transformer=CalculateTree(),
        ),
    },
    "name": {
        "raw": Lark.open(
            grammars["name"],
            rel_to=__file__,
            parser="lalr",
            start="start",
            cache=True,
            lexer="contextual",
        ),
        "full": Lark.open(
            grammars["name"],
            rel_to=__file__,
            parser="lalr",
            start="start",
            cache=True,
            lexer="contextual",
            transformer=CalculateTree(),
        ),
    },
    "note": {
        "raw": Lark.open(
            grammars["note"],
            rel_to=__file__,
            parser="lalr",
            start="start",
            cache=True,
            lexer="contextual",
        ),
        "full": Lark.open(
            grammars["note"],
            rel_to=__file__,
            parser="lalr",
            start="start",
            cache=True,
            lexer="contextual",
            transformer=CalculateTree(),
        ),
    },
    "proto": {
        "raw": Lark.open(
            grammars["proto"],
            rel_to=__file__,
            parser="lalr",
            start="start",
            cache=True,
            lexer="contextual",
        ),
        "full": Lark.open(
            grammars["proto"],
            rel_to=__file__,
            parser="lalr",
            start="start",
            cache=True,
            lexer="contextual",
            transformer=CalculateTree(),
        ),
    },
}


class ListParser:
    def __init__(self, parser_type: str = "number"):
        """ListParser is the main interface for the pattern syntax. It can be
        initialised in three different modes: 'number', 'note', 'name'. It is
        up to the user to choose the parser that fits best to a task. Each
        parser will be initialised two times, in two different modes:
        - full: the parser as it is used for parsing expressions and returning
        a result.
        - raw: the parser as it is used to print the syntax tree in debug mode.

        Args:
            parser_type (str, optional): Type of parser. Defaults to "number".
        """
        try:
            self._result_parser = parsers[parser_type]["full"]
            self._printing_parser = parsers[parser_type]["raw"]
        except KeyError:
            ParserError(f"Invalid Parser grammar, {parser_type} is not a grammar.")

    def _flatten_result(self, pat):
        """Flatten a nested list, for usage after parsing a pattern. Will
        flatten deeply nested lists and return a one dimensional array.

        Args:
            pat (list): A potentially nested list

        Returns:
            list: A flat list (one-dimensional)
        """
        if len(pat) == 0:
            return pat
        if isinstance(pat[0], list):
            return self._flatten_result(pat[0]) + self._flatten_result(pat[1:])
        return pat[:1] + self._flatten_result(pat[1:])

    def pretty_print(self, expression: str):
        """Pretty print an expression coming from the parser. Works for any
        parser and will print three things on stdout if successful:
        - the expression itself
        - the syntax tree generated by the parser for this expression
        - the result of parsing that syntax tree

        Args:
            expression (str): An expression to pretty print
        """
        print(f"EXPR: {expression}")
        print(Tree.pretty(self._printing_parser.parse(expression)))
        print(f"RESULT: {self._result_parser.parse(expression)}")

    def print_tree_only(self, expression: str):
        """Print the syntax tree using Lark.Tree

        Args:
            expression (str): An expression to print
        """
        print(Tree.pretty(self._printing_parser.parse(expression)))

    def _parse_token(self, string: str):
        """Parse a single token and return its result

        Args:
            string (str): A token to parse

        Returns:
            any: The result of parsing
        """
        return self._result_parser.parse(string)

    def parse(self, pattern: str):
        """Main method to parse a pattern. Parses 'pattern' and returns
        a flattened list to index on to extract individual values. Note
        that this function is temporary. Support for stacked values is
        planned.

        Args:
            pattern (str): A pattern to parse

        Raises:
            ParserError: Raised if the pattern is invalid

        Returns:
            list: The parsed pattern as a list of values
        """
        final_pattern = []
        for token in pattern.split():
            try:
                final_pattern.append(self._parse_token(token))
            except Exception as e:
                raise ParserError(f"Non valid token: {token}") from e
        return self._flatten_result(final_pattern)

    def _parse_debug(self, pattern: str):
        """Parses a whole pattern in debug mode. 'Debug mode' refers to
        a mode where both the initial expression, the syntax tree and the
        pattern result are printed directly on stdout. This allows to study
        the construction of a result by looking at the syntax tree.

        Args:
            pattern (str): A pattern to be parse.
        """
        for token in pattern.split():
            try:
                self.pretty_print(expression=token)
            except Exception as e:
                import traceback

                print(f"Error: {e}: {traceback.format_exc()}")
                continue


# Useful utilities


def Pname(pattern: str, i: int = 0):
    """Generates a pattern of names

    Args:
        pattern (str): A string to be parsed
        i (int, optional): Index for iterators. Defaults to 0.

    Returns:
        _type_: _description_
    """
    parser = ListParser(parser_type="name")
    pattern = parser.parse(pattern)
    return pattern[i % len(pattern)]


def Pnote(pattern: str, i: int = 0):
    """Generates a pattern of notes

    Args:
        pattern (str): A string to be parsed
        i (int, optional): Index for iterators. Defaults to 0.

    Returns:
        _type_: _description_
    """
    parser = ListParser(parser_type="note")
    pattern = parser.parse(pattern)
    return pattern[i % len(pattern)]


def Pnum(pattern: str, i: int = 0):
    """Generates a pattern of numbers

    Args:
        pattern (str): A pattern to be parsed
        i (int, optional): Index for iterators. Defaults to 0.

    Returns:
        int: A number taken from the pattern
    """
    parser = ListParser(parser_type="number")
    pattern = parser.parse(pattern)
    return pattern[i % len(pattern)]
