# Operators

**Python** is limited to a set of operators and you can&rsquo;t create your own. That&rsquo;s not good for us because live coding is also about speed. It is faster to write `!!` than to write `repeat_and_copy`. That&rsquo;s also why having a **pattern language** is important. We have new operators to work with to create musical patterns.

# Choice

```python
@swim
def choosing stuff(p=0.5, i=0):
    D('bd|pluck', speed='1|2', i=i)
    again(choosing_stuff, p=0.5, i=i+1)
```

The pipe operator `|` can be used on anything to make a 50/50% choice between two tokens. You can also chain them: `1|2|3|4`. The behavior of chaining multiple choice operators has not been clearly defined. The distribution might not be the one you expect.

# Ranges

```python
@swim
def ranges(p=0.5, i=0):
    D('pluck|jvbass', speed='1~5', i=i)
    again(ranges, p=0.5, i=i+1)
```
    
- If you want to generate a number in the range `x` to `y` included, you can use the `~` operator. This operator will adapt to context (integer or floating point number).
- It can be used as an alternative to `rand` for scaled randomisation.

# Ramps

```python
@swim
def rampD(p=0.5, i=0):
    D('amencutup:[0:10]',
      room='[0:1,0.1]',
      cutoff='[1:10]*100', i=i)
    again(ramps, p=0.5, i=i+1)
```
    
-   This operator is very reminiscent of the **range()** function, only better.
-   You can generate ramps of integers using the `[1:10]` syntax.
    -   This expression will yield `[1 2 3 4 5 6 7 8 9 10]`.
-   You can ramp up and you can ramp down!
-   You can be more specific: `[1:10 2]`.
    -   This expression will yield: `[1 3 5 7 9]`.
    -   It also works with floating point numbers and floating point number steps: `[1:10,0.5]`!

# Repeat

```python
@swim
def repeat_stuff(p=0.5, i=0):
    D('pluck|jvbass', speed='1:2', n='C4!4 E4!3 E5 G4!4', i=i)
    again(repeat_stuff, p=0.5, i=i+1)
```
    
- The `!` operator inspired by ****TidalCycles**** is used to denote the repetition of a value.
  - You need to add a number or a list to its right side.
  -   There is also the `!!` to be used on lists. This second one will not repeat the content of the list but repeat each element `x` times.

# Silence

```python
@swim
def silence_demo(p=0.5, i=0):
    D('bd ...', i=i, d=1)
    D('hh . hh ..', i=i, d=1)
    again(silence_demo, p=1/8, i=i+1)
```
    
- You can use a dot (`.`) inside any pattern to denote a silence. Be careful, the concept of silence in **Sardine** can be pretty confusing.
    
Silence is a very important and complex topic. Adding silences is a great way to generate interesting patterns. Silences are different for each sender because silence doesn&rsquo;t have the same meaning for a sampler, a MIDI output or an OSC output (`D()`, `N()`, etc.).
    
-   `D()`: a silence is the absence of a sample. The event will be skipped.
-   `N()`: a silence is the absence of a note. The event will be skipped.
-   any OSC based Sender: a silence is the absence of an address. The event will be skipped.
    
Perfect, but what about other patterns that live alongside the main pattern? A silence in an auxilliary pattern will cause a **&rsquo;parametric silence&rsquo;** to happen. Take a look at the following example:
    
```python
@swim
def silence_demo(p=0.5, i=0):
    D('sitar', legato='0.5', speed='[1:4] .!8', i=i, d=1)
    again(silence_demo, p=1/8, i=i+1)
```
    
We always have a sample here. There is no **real** silence, only a parametric one (in `speed`).
Denoting the absence of something the silence will cause the pattern to search its last value and hold it. **Sardine** will backtrack and search the last value that could have been generated by the pattern. The result of the `speed` parameter will then be `[1 2 3 4 8 8 8 8 8 8 8 8]`.
For people familiar with modular synthesizers and analog circuits, this is pretty much a **sample & hold** mechanism.
Note that it is impossible to write a **parametric silence** composed only of silences. A pattern of nothing is not a pattern.

## Lists and Collections

The **Sardine** pattern notation is built around the idea of having multiple ways to deal with linear lists and collections. The basic arithmetic syntax and most operators work on single tokens **but will also work on lists**. It means that you can write expressions such as :
    
```python
[0 1 2 3]%8
[0 2 4 5]*[4 5]
[1:8 0.1]&[2 9]
[0 2 4 5 9 10 12 14]!2
[0 2 4 5 9 10 12 14]!!4
```
    
There are a few special operators that are only available when you deal with lists. This is something you will get familiar with by trying. You will see that most things work while some will not yield the result you expect.

## Slicing and indexing

```python
@swim
def test_slice(p=0.5, i=0):
    D('pluck:19',
      legato=0.2,
      midinote='([60 63 67 69 71]&[i.i i.i + 8])^(1~8)', i=i)
    again(test_slice, p=0.125, i=i+1)
```
    
-   You can get a slice or just one value from a list by using the special `&` operator.
-   It will work with any list on the right side of the operator but it will only take the first and second value of it no matter what to compose a slice.
-   The index value can be infinite because the index is looping on the list. You can feed a random number generator and get something out.
    
On the down side, it can become quite complex to write very fast, so be careful with it:
    
```python
@swim
def test_slice(p=0.5, i=0):
    D('pluck:19', legato=0.2,
      n='[60 62 63 67 69 71]^(1~5)&[r rand*4]', i=i)
    again(test_slice, p=0.125, i=i+1)
```

## Extend

```python
@swim
def test_extend(p=0.5, i=0):
    D('pluck:19', legato=0.2, midinote='[60 62]!2', i=i)
    again(test_extend, p=0.125, i=i+1)
```
    
Just like with numbers, names and addresses, you can extend a list by calling the `!` operator on it. It will repeat the list x times.

## Extend-repeat

```python
@swim
def test_extend_repeat(p=0.5, i=0):
    D('pluck:19', legato=0.2, midinote='[60 62 63]!!3', i=i) #note the repetition of values within the list
    again(test_extend_repeat, p=0.125, i=i+1)
```
The variant `!!` now makes sense. It allows you to repeat each individual value in a list `x` times.



