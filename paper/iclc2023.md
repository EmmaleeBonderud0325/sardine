---
# This template is licensed under a Creative Commons 0 1.0 Universal License (CC0 1.0). Public Domain Dedication.


title: 'Sardine: a Modular Python Live Coding Environment'
author:
  - name: Raphaël Forment
    affiliation: Université Jean Monnet (Saint Étienne, ECLLA)
    email: raphael.forment@gmail.com
  - name : Jack Armitage
    affiliation: Iceland University of the Arts (Reykjavik), Intelligent Instruments Lab
    email: jack@lhi.is
abstract: |
    **Sardine** is a live coding environment and library for Python 3.10+ focusing on the modularity and extensibility of several base components (clocks, parser, *handlers*). 
    Sardine has been designed to be easily integrated with existing live coding environments as both a tool for experimentation, and a demonstration of various live coding techniques: temporal recursion, patterning, integration in various hardware and software setups. 
    Although the tool is still in active early development, it has already been used in multiple public performances and algoraves, partly enabled by its support for MIDI IN/Out, OSC IN/Out and *SuperCollider*/*SuperDirt* one-way communication through OSC.
    This paper is dedicated to the introduction of the **Sardine** system, and the explanation of the main guidelines currently followed by contributors to the project. 
    It will also present the preliminary results of our work through practical realisations that served as experimental validation during the early stages of development. 
fontsize: 11pt
geometry: margin=2cm
fontfamily: libertine
fontfamily: inconsolata
mainfont: Linux Libertine O
monofont: Inconsolata
bibliography: references.bib
header-includes:
    - \usepackage{multicol}
    - \newcommand{\hideFromPandoc}[1]{#1}
    - \hideFromPandoc{
        \let\Begin\begin
        \let\End\end
      }

...

![*Sardine first algorave in Lorient (France), 2022, October 13th. Photography: Guillaume Kerjean.*](images/sardine_intro_picture.png)

# Introduction

Sardine is a live coding library based on Python 3.10+ focusing on modularity and extensibility of several base components. 
Despite still being in early alpha stage, Sardine is extensively documented on a [dedicated website](https://sardine.raphaelforment.fr) providing installation guides, tutorials and media examples. 
Sardine provides three main features linked together by the `FishBowl` -- an environment handling synchronisation and communication between them:

- A *scheduling system* based on asynchronous and recursive function calls, inspired by the concept of temporal recursion [@SorensenTemporal]. Calls can be scheduled in musical time either on an `InternalClock` or a `LinkClock` based on the Link Protocol [@goltz2018ableton].

- A *modular handler* system allowing the addition and/or removal of various inputs/outputs (e.g. OSC, MIDI) or base components through a central `dispatch` environment named the `FishBowl`. This allows the customisation of IO logic, without the need to rewrite or refactor low-level system behaviour.

- A *concise number-based pattern programming language* with support for basic generative and musical syntax (MIDI notes, polyphony, etc), time-based patterns (clock and absolute time) and handling of symbols.

Sardine, by design, is in the direct lineage of previously released Python based libraries such as [FoxDot](https://foxdot.org) [@kirkbride2016foxdot], [Isobar](https://github.com/ideoforms/isobar) [@isobar] or the very recent [TidalVortex](https://github.com/tidalcycles/vortex) [@vortex]. Initially conceived as a demonstration tool, Sardine partially emulates some selected features from the previously mentioned libraries or from the dominant live-coding dialects such as the [TidalCycles](https://tidalcycles.org) pattern mini-notation [@mclean2014making] or the [Sonic Pi](https://sonic-pi.net/) imperative scheduling syntax [@aaron2016sonic]. Sardine is designed as an agnostic framework for approaching live coding using Python. Thus, the library aims to support different writing paradigms and different approaches to live performance based on the manipulation of source code. The reliance on regular Python asynchronous functions for scheduling and music writing means that Sardine is particularly suited to let each developer-musician follow their own personal coding style, providing a blank slate for experimental interface building. Furthermore, Sardine's design has been strongly influenced by McPherson and Tahiroğlu's concerns about the idiomatic patterns [@mcpherson2020idiomatic] of usage enforced by computer music software, pushing users to repeat and strictly follow prefered patterns of usage. Sardine focuses on laying out the base infrastructure needed to support live coding in Python and wishes to encourage users to imagine diverse patterning idioms and live coding targets, mini-notations or user-facing scheduling mechanisms and syntax. The system's modular architecture is a first step towards the inclusion of more targets and custom input and output handling.

<!-- JA: There is a lot of repetition in this paragraph, most of it can be cut -->
The version hereby presented -- `v0.2.0` at time of writing -- offers a first look into the complete intended design for the library, and is a near complete rewrite over the `0.1.0` version previously used by members of the French live coding scene and by the first global Sardine users. It features two different clock implementations, multiple handlers for IO (MIDI, OSC, SuperDirt), a robust asynchronous temporal recursive scheduling system, and a reimagining of the Player system previously introduced by FoxDot [@kirkbride2016foxdot]. Sardine's originality lies in its temporal model, strongly anchored in Python's default mechanisms for asynchronous programming. Sardine also features a modular overall architecture allowing it to be integrated into any live coding tooling and setup, capable of handling most Python-based scheduling duties or to be integrated into a larger mixed platform setup. It has been developed collectively with the help of John Phan, based on user requests and feedback gathered during a first period of experimentation that saw Sardine being used or integrated by musicians for several algoraves, network-based jams and musical performances. 

Sardine has been developed exclusively using the Python programming language with few libraries depending on C++ code through bindings to external libraries. Despite the known shortcomings of Python for interpreted real-time programming (incomplete support of dynamic programming, slowness relative to other interpreted languages), we believe that this language is suitable for the implementation of a live coding library. The large collection of available libraries and modules and the popularity of the language ensures the affordance of good tooling and rich customization and integration options for different text editors, running environments, and more. Sardine already takes advantage of a thorough ecosystem of libraries focused on data input/output, network communication and text manipulation. Moreover, thanks to its lightweight and clear syntax, Python can be read by programmers coming from various backgrounds, making it a convenient platform for collaboration and experimentation with bespoke features needed by performers.

In the present article, we will introduce Sardine by detailing its goals (1) and base implementation centered on the scheduling mechanism (2), the environment/handler system (3) and the mininotation support (4). By doing so, we hope to highlight the basic principles of its inner workings, while providing some context on the current direction taken by the project and by its users.

# Methodology and objectives: a framework for exploring live-coding in Python

Sardine is born out of a curiosity for the implementation of similarly featured Python-based live-coding libraries such as [FoxDot](https://foxdot.org), [Isobar](https://github.com/ideoforms/isobar) or the very recent [TidalVortex](https://github.com/tidalcycles/vortex) [@vortex]. At its inception, the Sardine project was thought as an attempt to provide a functional but barebones live coding library for demonstration purposes in a dissertation manuscript; a library capable enough for showing the impact of design and implementation choices on the possibilities of musical expression and on the expressiveness offered by a live coding environment. Therefore, a particular attention has been given to reproducing or *at least* paving the way for the reproduction of different coding styles and representation of timed musical information. Initial work for the `0.1.0` has been based upon an older personal attempt at writing a live coding library, then named *ComputerTalk*^[Some videos of this older system can be found on Raphaël's YouTube channel: \url{https:/youtube.com/watch?v=MHGYtlKibUo}]. The base design, not suitable with our goal, has quickly evolved after the first initial public tests. It has been decided to aim for an increased modularity of the system in order to support and maximise the *input* and *output* options offered by Sardine. This has allowed for the quick integration of the tool with other neighbour interfaces and live coding environments. 

The development of Sardine began initially in a period of frantic collaborations and joint performances with the Parisian *Cookie Collective* [@cookiewebsite] and the Digital Audio Community from Lyon (*th4*, *rAlt144MI*, etc..). Stemming from the *demoscene* and shader-coding scene, the *Cookie* is known for its complex multimedia performances, each member relying on bespoke hybrid audio-visual setups ranging from low end computing devices to complex synthesizers and circuit-bended video mixers. It is also known for working in an improvised manner, customising its setup for each venue depending on the audience needs and expectations. The need to adapt and customize the live coding interfaces already in use to the needs of each performance and each artist gave rise to the idea of creating a modular interface that could be used and mastered by every member of the collective, while allowing for jam-ready synchronisation with other musicians and live-coders. The recent splitting of Foxdot's development into several scattered branches reinforced the need for a central, customizable and easily editable Python interface, the software being particularly used in the French live coding community. Due to the open-ended nature of the development process, Sardine has been gradually shifting towards its current modular architecture, allowing each performer to refine the nature of the *inputs* and *outputs* controllable through the system, from simple MIDI note output to more convoluted custom Sysex and OSC message support. The invaluable help and expertise from John Phan has allowed for a complete deep rewrite of every base mechanism. With Sardine's finalization of its new framework marks the beginning of a new stage in the development process, focused on introducing new features and improving existing ones. This process is managed in an *ad-hoc* manner, by encouraging users to propose ideas and contribute to an extensively documented codebase.

# Sardine implementation

![Sardine usage workflow](images/usage.png)\
\begin{center}
\textbf{Figure 1:} \textit{Software layers of the Sardine system stack.}
\end{center}

Sardine is implemented and distributed as two complementary Python modules: `sardine` and `fishery`. These modules will typically work hand in hand to provide the interface to the user. `fishery` provides amendments to the default Python asynchronous REPL^[*Read, Eval, Print, Loop*: mechanism used by most interpreted languages to quickly process user input from the command line.] and constitutes the entry point for the Sardine system, accessible by typing `python -m fishery` or simply `fishery` right after install. `fishery` is nothing more than a slightly modified version of the base Python asynchronous REPL. Importing it also imports `sardine` and will *de facto* start a new playing session. As a helper for new users, a terminal based configuration client (`sardine-config`) is also provided and can be used to setup various options before starting `fishery`. Configuration files are stored in a default standard location depending on the OS currently in use (`e.g.` `.local/share` on UNIX systems). Configuration files include a general JSON file, a blank `.py` usable to load user-specifc Python code at the start of each session and the files needed to properly configure a *SuperCollider*/*SuperDirt* session. This architecture -- despite its initial complexity -- makes Sardine more accessible to novice users who may not be familiar with using the command line and Python development tools. Files relative to Sardine will be kept in a single configuration folder. Note that modularity of the system is greatly encouraged, with many *input* and *output* components being disabled by default. This makes the installation of any audio-backend like *SuperCollider* entirely optional, the latter being considered more as a target than a dependency.

Thanks to the generally great IDE support for Python, *Sardine* is not shipping with its own text-editor or dedicated text editor plugin. Sardine has been tested with third-party code writing tools such as *Atom*, *VSCode*, *Emacs*, *Vim/Neovim* or even *Jupyter Notebooks*. Each one of these text editors generally support the spawning of an asynchronous REPL and the piping of code from a text buffer to a running interpreter. The setup process for each one of these interfaces generally relies on the installation of a simple general-purpose Python plugin^[The process for setting up various interfaces is extensively detailed on Sardine's [Website](https://sardine.raphaelforment.fr).]. This has lead us to consider the Python interpreter as a code receiver and monitoring tool mainly used to mirror useful information to the user, such as the state of the SuperCollider sub-process, of the event loop and *runners*, etc... Every other operation is directly handled by calls internal to a Sardine session.

Reliance on any audio backend can / will require the boot of another application. For the time being, only *SuperCollider* and *SuperDirt* are natively supported by their own Sardine components. Even though the installation of these backends is still necessary for users willing to use them, integration is done in such a way that there is no need -- later on -- to actively take care and monitor any of these dependencies. A basic API to *SuperCollider* and *SuperDirt* is offered through the `SC.send()` function, allowing to run arbitrary `sclang` code in the subprocess session. The addition of more automatically-managed audio-backend *subprocesses* is planned and will be explored in the coming months (deeper *SuperCollider* integration, *CSound* backend, etc...). Clever combination of Sardine provided functions is already allowing some amount of customization for patterning hardware and software synthesizers through MIDI or OSC.

Being packaged as a regular Python module, Sardine makes use of the `pyproject.toml` module configuration and packaging format defined by PEP 660. No third party tool is currently required to install Sardine other than a base *complete* installation of a modern (3.10+) Python runtime. The package has recently been packaged and released on `Pypi`, allowing any Python user to install it using the `pip install sardine-system` command. Work has been done to properly ensure that every C++ dependency is served on our own and that `wheels` -- binary distribution of compiled packages -- are available for every major platform. This has solved a long-lasting issue that prevented users from installing Sardine on the recently released Python 3.11 version.

## Event loop and scheduling System

### Event loop

![*Event Loop Diagram*](images/event_loop.png){width=100%}\`
\begin{center}
\textbf{Figure 2:} \textit{Architecture diagram of the customised asynchronous event loop.}
\end{center}


Sardine is making use of the asynchronous programming features offered by Python. More specifically, Sardine takes advantage of the little known `asyncio` REPL prototype introduced by Python 3.8 [@asynciorepl]. The UVLoop [@uvloop] drop-in replacement event loop is also being used -- but not on Windows -- in order to speed up the scheduling of asynchronous calls. Several hot-patches to the asynchronous loop have been introduced by John Phan (*thegamecracks*) in order to make its behaviour consistent on every major OS platform. Sardine is laid out as a series of abstractions built on the base loop, making it aware of tempo and timing. Sardine *clock* (either the `internal` or `link`) clock automatically starts whenever the system is imported but pure asynchronous calls can still be handled even if the clock is being stopped. The usage of the `LinkClock` will allow Sardine users to link their session to a global tempo shared by other users of the local network, allowing networked synchronisation of several Sardine or Link capable hardware/software. Every clock provides the same interface, allowing the system to retrieve the current bar, beat and current position in *musical* time. Time drift compensation and the time shifting needed by some functionalities is handled entirely by the low-level event loop system.

The consistency of the asynchronous clocks is being covered by tests (in the `tests/` folder) and has been checked to be *on-par* with the alternatives offered by similar, more widely used threaded clocks. Development of such a feature has proven to be a difficult technical challenge due to the specificity of the task and of the relatively obscure and scarcely documented inner workings of internal OS's schedulers. Threaded components are still used for various *I/O* operations in order to lighten the load of the event loop and to alleviate the temporal cost of message processing. Note that many *Sardine* components are entirely optional and can be activated on demand by the user. Only the `clock`, `AsyncRunners` and `SleepHandler` constitute the core abstractions needed over Python `asyncio` loop. Basing the custom event loop on top of the Python asynchronous interpreter is allowing for the evaluation of any top-level asynchronous `await` instructions that would be forbidden by the main interpreter. It must be noted that Python `asyncio` features might behave differently on every major OS due to its binding with system-level mechanisms. 

### Scheduling

\Begin{multicols}{2}

![*Lifetime of an asynchronous 'swimming' function*](images/asyncrunner_diagram.png){width=51%}\ 
\begin{center}
\textbf{Figure 3:} \textit{Lifetime of an asynchronous 'swimming function'.}
\end{center}

Python is known to be a language that doesn't have native support for tail-call recursion [@guido1;@guido2], making the infinite recursion of a function a delicate task. To properly support this central feature, a complex system based on John Phan's `AsyncRunners` has been developed and is used as the basis for every repetitive operation -- such as a pattern -- scheduled with Sardine. In the spirit of the metaphor followed by the whole program, a temporal recursive function is nicknamed a *swimming function* by the development team and is labelled in code as an `AsyncRunner`. A *swimming function* can be started using the `@swim` decorator^[Decorators in Python are used to add a behaviour to an object -- such as a function -- without modifying the base object itself.], stopped using the `@die` decorator and can receive updates all along its lifetime on the scheduler.

Decorating a Python function is enough to push a given synchronous or asynchronous function to the scheduler, making it repeat every `p` (for `period`), a time measured in beats relative to the clock currently in use. The content of a given function will be re-evaluated for every recursion cycle and state can be preserved either by passing arguments to a subsequent call or by relying on global state. *Swimming functions* are a powerful construct for building abstractions dealing with time, code re-evaluation and dynamic lifetime management of code components. Iterators, for example, can be built by incrementing a variable passed as argument. Random generators can be built by calling a simple native random function whose result will be dynamically updated for each recursion.

\End{multicols}

*Swimming functions* will automatically start *on-the-beat*. The start of a function can target a specific point in musical time by specifying a special `snap` argument that is understood as an offset, in beats, from the beginning of the next bar. The `period` argument of a given function is the only required argument for a function to be considered as a valid *swimming function*. Every other component of the *Sardine* system is based on the assumption that its evaluation context will be the *swimming function*. They can receive any arbitrary Python code and/or call the various players defined by the Sardine system to properly handle *I/O* operations. Thus, the prototype of a basic musical function using the previously defined model looks like the following:

~~~~ {.python}
@swim                                      # swimming decorator (swim or die)
def swimming_function(p=0.5, i=0):         # p: (period), i (custom iterator)
    print('I am swimming in time.')        # genuine function call
    D('bd, hh, cp, hh', i=i)               # call to the 'Dirt' SuperDirt interface.
    ...                                    # other user specified code
    again(swimming_function, p=0.5, i=i+1) # recursion callback with argument passing
    # remove the call to again() to stop the recursion from happening, stopping the runner.
~~~~
\begin{center}
\textbf{Figure 4:} \textit{A commented complete example of a 'swimming' recursive function.}
\end{center}


Multiple abstractions can be built on top of the basic *swimming function* mechanism, allowing for a terser user-facing syntax. We believe that building abstraction on top of the *swimming function* is helpful to allow newcomers to get a grasp on the temporal model offered by the system. The FoxDot's inspired *surfboard* mechanism is currently the only available abstraction demonstrating this principle. It automatically handles its own scheduling logic and provides its own iterators needed by the default parser. As demonstrated by the following example, it also provides additional musical logic without the need for altering the base scheduling logic, thus adding a completely new -- and optional -- flavour of patterning/scheduling for Sardine users. Following this model, Sardine future versions are likely to include user-based modes of playing built upon the basic abstractions provided by the library.

~~~~ {.python}
Pa >> d('bd, hh, cp, hh', p=0.5) # Terser version of the above swimming function.
Pb >> d('voodoo', span=2)        # 'span' extends the inner-hidden swimming 
                                 # function duration to span over twice the 
                                 # duration of Pa.
Pc >> d('voodoo, tabla', legato=0.1, span=2, p='1,2,3,4') 
                                 # duration values of Pc will be fitted to the 
                                 # duration of the given timespan.
Pc >> None                       # alternative to @die
~~~~
\begin{center}
\textbf{Figure 5:} \textit{A 'surfboard', custom FoxDot-like emulation adding a new playing mode to Sardine.}
\end{center}

Sardine's `sleep()` method, worthy of note, has been overridden from the default Python `time.sleep()` function that would, if used, block the event loop. This special function will allow to defer the execution of any statement or expression defined thereafter to *x* beats in the future even if these events take place after the next recursive call. This latter phenomenon is known and referred to as *oversleeping*. Unlike `time.sleep()`, this function does not actually block the function from running to its end. Instead, it temporarily affects the value of `clock.time` and extends the perceived time of methods using that property. This mechanism has been introduced to mimick the `sleep()` statement found in other live coding tools such as Sonic Pi [@aaron2014temporal].

~~~~ {.python}
@swim
def sonorous_cake(p=2, i=0):
    D('jvbass!4, jvbass:4', midinote='C,Eb,G,D', i=i) # SuperDirt calling sample playback
    sleep(1)                                          # Deferring further operations to next beat
    D('jvbass:4!4', midinote="C', C''!3", i=i)        # Other sample playback
    again(sonorous_cake, p=2, i=i+1)                  # Recursive call
~~~~
\begin{center}
\textbf{Figure 6:} \textit{Usage of the 'sleep' method to defer execution, mimicking Sonic Pi.}
\end{center}



## Environment, dispatch and handlers

### The FishBowl

While scheduling takes an important part in the overall modular design of the Sardine library, its logic wouldn't function without the central piece of the system called the `FishBowl`. The `FishBowl` is an environment for software components handling the synchronisation and coordination between all the different pieces composing a Sardine system. This environment has been designed so that every component of the system can talk or access transparently and instantly to the data held by any other component. The `FishBowl` is a central coordination mechanism allowing components to subscribe to it throuh `hooks` and to react to every message through a `dispatch` system. The `bowl.dispatch('stop')` message is an example of such an event -- stopping the clock -- asking for the collaboration and immediate response of multiple components. Naturally, some components are more important than others and can thus be considered as *hard* dependencies. Other *soft* dependencies, mainly the various *I/O* handlers available, can be added and removed from the environment/session at any point in time. The `clock` and the `parser` are two *hard* dependencies that cannot be removed but which can be swapped. They provide the basic mechanisms needed by every other modular component to properly function. The fluidity of the `FishBowl` mechanism allows for the addition and removal of modular logic to any Sardine system capable of answering to any message currently being dispatched to neighbor components. One can switch from the `internal` to the `link` clock *on-the-fly* if the need arises to synchronise with other players, or add a new OSC receiver. Even though the current version of Sardine does not feature multiple parsers, the parser can also be switched.

~~~~ {.python}
bowl = FishBowl(clock=clock(tempo=config.bpm, bpb=config.beats)) # declaring the bowl
...
midi = MidiHandler(port_name=str(config.midi))                   # instance of new component
bowl.add_handler(midi)                                           # adding to the environment
M = midi.send                                                    # aliasing for playability
~~~~
\begin{center}
\textbf{Figure 6:} \textit{Excerpt from Sardine boot process, addition of a MIDI Output.}
\end{center}

### Case-study of a component: the MIDI sender

In the previous code example, a MIDI handler was added to the `FishBowl`, giving access to a new MIDI output. *Senders* are one type of Sardine modular components which requires the collaboration of multiple parts of the system to function properly. The `M` (`midi.send`) function serves as the central output and user interface for this component. It is the only function that the user will be playing with during a session. To operate efficiently, it requires an access to the `parser` for patterning and composing a valid message, to the `clock` for sending its message in musical time and to the `SleepHandler` to precisely time calls between a 'note on' and 'note off' message. By declaring itself to the environment, it gains access to these much needed features that will be accessed transparently without having to deal with the innermost lower-level logic. Consequently, user interaction can be carefully implemented through one minimal function only, letting the system handle the hard and slightly convoluted asynchronous scheduling calls taking place in the background.

~~~~ {.python}
# basic MIDI note scheduling (duration handled by bowl.SleepHandler)
M(note=60, velocity=100, channel=0, dur=0.25)                        
# patterning a similar call with added component-specific logic (strings parsed by bowl.parser)
M(note='C@penta, C.., G3', velocity='80~100', channel='[0:10]', i=i, r=2) 
~~~~
\begin{center}
\textbf{Figure 7:} \textit{Sending MIDI using multiple components of the bowl.}
\end{center}

Similar *senders* or *handlers* can be implemented for various operations requiring collaboration between multiple parts of the system. Given that each of these adhere to the `BaseHandler` abstract base class, adding a component to Sardine does not require any particulary complex addition or refactoring to the base system. Most of the internal critical components of Sardine work by taking advantage of interconnexion of every component, allowing one component to affect the behavior of the whole environment if ever needed.

## Sardine Pattern Language

### Sardine default pattern language

For the sake of demonstration and usability, a small programming language specialised in the writing of musical patterns has been developed for Sardine. This *mininotation* language has been developed using the [Lark](https://github.com/lark-parser/lark) (`LALR` parsing). Its entire source code is directly included in the `sardine` module (in the `sequences/` folder). The need for the creation of a *domain specific language* (DSL) has been felt in order to deal with the limited support provided by Python for syntactic macros (*à la Lisp*) and operators overloading. The use of the *hard* `parser` dependency is limited to parsing string arguments provided to any *handler* `send` method. These `send` functions, common to any sender, are acting as **the principal interface, for patterning and output alike**. They provide a convenient user-facing interface for the creation of complex musical and data pattern evolving through time in the context of a *swimming function*. Patterns play an important role in the workflow of audio/visual live coders, allowing them to define rich evolving structures spanning over time [@magnusson2018performing]. A generic interface -- named `Pat()` -- is also made available to Sardine users in order to increase the *patternability* of any given Python code or function call done in the context of recursive *swimming* calls. This basic test pattern language is best defined as a rich and terse interface dealing with lists of arbitrarily typed elements ranging from numbers to MIDI notes, samples or synthesizer names, OSC addresses, etc... The string input(s) composed by the user for each keyword argument provided to a `send` method is always ultimately resolved by the parser as final arbitrarily-nested list used for composing an output message. Quite possibly, multiple instances to different parsers will be supported in future versions as a way to vary the idioms usable to compose patterns. For now, only one parser is supported in each instance of the `FishBowl`. Its use is entirely optional for users willing to work with different methods.

~~~~ {.python}
Pat('1, 2, 3, 2~40, 5!4, C@fifths', i=i) # standalone call to the parser, yielding one value
D('amencutup:[1,10]', legato='0.1~0.8', room='0.5', dry='[0.1,0.5:0.05]', i=i) # several calls nested
                                         # inside a more densely composed call to SuperDirt.
~~~~
\begin{center}
\textbf{Figure 8:} \textit{Several calls to the parser spread in different Sardine methods}
\end{center}

Extensive support has been dedicated to list-based operations for the composition of sequences. Every basic binary arithmetic operator such as `+`, `-`, `*` or `%`, can work either on single tokens or on lists (on both sides). Lists can be arbitrarily nested. List slicing and value extraction has been re-implemented in a fashion similar to that of its Python counterpart. Unary operators such as `abs()`, `sin()` or similar scientific calculation functions work in a similar way, with the function being functionally mapped to each element of the list if needed. Custom convenience operators have also been defined such as `x~y` (choosing a number in range), `x|y|z` (choosing between *x* elements). Other custom operators have been borrowed to similar pattern languages such as *Ziffers* or *TidalCycles*: `'` for octave up, `.` for octave down, `:` for sample choice, `!` for repetition; among many others. Basic music notation is handled through the conversion of specific tokens to single MIDI notes (`C#4` or `Do#4` parsed as `61`), silences (a dot `.` or multiple dots `...`), list objects (`C@penta` parsed as `[60,62,64,67,69]`) with support for transposition, chord and structure inversion, etc... A complete list of all supported operations is provided to the user through Sardine's documentation. Support for random and generative structures -- even though fairly basic --  has been implemented. Once more, the implementation of this feature has been facilitated by the definition of the *parser* as a component of the `FishBowl`. This allows the parser to query the environment and `bowl.clock` in search of semi-random number generators such as the measure number (`m`) or current execution time given as clock time (`$`).

~~~~ {.python}
# Middle-C MIDI Note with default velocity and channel (M, alias for midi.send)
M(note=60)                         
# C major natural seventh chord with velocity in between 80 and 120, channel either 0, 1 or 2
M(note='<C@maj7>', velocity='80~120', channel='0|1|2', i=i) 
# SuperDirt call, picking samples '0' to '20' in order in the 'drum' folder. Speed parameter
# ramping from 1 to 10 in increments of 2, shape is the sin function of current time divided by 2.
D("drum:[0:20]", speed='[1:10,2]', shape='sin($)/2', i=i)
~~~~
\begin{center}
\textbf{Figure 9:} \textit{Various commented examples of Sardine patterns.}
\end{center}

The querying of values in the multiple patterns defined in each *sender* is done by providing a single pattern-wide *iterator* (labelled as `i`) as an argument to each `send` function. Indexing errors are taken care of by making this index cyclical over the length of each pattern. The design of the iterator is entirely left to the care of the user. Hence, the preferred method for browsing through the reduced list patterns can be chosen depending on context: sequentially, in reverse, using a random number generator, etc... More arguments, namely `rate` and `div`, can help in specifying how the iterator will be applied to the gathered patterns, adding another layer of patterning -- and complexity -- on top of the base mechanism: 

* `rate` (aliased as `r`): *compress* or *extend* the number of iterations needed to move from a list index to the preceding/next. Used as an equivalent to *slowing down* or *speeding up* the iteration over patterns.
* `div` (aliased as `d`): a modulo operation between the iteration count and `div` that will determine if the pattern will be played. This is mainly used to generate interesting rhythms by confronting *senders* calls with different `div`s. 

In our opinion, the iteration-based pattern system is suited to a system based on the concept of temporal recursion. Recursive operations are often used as iteration tools in functional approaches to programming. Multiple iterators can be used in the same pattern by playing around with the `Pat()` mechanism previously described. This allows for the creation of arbitrarily complex patterns composed of multiple values assigned to any parameter accessible through a given *sender*. Even though the list of features provided by the pattern language is dense, its overall architecture is not particularly complex and allows for quick customisation and feature addition from a user willing to do so. This parser also provides a basic workaround for most *patterning duties* while awaiting for the inclusion of new parsers in future versions of the software.

### Planned extensions of the parser mechanism 

The basic Sardine parser has proved to be useful for increasing the playability of the system. However, multiple extensions have been planned and will hopefully be included in future versions. These additions can be split in two categories, the first focusing solely on additions and corrections to the basic parser, the other to the addition of new parsers and to the inclusion of more mininotations. Both are currently priorities of the development team following the end of the rewrite. Support for the [Ziffers](https://github.com/amiika/ziffers) numerical notation created by Miika Alonen, defined as a PEG parser, has already started to take shape. To be properly supported, *Ziffers* will require the inclusion of a new type of `Player` similar to the previously mentioned *surfboards*, relying on the low-level scheduling mechanism. This will allow to test the ease of inclusion of new patterning and live coding paradigms to the Sardine system while opening new ways to write complex melodies and harmonic content. A refactoring of the basic parser is also currently being worked on. Although the pattern language currently supports the definition of custom operators and the function calls with an arbitrary number of arguments, we do not consider that the language is advanced enough to support all the operations we want to support. The addition of high-order functions and easier function calls will now be prioritized, as well as better matching for basic tokens. The basic parser aims to support a large range of functions typically found in most functional programming languages, paving the way for better support of a more functional pattern writing style typically found in other historical live coding libraries.

# Sardine usage

![Sardine in use at the Zorba](images/sardine_code_paper_fig.png){width=100%}\
\begin{center}
\textbf{Figure 10:} \textit{Sardine v0.1.0 code during an algorave (Zorba, Paris), November 3rd, 2022}
\end{center}

Over its relatively short timespan, from September to December 2022, Sardine has already been used multiple times for public music performance. The thrill and danger arising from using an unstable and unpolished software has constituted an obstacle as well as an appealing perspective for most users [@roberts2018]. Jams, informal meetings and dialogue with the wider live coding community were also of the utmost importance to study the relevance and/or the inefficiency of integrating Sardine, in often already pre-established musical contexts. Here we mention a few specific examples of Sardine usage, and show how being able to live code in Python provides unique advantages (and also potential disadvantages). Numerous specialised devices or handlers have been created to facilitate Sardine interacting with other systems. Hybridations between multiple live coding environments, such as *Sardine*/*TidalCycles* and *Sardine*/*Sonic Pi* have been tried successfully. Initial failures mostly arised from improper or careless implementations of the synchronisation mechanism. Documentation pertaining to the implementation of live-coding oriented musical clocks and synchronisation mechanism is scarce and most of it had to be inferred from the inner workings of similar open-source libraries. In order to help with the collective effort of documenting live coding practices, we hope to upload a very thorough explanation of the system on the Sardine website to help future developers.

A proto-sender specialised in SysEx communication with a Yamaha TX7 synthesizer unit has been designed by Raphaël in order to enhance melodic and timbral capabilities of *Ralt144MI* (Rémi Georges) current live coding setup, previously mostly based on TidalCycles, MIDI controllers and audio-video hardware. Using a simple dictionary of `lambda` functions, this mechanism uses the previously described `Pat()` function to provide a general patterning interface for each individual parameter defined in the MIDI specification of the unit. Subsequent performances led to the inclusion of more bespoke mechanisms that ultimately made their way into the main codebase, having been proved useful in the context of live performances (`span`, `snap`, support for polyphony, etc...). This experience also proved the usefulness of adding better support for the definition of custom-fit *senders* and output/patterning interfaces.

\Begin{multicols}{2}

![*Tölvera artificial life simulation run inside a Sardine `@swim` function.*](images/tolvera.jpg){width=49%}\
\textbf{Figure 11:} \textit{Tölvera artificial life simulation run inside a Sardine `@swim` function.}

At the Intelligent Instruments Lab in Reykjavík, Jack Armitage has been using Sardine to live code the Magnetic Resonator Piano (MRP) [@mcphersonAugmentingAcousticPiano2010]. In this case, Sardine enabled developing a Python API client for the MRP much more interactively, due to being able to redefine `@swim` functions on the fly. Another attractive feature of Sardine being written in Python in this case, is that the entire Python ecosystem can be explored for machine learning based approaches to instrumental control and interaction^[Python codebase for the Magnetic Resonator Piano: \url{https://github.com/Intelligent-Instruments-Lab/iil-mrp-tools/}]. This also positions Sardine as a bridging platform for researchers and practitioners interested in hybrid live coding interfaces, as in this case where live coding and instrumental practices are blurred. Jack Armitage has also been live coding artificial life simulations using Sardine, in the _Tölvera_ library as part of the _Agential Scores_ project [@agential]. This is one of the first examples of Sardine being used for visual output. In this case, the Taichi numerical simulation library was able to run its animation frame loop as a `@swim` function, with Sardine's recursion occurring fast enough to give 60fps graphics^[Code from this experiment can be found on the _Tölvera_ GitHub repository: \url{https://github.com/Intelligent-Instruments-Lab/iil-python-tools}] (see Figure 11). These early examples showed the diversity of approaches that are possible in the Python ecosystem, and they also usefully highlighted usability pain points and performance bottlenecks with Sardine. As a result, substantial rewriting efforts have been taking place to accommodate these needs. Motivation for the rewrite process was found in the perspective to support more of these creative endeavours that would be hard to undertake in more closed or less configurable live coding systems.

\End{multicols}

# Conclusion

## Current issues and shortcomings

Sardine is both a new software/environment and an architecture model for a Python based live coding library. Developed only by a small dedicated team of developers with few enthusiastic users, some features are already hard to keep a track of for they are not often used. Much needed updates to specific parts of the system are currently delayed to address more urgent concerns. To help keeping track of the current state of the system, tests have recently been introduced. However, better code coverage is still much needed to track each specific component and their mutual interaction. Only time critical parts of the system are currently extensively covered. Most of the rewrite work for `v.0.2.0` has been focused on improvements to the temporal model and component handling. Although very promising, it remains fragile and requires careful and time-consuming testing to keep track of regressions and possible issues brought by additions to the model. Regular updates are being provided to increase the *playability* of the system. 

Sardine is in dire need of documentation focused on new and unexperienced users. The installation process -- despite being now more accessible than ever -- still requires the manual configuration of a suitable text editor and the installation of a full Python runtime. The documentation currently only provides a thorough tour and exploration of the system but lacks friendly videos, text tutorials and contents that could lead to the adoption of Sardine by more users. As a temporary solution for demonstrating the capabilities of the system, we actively provide the code used by performers in a special `Demo` section included on the website. Automatic documentation of the codebase is planned to help with the process of maintaining good technical documentation, liberating time to focus on user-focused contents. Every part of the source code is extensively documented for contributors, but currently unavailable to surface users not willing to deep dive into the source code. The modularity of Sardine can be considered as its major strength and weakness. The first configuration of the software can be quite intimidating for newcomers that doesn't yet know what task they wish to accomplish using Sardine (MIDI, OSC, SuperDirt, etc..). Most options are disabled by default and must be added manually to configure a session.

## Learning, contributing, testing

The Sardine system project is already freely usable and modifiable by its users. It is currently hosted on GitHub under the GNU General Public License v.3.0. We warmly encourage anyone interested to actively try this experimental system in order to help us with chasing bugs and/or collectively build this new live coding system. A Discord server and a TOPLAP `#sardine` channel are used for communication around the project. Sardine is currently by no mean as complete or as fully featured as other existing propositions used by the community. We are still in the process of catching up with known alternatives, thinking as Sardine as a way to extend or collaborate with other musicians and visualists using different live coding environments.

# Acknowledgments

I warmly thank my thesis supervisors Laurent Pottier and Alain Bonardi for their support and advice in the creation of this tool. I thank the doctoral school *3LA* from the University of Lyon for the funding it provided to this research. I extend my thanks to the musicians and friends who allowed me to take **Sardine** on stage and to present it to a wider audience these few last months: the **Cookie Collective**, Rémi Georges, Yassin Siouda and many more from the online Sardine chat channels.

# References
